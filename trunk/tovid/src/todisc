#!/usr/bin/env bash
ME="[todisc]:"
. tovid-init
# todisc
# Part of the tovid suite
# =======================
# A bash script for generating a DVD or SVCD
# with many styles of animated and static menus,
# from a collection of MPEG video files.
#
# Project homepage: http://www.tovid.org


# Copyright (C) 2005 tovid.org <http://www.tovid.org>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. Or see:
#
#           http://www.gnu.org/licenses/gpl.txt


# Mostly written by Robert Sohn:
#     <grepper@gmail.com>
#     grepper on irc.freenode.net

SCRIPT_NAME=`cat << EOF
--------------------------------
todisc
Generate a DVD filesystem with animated thumbnail menus
Part of the tovid suite, version $TOVID_VERSION
$TOVID_HOME_PAGE
--------------------------------
EOF`

USAGE=`cat << EOF
Usage:
    todisc [OPTIONS] \\\\
      -files File1.mpg File2.mpg ... \\\\
      -titles "Title 1" "Title 2" ... \\\\
      -out OUT_PREFIX
Input files must be MPEG, and the number of -files and -titles must be equal.
See the todisc manual page ('man todisc') for additional documentation.

EOF`
# check that needed todisc deps are installed
assert_dep "$todisc_deps"
# check if symlink in /tmp exists and use time stamped link if so
WORK_DIR="/tmp/todisc-work"
CUR_DIR=$(readlink -f "$PWD")
# make unique REAL_WORK_DIR
REAL_WORK_DIR="$CUR_DIR/todisc-work"
LOG_FILE=$(readlink -f todisc.log)
#RECURSIVE_LOG_FILE=$(tempfile -s -todisc.log)
OUT_PREFIX=""
TV_STANDARD=ntsc
MENU_LEN=( 20 )
USER_MENU_LEN=false
ANI_SUBMENU_LEN=10
MAX_MENU_LEN=""
TARGET=dvd
FRAME_RATE=29.970
VIDSIZE=720x480
MENU_TITLE="My Video Collection"
STATIC=false
SUB_MENU=false
ANI_SUB_MENU=false
TITLE_COLOUR="#CDC0B0"
SM_TITLE_COLOUR="#CDC0B0"
THUMB_BG_COLOUR=white
THUMB_TEXT_COLOUR=""
BUTTON_STYLE="rect"
MIST_COLOUR=white
MIST_OPACITY=60
STROKE=""
SUBMENU_STROKE="none"
BG_AUDIO=""
BG_PIC=""
BG_VIDEO=""
SHOWCASE=false
SUBMENU_AUDIO=false
SM_AUDIO_FADE=:
SM_FADE=1
AUDIO_FADE=:
OPACITY=100
MENU_FADE=false
TRANSPARENT=false
PREVIEW=:
PAUSE_TIME=10
STATIC_LOOP=false
MIST=false
FEATHER=false
BLUR=4
SUB_MENU_FEATHER=false
IMG_FMT=jpg
SM_IMG_FMT=jpg  # submenu image format
KEEP_FILES=false
THUMB_SHAPE=""
SEEK_VAL=2
USER_SEEK_VAL=false
FADE=1
CHAPTERS=( 6 )
TOVID_OPTS=""
CHAIN_VIDEOS=false
NOASK=false
SC_FRAMESTYLE="none"
THUMB_FRAME="-frame 3x3"
SC_BORDERWIDTH=4x4
SC_FRAME="-bordercolor  #6E6E6E -compose Copy -border $SC_BORDERWIDTH -blur 0x0.4"
SHOWCASE_VIDEO=""
THREExONE=false
FOURxONE=false
PLAYALL=false
USE_MAKEMENU=false
THUMBS_3D=false
RAISE=""
CURVE_UPDATE=""
SUBTITLES=false
AUDIOLANG=false
USER_BSTYLE=false
SHOWCASE_SEEK_VAL=2
BG_SEEK=2
BG_AUDIO_SEEK=2
USER_BG_AUDIO_SEEK=false
SC_THUMB=:
TEXTMENU=false
SC_TITLE_ALIGN=center
THUMB_TITLE_ALIGN=center
ALIGN_OVERRIDE=false
MULTILINE_TITLE=false
SAFE_AREA=50 # undocumented: you can set this from CLI with -showcase-safe-area
SAFE_OFFSET=36
ASPECT_RATIO=4:3
AR=1.333
ASPECT_ARG=all
WIDE_SCREEN=false
WIDESCREEN="nopanscan"
GROUPING=false
TEXT_YSTART=$SAFE_AREA
BUTTON_GRAVITY=north
XGEO=0
YGEO=45
USER_GRAVITY=false
USER_GEO=false
USER_SPLIT=false
TITLE_GRAVITY=south
SPACER=15
SELECT_CLR="#DE7F7C"
HLIGHT_CLR="#266CAE"
USER_SC_GEO=false
USER_SAFE_AREA=false
USER_TITLE_GEO=false
SPACER=""
SE_YCORNER=0
WARN=true
ROTATE_THUMBS=false
DO_TITLESETS=false
AUTHOR=:
ts_start=0
args=( "$@" )
VMGM_ONLY=false
TITLESET_MODE=false
TSET_NUM=1
MENU_NUM=1
INTRO=""
QUICK_NAV=false
SKIP_VMGM_MENU=false
VMGM_MENU=:
MONTAGE_MENU=:
DO_MENU=:
DO_STATS=:
DO_FRAME=:
DO_BUTTONS=:
SWITCHED_MENUS=false
SWITCHED_MODE=false
SWITCHED=false
TSET_MODE=false
TSET_TOT=1
NONAME=false
DO_INTRO=false
USE_MPLAYER_4AUDIO=false
MENU_AUDIOLENGTH=""
USER_AUDIOLENGTH=false
USER_AUDIO_FADE=false
BURN=false
BURN_DEVICE="/dev/dvdrw"
QUICK_MENU=false
BG_COLOUR=161514
SUBMENU_BG_COLOUR=161514
QM_PREVIEW=false
USER_CHAPTERS=false
QUICKMENU_IS_SHOWCASE=false
QUICKMENU_IS_BACKGROUND=false
RESIZE_BG=false
DO_SLIDE_MIX=false
SLIDESHOW=false
KEEPALL_FILES=false
SLIDE_FADE=false
MTG_GEO="+10+4"
MENUBUTTONS_ARE_CHAPTS=false
SCRIPT_START_TIME=`date +%s`

##############################################################################
#                                 Functions                                  #
##############################################################################

# Y-echo: echo to two places at once (stdout and logfile)
# Output is preceded by the script name that produced it
# Args: $@ == any text string
# If no args are given, echo a separator bar
# Use yecho if you want output to go to the logfile
function yecho()
{
    if test $# -eq 0; then
        printf "\n%s\n\n" "$SEPARATOR"
        # If logfile exists, copy output to it (with pretty formatting)
        test -e "$LOG_FILE" && \
            printf "%s\n%s %s\n%s\n" "$ME" "$ME" "$SEPARATOR" "$ME" >> "$LOG_FILE"
    else
        echo "$@" | sed "s/    */ /g;s/^ *//"|fold -bs
        test -e "$LOG_FILE" && \
            printf "%s %s\n" "$ME" "$@" | sed "s/    */ /g;s/^ *//"|fold -bs >> "$LOG_FILE"
    fi
}

# ******************************************************************************
# Execute the given command-line string, with appropriate stream redirection
# Args: $@ == text string containing complete command-line
# Returns: Exit status of the subprocess
# To filter/prettify the subprocess output before writing it to the log file,
# set the LOG_FILTER variable before calling this function, to e.g.
#    LOG_FILTER="sed 's/\r/\r\n/g'"    # Replace LF with CR/LF
# ******************************************************************************

function cmd_exec()
{
    eval "$@" 2>&1 | ${LOG_FILTER:=cat} # >> "$LOG_FILE"
    # Return exit status
    return $?
}

# Print script name, usage notes, and optional error message, then exit.
# Args: $@ == text string(s) containing error message and help
function usage_error()
{
    MESSAGE=( "$@" )
    printf "%s\n%s\n%s\n\n" "$USAGE" "$SEPARATOR" "***"
    for ((i=0; i<$#; i++)) ; do printf "%s" "${MESSAGE[i]}"; done |format_output
    printf "\n\n%s\n" "***"
    rm -rf "$REAL_WORK_DIR" "$WORK_DIR"
    if $SWITCHED_MODE || $SWITCHED_MENUS || $TITLESET_MODE || $DO_TITLESETS; then
        killall_instances
    fi
    exit 1
}
function titlesafe_error()
{
    echo "***** WARNING *****"
    yecho "thumb title is $1 pixels from screen edge"
    yecho "Part of the title may not be visible on your tv screen"
    yecho "Consider using a smaller -thumb-fontsize, or shortening \"${TITLES[i]}\""
    echo "****************************"
    $WARN && sleep 3
}

function format_output()
{
    sed "s/    */ /g;s/^ *//"|fold -bs
}

function get_font()
{
    # If there is a filename extension, find the absolute path
    if echo "$1" | grep -q '\...*$'; then
        echo $(readlink -f "$1")
    # Otherwise, use the literal name
    else
        echo "$1"
    fi
    # TODO: Check for font availability?
}

# ******************************************************************************
# Print out a runtime error specified as an argument, and exit
# ******************************************************************************

vid_length()
{
    check_frames=""
    [[ -n $2 ]] && check_frames=$2 && check_frames="-frames $check_frames"
    echo "Using mencoder to get length of $1" >> "$LOG_FILE"
    L=$(mencoder -nosound -mc 0 -oac pcm -ovc copy $check_frames -o /dev/null "$1" 2>> "$LOG_FILE")
    awk 'END{print $(NF-3)}' <<< "$L"
}
audio_length()
{
    [[ -n $2 ]] && ENDPOS="-endpos $(format_time $2)"
    mplayer $ENDPOS -speed 20  -vo null -ao null "$1"  2>&1 |
    tr '\r' '\n' |
    grep ^A: |
    tail -n 1 |
    sed s/^.*A:// |
    awk '{print $1}'
}
cleanup()
{
    echo
    yecho "Cleaning up..."
    if test -s "$WORK_DIR/tcode*.pid"; then
        for pidfile in "$WORK_DIR/tcode*.pid"; do
            if kill -0 $(<$pidfile) 2> /dev/null; then kill -9 $(<$pidfile) 2> /dev/null; fi
        done
    fi
    if kill -0 $TCODE_PID 2> /dev/null; then kill -9  $TCODE_PID  2> /dev/null; fi
    if kill -0 $TRANSCODE_PID 2> /dev/null; then kill -9  $TRANSCODE_PID 2> /dev/null; fi
    if kill -0 $NS_PID 2> /dev/null; then kill -9 $NS_PID 2> /dev/null; fi
    if $KEEP_FILES; then
        yecho "Keeping temporary files in $REAL_WORK_DIR"
        [[ -n $SUPPORT_VIDEOS ]] && yecho "Keeping ${SUPPORT_VIDEOS[@]}" && \
            yecho "This sliced video will not work if todisc is run with different seeks so should be deleted manually"
    else
        if [[ -d $REAL_WORK_DIR ]]; then
            yecho "Removing $REAL_WORK_DIR"
            [[ -n $SUPPORT_VIDEOS ]] && yecho "Removing "${SUPPORT_VIDEOS[@]}"" && rm -f "${SUPPORT_VIDEOS[@]}"
            rm -rf "$REAL_WORK_DIR"
        fi
    fi
    echo "Removing the symlink in /tmp . . . "
    rm -fv "$WORK_DIR"
}

# exit from all recursive todisc calls
killall_instances()
{
    for P in $todisc_pids ; do
        kill $P
    done
}

runtime_error()
{
    # Uncomment if needed later
    #killsubprocs
    echo
    echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    yecho "todisc encountered an error:"
    yecho "    $@"
    echo
    echo "Check the contents of $LOG_FILE to see what went wrong."
    echo "See the tovid website ($TOVID_HOME_PAGE) for what to do next."
    echo "Sorry for the inconvenience!"
    echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    cleanup
    if $SWITCHED || $TITLESET_MODE || $DO_TITLESETS; then
        killall_instances
    fi
    exit 1
}

running_total ()
{
    LC_ALL="C" awk -v offset=$offset '{
    for (i=1; i<=NF; i++) if (s=s+$i) printf("%s ",s);printf ("\n")}'
}

awk_total()
{
    LC_ALL="C" awk '{for (i=1; i<=NF; i++) s=s+$i}; END{print s}'
}

format_seconds()
{
    LC_ALL="C"  awk '{
    hr=($1/3600); hd=(sprintf("%02d", hr))
    mr=((hr-hd)*60); md=(sprintf("%02d", mr))
    s=((mr-md)*60); sd=(sprintf("%02d", s))
    t=(sprintf("%02d:%02d:%06.3f" ,hd,md,s)); print t}' <<< $1
}

# TODO get rid of awk_math and use bc as below
bc_math()
# usage: bc_math "expression" [int]
{
    bc_out=$(bc <<< "scale=3;$1" 2>/dev/null)
    [[ -n $2 && $2 = "int" ]] && bc_out=${bc_out%.*}
    echo "$bc_out"
}

confirm_preview()
{
    confirm_msg="type 'yes' to continue: "
    yecho
    if $SWITCHED || $TITLESET_MODE || $VMGM_ONLY; then
        echo "If doing titlesets or switched menus and you wish to exit "
        echo "without seeing more previews, then type: 'exit', else you will "
        echo "continue on with other previews even if you don't type 'yes'."
        echo
        confirm_msg="read above paragraph and then $confirm_msg"
    fi
    echo "If you are happy with the preview, $confirm_msg"
    read input
    echo
    if [ ! -z "$input" -a "$input" = "yes" ]; then
        yecho "Preview OK, continuing."
        yecho
    else
        yecho "Preview not OK, exiting."
        echo -n "Deleting symlink in /tmp . . . "
        rm -fv "$WORK_DIR"
        if ! $KEEP_FILES; then
            echo -n "Deleting "$REAL_WORK_DIR" . . . "
            rm -fr "$REAL_WORK_DIR"
        fi
        yecho
        echo
        echo "Some configuration options to try, if things look bad:"
        echo "Color:"
        echo "    -title-color"
        echo "    -thumb-text-color"
        echo "Fonts:"
        echo "    -menu-font and -menu-fontsize"
        echo "    -thumb-font and -thumb-fontsize"
        echo "(or reduce thumb title lengths)"
        echo "If you get black frames, then look at the -seek option"
        echo "For other fine-tuning options, see 'man todisc'."
        [ ! -z "$input" -a "$input" = "exit" ] && killall_instances
        exit 0
    fi
#    yecho
}

# Display (echo) a spinner with a message
SP=0
spin()
{
    SPIN_CHARS=".oOo"
    SPINNER="${SPIN_CHARS:SP++%${#SPIN_CHARS}:1}"
    # Print spaces to overwrite previous line
    echo -ne "\r                                                            "
    echo -ne "\r$@ "
}

#EXPAND="expand=-6:-6,"
get_framed_pics()
{
mplayer -ss $MPLAYER_SEEK_VAL -vo $VOUT -noconsolecontrols \
-vf ${EXPAND}rectangle=${FRAME_SIZE/x*}:${FRAME_SIZE/*x},rectangle=$(( ${FRAME_SIZE/x*} - D )):$(( ${FRAME_SIZE/*x} - D)),rectangle=$(( ${FRAME_SIZE/x*} - $((D * 2)) )):$(( ${FRAME_SIZE/*x} - $((D * 2)) )),rectangle=$(( ${FRAME_SIZE/x*} - $((D * 3)) )):$(( ${FRAME_SIZE/*x} - $((D * 3)) )) \
-nosound -zoom -x ${FRAME_SIZE/x*} -y ${FRAME_SIZE/*x}  -frames $FRAMES "$1"
}

# Create a text-only menu, using makemenu/makexml
call_makemenu()
{
    # Assemble and run makemenu command
    MENU_OUT="${OUT_PREFIX}_menu"
    MAKEMENU="makemenu"
    for ((i=0; i<${#TITLES[@]}; i++)); do
        MAKEMENU="$MAKEMENU \"${TITLES[i]}\""
    done
    MAKEMENU="$MAKEMENU -textcolor \"$TITLE_COLOUR\""
    test -n "$BG_PIC" && MAKEMENU="$MAKEMENU -background \"$BG_PIC\""
    test -n "$MENU_FONT" && MAKEMENU="$MAKEMENU -font \"$MENU_FONT\""
    test -n "$MENU_FONTSIZE" && MAKEMENU="$MAKEMENU -fontsize \"$MENU_FONTSIZE\""
    MAKEMENU="$MAKEMENU -out $MENU_OUT"

    echo "Running the following makemenu command:"
    echo $MAKEMENU
    cmd_exec "$MAKEMENU"

    # Assemble and run makexml command
    MAKEXML="makexml -menu $MENU_OUT.mpg -out $OUT_PREFIX"
    for ((i=0; i<${#FILES[@]}; i++)); do
        MAKEXML="$MAKEXML \"${FILES[i]}\""
    done
    MAKEXML="$MAKEXML -out $OUT_PREFIX"
    echo "Running the following makexml command:"
    echo $MAKEXML
    cmd_exec "$MAKEXML"

    # Assemble and run makedvd command
    MAKEDVD="makedvd -author ${OUT_PREFIX}.xml"
    echo "Running the following makedvd command:"
    echo $MAKEDVD
    cmd_exec "$MAKEDVD"
}

stat_logfile()
{
    stat -L -c "%Y" "$LOG_FILE"
}

get_line_count()
{
awk 'END{print NR}' "$LOG_FILE"
}

# hack to check if transcode is stalling and set it a HUP if so
# usage: check_stall PID
check_stall()
{
    PIDOF_TRANSCODE=$1
    newlines=$(stat_logfile)
    while ps -p $PIDOF_TRANSCODE >/dev/null; do
        # Check for transcode output every 10 seconds
        sleep 10
        age=$newage
        newage=$(stat_logfile)
        # If no new output, sleep 20s and check again
        [[ $newage = $age ]] && sleep 20 && newage=$(stat_logfile)
        # If still no new lines, send a HUP signal to transcode
        if [[ $newage == $age ]] && kill -0 $PIDOF_TRANSCODE > /dev/null 2>&1; then
            echo
            echo "*** transcode appears to be stalled ***"
            echo "*** We are going to send transcode a HUP and hope for the best ***"
            sleep 5
            $(kill -0 $PIDOF_TRANSCODE > /dev/null 2>&1) && kill -HUP $PIDOF_TRANSCODE
            echo
        fi
    done
}
check_filetype()
{
    fstats=$(file -L "$1")
    if [[ $fstats =~ "image data" || $fstats =~ "bitmap data" ]]; then
        TYPE=image
        CONVRT=:
        if [[ $fstats = *JPEG* || $fstats = *PNG || $fstas = *PPM* ]]; then
            CONVRT=false
        fi
    elif mencoder -endpos 2 -oac pcm -ovc copy  "$1" -o /dev/null  >/dev/null 2>&1; then
        TYPE=video
    else TYPE=unknown
    fi
}

get_stats()
{
unset IN_STATS FILES_IN
this_set=$1
if [[ $this_set = "group" ]]; then
    unset TOT IN_STATS FILES_IN
    TOT=${#grouping[@]} # || TOT=${#IN_FILES[@]}
    IN_STATS=( "${group_idvid_stats[@]}" )
    FILES_IN=( "${grouping[@]}" )
else
    TOT=${#IN_FILES[@]}
    IN_STATS=( "${idvid_stats[@]}" )
    FILES_IN=( "${IN_FILES[@]}" )
fi
for ((i=0; i<TOT; i++)); do
    VCODEC="$(awk -F= '/ID_VIDEO_FORMAT/ {print $2}'    <<< "${IN_STATS[i]}")"
    V_BR="$(awk -F= '/ID_VIDEO_BITRATE/ {print $2}'    <<< "${IN_STATS[i]}")"
    ACODEC="$(awk -F= '/ID_AUDIO_CODEC/ {print $2}'    <<< "${IN_STATS[i]}")"
    A_BR="$(awk -F= '/ID_AUDIO_BITRATE/ {print $2}'    <<< "${IN_STATS[i]}")"
    if [ -z "$A_BR" ]; then
        A_BR="No audio found"
    fi
    V_LENGTH=${VID_LEN[i]}
    [[ $this_set = "group" ]] && V_LENGTH=${GROUP_VID_LEN[i]} 
    FPS="$(awk -F= '/ID_VIDEO_FPS/ {print $2}'    <<< "${IN_STATS[i]}")"
    yecho
    if [[ $this_set = "group" ]] && ((i == 0)); then
        echo; echo ". . . Grouped file stats . . ."; echo
    yecho
    fi
    [[ $this_set = "group" ]] && echo -e "Stats for" $(readlink "${FILES_IN[i]}") "\n" || \
    echo -e "Stats for" "${FILES_IN[i]}" "\n"
    echo -e  \
    " video codec:   " \
    "$VCODEC" "\n" \
    "video bitrate: " "$V_BR" "bits per second" "\n" \
    "framerate:     " "$FPS" "fps" "\n" \
    "audio codec:   " \
    "$ACODEC" "\n" \
    "audio bitrate: " \
    "$A_BR" "bits per second" "\n" \
    "video length:  " \
    "$V_LENGTH" "seconds" |tee -a "$LOG_FILE"
done
}
test_compliance()
{
    file_in="$1"
    if idvid -isformat ${TV_STANDARD}-${TARGET} "$file_in" >/dev/null; then
        :
    else
        return 1
    fi
}
    

check_compliance()
{
    unset FILES_TO_ENCODE ENC_IN_FILES CHECK_IN_FILES
    group_set=false
    if [[ $1 = "group" ]]; then
        group_set=:
        unset x a
        CHECK_IN_FILES=( "$WORK_DIR"/${TSET_NUM}-group-*.mpg )
    else
        CHECK_IN_FILES=( "${IN_FILES[@]}" )
    fi
    for ((i=0; i<${#CHECK_IN_FILES[@]}; i++)); do
        IN_FILE=${CHECK_IN_FILES[i]}
        if [[ ${#CHECK_IN_FILES[@]} -le 30 ]]; then
            echo "Checking $(readlink -f "$IN_FILE") for compliance..."
        else
            spin "Checking files for compliance..." $SPINNER
        fi
        # if file tested as an image when we were verifying input files 
        $group_set && is_image=${grp_file_is_image[i]} || is_image=${file_is_image[i]}
        if [[ $is_image = "yes" ]]; then
            # ffmpeg image2 can't handle 16 bit depth
            if $group_set && [[ $(identify -format "%z" "$IN_FILE") = 16 ]]; then
                if $SWITCHED \
                  && [[ -s ${IN_FILE/.todisc_enc.*}.todisc_enc.png ]]; then
                    : # do not keep reencoding the same file
                else
                    convert "$IN_FILE" -depth 8  \
                      "${IN_FILE/.todisc_enc.*}.todisc_enc.png"
                fi
                IN_FILE="${IN_FILE/.todisc_enc.*}.todisc_enc.png"
            fi
            $group_set && grp_use_image2mpeg2[i]="yes" || use_image2mpeg2[i]="yes"
            FILES_TO_ENCODE[i]="$IN_FILE"
            ENC_IN_FILES=("${ENC_IN_FILES[@]}" "${IN_FILE/.todisc_enc.*}.todisc_enc.mpg")
        # test files with idvid script
        elif test_compliance "$IN_FILE" && [[ $TOVID_OPTS != *-force* ]] ; then
            ENC_IN_FILES=("${ENC_IN_FILES[@]}" "$IN_FILE")
        # Video needs to be re-encoded; use a .enc filename in ENC_IN_FILES
        else
            FILES_TO_ENCODE[i]="$IN_FILE"
            ENC_IN_FILES=("${ENC_IN_FILES[@]}" "${IN_FILE/.todisc_enc.*}.todisc_enc.mpg")
        fi
    done
    if test "${#FILES_TO_ENCODE[@]}" -gt 0; then
        TGT_CAPS=$(echo $TARGET | tr a-z A-Z)
        TV_STND_CAPS=$(echo $TV_STANDARD | tr a-z A-Z)
        echo
        yecho "Encode input files"
        echo
        yecho "Some of the -files you provided are not $TV_STND_CAPS $TGT_CAPS-compliant:"
        echo " "
        if test ${#FILES_TO_ENCODE[@]} -lt 30; then
            for i in "${FILES_TO_ENCODE[@]}"; do
                this_file=$(readlink -f "$i")
                test -n "$this_file" && yecho " $this_file"
            done
        fi
        yecho " "
        if ($SWITCHED && [[ $MENU_NUM -ne 2 ]]) || $NOASK || [[ $TOVID_OPTS = *-noask* ]]; then
            echo "Converting files to $TV_STND_CAPS $TGT_CAPS-compliant format."
            echo "(This may take a long time)"
            ENCODE="yes"
        else
            yecho "I can encode them for you, but it may take a long time."
            yecho "Encoding will ensure that your disc is fully compliant;"
            yecho "you may skip this, but your disc may not be playable."
            yecho "Please type 'yes' if you want the files to be encoded:"
            read ENCODE
        fi
        if test -n "$ENCODE" && test "$ENCODE" = 'yes'; then
            yecho
            yecho "Converting files to $TGT_CAPS format"
            yecho
            for i in "${!FILES_TO_ENCODE[@]}"; do
                
                IN=$(readlink -f "${FILES_TO_ENCODE[i]}")
                if $group_set; then
                    convert_image=${grp_use_image2mpeg2[i]}
                else
                    convert_image=${use_image2mpeg2[i]}
                fi
                    
                if [[ $convert_image = "yes" ]]; then
                    if $SWITCHED && \
                     [[ -s "${IN/.todisc_enc.*}.todisc_enc.mpg" ]]; then
                        :
                    else
                        spin "Processing" "${IN##*/}"
                        image2mpeg2 "$IN" stills
                    fi
                    # AUDIO_FADE=false # do not fade silence FIXME ???
                else
                    THIS_FILE=$(readlink -f "${FILES_TO_ENCODE[i]}")
                    yecho "Converting $THIS_FILE"
                    echo
                    countdown 3
                    tovid $NO_ASK -$TV_STANDARD -$TARGET -in "$IN" \
                    -out "${IN}.todisc_enc" $TOVID_OPTS
                fi
                wait
                # See if output file exists
                if ! test -f "${IN/.todisc_enc.*}.todisc_enc.mpg"; then
                    runtime_error "Could not encode file: $IN"
                fi
                #yecho
            done
            
            # Replace IN_FILES with ENC_IN_FILES (with .enc extension)
            if $group_set; then
                for title in "${FILES_TO_ENCODE[@]}"; do
                    ln -sf \
                      "$(readlink "${title/.todisc_enc.*}").todisc_enc.mpg" "$title"
                done
            else
                 IN_FILES=("${ENC_IN_FILES[@]}")
            fi
        else
            yecho
            yecho "Not re-encoding. I will proceed with menu generation, but"
            yecho "your authored disc will not be fully $TGT_CAPS-compliant."
            yecho
        fi
    fi
}

# check bgvideo and showcase VIDEO for compliance
tovid_reencode()
{
    VIDEO_IN="$1"
    VIDEO_IN_SEEK="$2"
    video_type=$3
    yecho
    yecho "$VIDEO_IN is not compliant - re-encoding 
      $(bc <<< "$VIDEO_IN_SEEK + ${MENU_LEN[MENU_NUM-1]}" 2>/dev/null) 
        second slice to DVD compliant file"
    yecho "For long seeks this will take some time and produce a large file."
    yecho "But if the file is not encoded this way there may be sync problems."
    yecho "Do you want to continue encoding this file?, type 'yes' to do so"
    if ! $NOASK; then
        read response
        if [ ! -z "$response" -a "$response" = "yes" ]; then
            :
        else
            return
        fi
    fi
    yecho
    yecho "Converting files to $TGT_CAPS format with 'tovid'"
    countdown
    tovid $NO_ASK -in "$VIDEO_IN" \
    -slice 0-$(bc <<< "$VIDEO_IN_SEEK + ${MENU_LEN[MENU_NUM-1]}" 2>/dev/null) \
    -${TV_STANDARD} -${TARGET} -in "$VIDEO_IN" -out "${VIDEO_IN}.todisc_enc" $TOVID_OPTS
    # See if output file exists
    if ! test -f "${VIDEO_IN}.todisc_enc.mpg"; then
        runtime_error "Could not encode file: $VIDEO_IN"
    else
        [[ $video_type = showcase ]] && SHOWCASE_VIDEO="${VIDEO_IN}.todisc_enc.mpg"
        [[ $video_type = background ]] && BG_VIDEO="${VIDEO_IN}.todisc_enc.mpg"
    fi
    SUPPORT_VIDEOS=( "${SUPPORT_VIDEOS[@]}" "${VIDEO_IN}.todisc_enc.mpg" )
    yecho
}

mk_workdir()
{
    REAL_WORK_DIR=$(tempdir $CUR_DIR/todisc-work)
    WORK_DIR=$(tempdir /tmp/todisc-work nocreate)
    # tempdir() made a unique name with nocreate, now make it a symlink
    ln -sfv "$REAL_WORK_DIR" "$WORK_DIR"
}


get_group_chapters()
{
    FORMAT=false
    index=$1
    [[ -n $2 && $2 = "format" ]] && FORMAT=:
    $USER_CHAPTERS && FORMAT=false
    unset chapt_len_array x len remainder y e
    remainder=0
    chapter_length=$( bc <<< "scale=3; ${GROUP_TOT_LEN[index]} / \
    ${CHAPTERS[index]}" 2>/dev/null)
    GROUP_VIDEO_LENGTHS=( ${GROUP_VID_LENGTHS[index]} )
    if $USER_CHAPTERS; then
        unset grp_arb_chts y
        grp_arb_chts=( ${group_arbitrary_chapters[index]} )
        
        for y in ${!grp_arb_chts[@]}; do
            [[ $y -eq 0 ]] && chpts0="chapters=\"${grp_arb_chts[y]}\""
            if [[ ${grp_arb_chts[y]} = 0 ]]; then
                chpts[y]=""
            else
                chpts[y]="chapters=\"${grp_arb_chts[y]}\""
            fi
        done
    else
#        unset chapt_len_array remainder e
        for len in ${GROUP_VIDEO_LENGTHS[@]}; do
            adjusted_length=$( bc <<< "scale=3; $len + $remainder" 2>/dev/null)
            num_chapters=$( bc <<< "$adjusted_length / $chapter_length" \
            2>/dev/null )
            if (( num_chapters > 0)); then
                chapt_len_array=( $( for ((t=0; t<num_chapters; t++)); do
                echo $chapter_length; done) )
                chapt_len_array=($(bc <<< "scale=3; $chapter_length - $remainder" \
                2>/dev/null) ${chapt_len_array[@]})
                unset chapt_len_array[${#chapt_len_array[@]}-1]
                chapter_points=$( running_total <<< ${chapt_len_array[@]} )
                remainder=$( bc <<< "$adjusted_length % $chapter_length" \
                2>/dev/null)
                group_chapters[x++]=$chapter_points
            else
                group_chapters[x++]=""
                remainder=$adjusted_length
            fi
        unset chapt_len_array
        done
        unset remainder
    fi
    if $FORMAT; then
        for d in ${!group_chapters[@]}; do
            for number in ${group_chapters[d]}; do
                new_element="$new_element $(format_seconds $number),"
            done
            array[d]="$new_element"
            unset new_element
        done

        for e in ${!array[@]}; do
            points=$(for f in ${array[e]// /}; do echo -n $f;done)
            if [[ -z ${array[e]} ]]; then
                [[ -n ${chapts[e]} ]] && unset chpts[e]
            else
                chpts[e]="chapters=\"${points%,}\""
            fi
            [[ -n ${array[e]} ]] && chpts[e]=${chpts[e]#,}
            if ((e == 0)); then
                if [[ -z "$points" ]]; then
                    chpts0="chapters=\"00:00:00\""
                else
                    chpts0="chapters=\"00:00:00,${points%,}\""
                fi
            fi
            chpts=${chpts[@]#,}
        done
    fi
}

get_image_dim()
{
    identify "$1" | awk '{print $3}'
}

get_button_geo()
{
    GEOx=${MENU_BUTTON_SIZE/x*}
    GEOy=${MENU_BUTTON_SIZE/*x}
    GEOx=$((GEOx - 3))
    GEOy=$((GEOy - 3))
    GEO="$GEOx,$GEOy"
}

image2mpeg2()
{
    IN_IMAGE="$1"
    THIS_RUN=$2
    # some vars depending on whether doing stills or a 'mix' video
    if [[ $THIS_RUN = "stills" ]]; then
        alength=$alen && vlength=$slen && mixext=""
    elif [[ $THIS_RUN = "mix" ]]; then
        alength=$MIX_ALEN && vlength=$MIX_VFRAMES && mixext=_mix
        MIX_FILES=( "${MIX_FILES[@]}" \
          "${IN_IMAGE/.todisc_enc.*}.todisc_enc${mixext}.mpg" )
    fi
    IMAGE_ENC_CMD=(ffmpeg -f image2 -loop_input -vframes $vlength -i "$IN_IMAGE" \
    -s $VIDSIZE -f s16le -i /dev/zero -t $alength -ar $SAMPLERATE -ac 2 \
    -ab 224k -target ${TV_STANDARD}-${TARGET} -aspect $ASPECT_RATIO \
    -y "${IN_IMAGE/.todisc_enc.*}.todisc_enc${mixext}.mpg")
    echo "Running ${IMAGE_ENC_CMD[@]}" | format_output >> "$LOG_FILE"
    "${IMAGE_ENC_CMD[@]}" 2>&1 |strings >> "$LOG_FILE"
}

switched_menu_mode()
#call todisc recursively to make multiple menus for -switched-menus option
{
    $TITLESET_MODE && IS_TITLESET="-is_titleset"
    for ((i=1; i<${#FILES[@]}; i++)); do
        yecho
        yecho "Working on switched menu $((i+1))"
        $WARN && yecho && sleep 5
        yecho "Running todisc "$@" -switched-mode $IS_TITLESET -basedir "$BASEDIR" -menu_num $((i+1)) -showcase "${FILES[i]}""
        todisc "$@" -switched-mode $IS_TITLESET -basedir "$WORK_DIR" -menu_num $((i+1)) -todisc-pids "$todisc_pids" -showcase "${FILES[i]}"
    done
        yecho
        yecho "Working on switched menu 1"
        yecho
#    exit
}
titleset_mode()
# call todisc recursively in order to allow titlesets
{
    # some vars for vmgm menu, depending on presence of -static or -quick-nav
    # how many titlesets do we have ?
    for i in "$@"; do [[ $i == -end-titleset ]] && ((count++)); done
    VMGM_PAUSE_TIME=$PAUSE_TIME
    grep -q ' -static ' <<< "$VMGM_OPTS" && VMGM_PAUSE_TIME="inf"
    for i in ${!VMGM_OPTS[@]}; do
        if [[ ${VMGM_OPTS[i]} = '-loop' ]]; then
            loop_val=${VMGM_OPTS[i+1]}
            test_is_number $loop_val && VMGM_PAUSE_TIME=$loop_val
        fi
    done
    DVDAUTHOR_XML="$BASEDIR/dvdauthor.xml"
    VMGM_PRE="        if ( g5 eq 0 ) g5 = 1;"
    VMGM_PRE="$VMGM_PRE\n        if ( g6 eq 0 ) g6 = 1; button = g6 * 1024;"
    grep -q -- -switched-menus <<< "${args[@]}" && VMGM_PRE="$VMGM_PRE\nif (g1 eq 0) g1=1;"
    $DO_INTRO && VMGM_PRE="$VMGM_PRE\n        if (g2==1) jump cell 2;"
    $SKIP_VMGM_MENU && VMGM_PRE="$VMGM_PRE\n        if ( g3 eq 0 )  g3 = 1 ;"

#    $SWITCHED_MODE && VMGM_PRE="$VMGM_PRE g1=1;"
    # make dvdauthor.xml
(
    cat <<EOF
<?xml version="1.0" encoding="utf-8"?>
<dvdauthor dest="$OUT_DIR" jumppad="0">
  <vmgm>
    <menus>
      <pgc entry="title">
        <pre>
$(echo -e "$VMGM_PRE")
$(if $QUICK_NAV || $SKIP_VMGM_MENU; then
        for ((i=1; i<=${#TITLESET_OPTS[@]}; i++)); do
            echo -e "        if ( g3 eq $i ) jump titleset $i menu;"
        done
fi)
        </pre>
        <post>
$([[ $INTRO ]] && echo -e "        g2=1; jump vmgm menu entry title;")
        jump cell 1;
        </post>
$(for ((i=1; i<=${#TITLESET_OPTS[@]}; i++)); do
    echo "        <button name=\"$i\">g5=1; g6=$i; jump titleset $i menu;</button>"; done)
        $INTRO
        <vob file="$BASEDIR/VMGM.mpg" pause="$VMGM_PAUSE_TIME"/>
      </pgc>
    </menus>
  </vmgm>
EOF
) |sed '/^ *$/d' >> "$DVDAUTHOR_XML"

    function  get_genopts()
    {
        unset GEN_OPTS
        i=0
        while [[ $@ ]]; do
            case "$1" in
                "-titleset")
                    while [[ $@ && $1 != "-end-titleset" ]]; do
                        shift
                    done
                    ;;
                "-vmgm")
                    while [[ $@ && $1 != "-end-vmgm" ]]; do
                        shift
                    done
                    ;;
                "-group")
                    shift
                    get_listargs "$@"
                    ;;
                *)
                    GEN_OPTS[i++]="$1"
                    ;;
            esac
            shift
        done
    }
    function  get_menu_titles()
    {
        unset y titles
        while [[ $@ ]]; do
            case "$1" in
                "-vmgm")
                    while [[ $@ && $1 != "-end-vmgm" ]]; do
                        shift
                    done
                    ;;
                "-menu-title" )
                    shift
                    menutitles=("${menutitles[@]}" "$1")
                    ;;
                "-titles" )
                    shift
                    get_listargs "$@"
                    OIFS=$IFS
                    IFS=""
                    titles=( "${titles[@]}" "${ARGS_ARRAY[@]}" )
                   # NUM_TITLES="$NUM_TITLES ${#ARGS_ARRAY[@]}"
                    IFS=$OIFS
                    ;;
                "-files" )
                    shift
                    get_listargs "$@"
                    for i in ${!ARGS_ARRAY[@]}; do
                        all_files[i]=$(readlink -f "${ARGS_ARRAY[i]}")
                    done
                    ALL_FILES=( "${ALL_FILES[@]}" "${all_files[@]}")
                    NUM_TITLES="$NUM_TITLES ${#ARGS_ARRAY[@]}"
                    ;;
            esac
            shift
        done
    }
    get_genopts "${args[@]}"
    get_menu_titles "${args[@]}"
    # get the number of files in each titleset
    num_titles="$NUM_TITLES"
    MENUTITLES=( "${menutitles[@]}" )

    get_menu_titles "${VMGM_OPTS[@]}"
    if [[ ${#menutitles[@]} -ne 0 && ${#menutitles[@]} -ne $count ]]; then
        usage_error "Number of titleset titles must equal the number of titlesets"
    fi
    if [[ -z ${VMGM_OPTS[@]} ]]; then
        yecho
        yecho "You have not supplied -vmgm OPTIONS -end-vmgm"
        yecho "At a minumum you should have '-vmgm -titles "Title one" "Title two" -end-vmgm'"
        yecho "One title for each titleset you are making."
        yecho "Any other appropriate todisc options for the vmgm menu can be specified as well."
        if  [[ ${#MENUTITLES[@]} -eq $count ]]; then
            yecho "Since -menu-title was supplied for each titleset: these titleset titles will be used:"
            for t in "${MENUTITLES[@]}"; do echo "\"$t\""; done
            VMGM_OPTS=(-titles "${MENUTITLES[@]}")
        else
            VMGM_OPTS[0]="-titles"
            for ((menu=1; menu<=count; menu++)); do VMGM_OPTS[menu]="Titleset $menu"; done
        fi
        yecho "Making a generic vmgm menu for you - you may wish to cancell out and change this."
        yecho
        $VMGM_MENU && $WARN && sleep 15
    fi
    yecho
    yecho "Making a VMGM menu with the following command:"
    vmgm_menu_cmd=(todisc "${GEN_OPTS[@]}" -basedir "$WORK_DIR" -menu-only -textmenu -todisc-pids "$todisc_pids"  "${VMGM_OPTS[@]}")
    yecho "Running: ${vmgm_menu_cmd[@]}"
    INITIALDIR="$BASEDIR"
    if ! "${vmgm_menu_cmd[@]}" ; then cleanup && exit 1; fi
   # TODO move to function so its not duplicated here and in main parser, generalize for -vmgm too 
    while test $# -gt 0; do
        DO_SHIFT=:
        case "$1" in
            "-titleset" )
                let tset=tset+1
                shift
                unset x TITLESET_OPTS
                # Hackish list-parsing
                while test $# -gt 0 && test "$1" != "-end-titleset"; do
                    TITLESET_OPTS[x++]="$1"
                    shift
                done
                titleset_cmd=( todisc -titleset-mode -basedir "$WORK_DIR" \
                -title_count "$num_titles" -tset_num ${count}-${tset} \
                "${GEN_OPTS[@]}" "${TITLESET_OPTS[@]}" )
                yecho
                yecho "Working on the menu for titleset number $tset"
                yecho
                $WARN && sleep 5
                yecho "Running: ${titleset_cmd[@]}"
                if ! "${titleset_cmd[@]}"; then cleanup && exit 1; fi
                yecho
                ;;
        esac
        $DO_SHIFT && shift
    done
    echo -e "</dvdauthor>" >> "$DVDAUTHOR_XML"
    yecho "Running dvdauthor to create final DVD structure"
    dvdauthor -x "$DVDAUTHOR_XML" 2>&1 | tee -a "$LOG_FILE"
    if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
        dvdauthor_error
    fi
    thanks_goodbye
    cleanup

}

parse_rotateargs()
{
    unset x ARGS_ARRAY
    # Hackish list-parsing
    while test $# -gt 0 && egrep -q '^[-+]?[[:digit:]]{1,2}+$' <<< "$1"; do
        ARGS_ARRAY[x++]="$1"
        shift
    done
    # Do not skip past the next argument
    if test $# -gt 0 && test x"${1:0:1}" = x"-";then
        DO_SHIFT=false
    fi
}

burn_disc()
{
    yecho
    echo "You have indicated you want to burn the $BURN_TGT_STR"
    echo "Would you like to burn the ${BURN_TGT_STR/ *} now ?"
    echo -n "Type 'yes' to continue: "
    read input
    echo
    if [ ! -z "$input" -a "$input" = "yes" ]; then
        echo "Proceeding to burn, continuing."
        echo
        if $BURN_PROG -burn -device "$BURN_DEVICE" $BURN_SPEED "$BURN_TGT" | tee -a "$LOG_FILE" 2>&1; then
            echo "Your ${BURN_TGT_STR/ *} should be ready"
        else
            echo "There appears to have been a problem creating the ${BURN_TGT_STR/ *}"
            echo "Please see "$LOG_FILE" for details"
        fi
    else
        echo "Not burning now - please see the parting message from todisc"
        echo "for instructions on using ${BURN_PROG}, or see 'man $BURN_PROG'"
    fi
}

thanks_goodbye()
{
    SCRIPT_END_TIME=`date +%s`
    SCRIPT_TOT_TIME=`expr $SCRIPT_END_TIME \- $SCRIPT_START_TIME`
    HHMMSS=`format_seconds $SCRIPT_TOT_TIME`
    echo
    echo $SEPARATOR
    echo "todisc took $HHMMSS to finish on $CPU_MODEL $CPU_SPEED mhz"
    echo $SEPARATOR
    if [ "$TARGET" = "dvd" ]; then
        echo "Your new DVD should be in $OUT_DIR"
        echo "You can preview them in gxine with this command:"
        echo "    gxine \"dvd:/$OUT_DIR\""
        echo "If you are satisfied with the results, you can burn a disc with:"
        echo "    makedvd -burn \"$OUT_DIR\""
    elif [ "$TARGET" = "svcd" ]; then
        echo "Your svcd bin and cue files are ready. You can burn them with:"
        echo "   $BURN_PROG -burn -device $BURN_DEVICE $BURN_SPEED $BURN_TGT"
        echo "Make sure to adjust the device name to YOURS "
        echo "and add -speed NN if needed ( ie. -speed 4 for an old cdrw disc)"
    fi
    echo
    echo "Thanks for using todisc."
}

# usage mk_return_button (mk_play_button) COLOUR1 COLOUR2 OUTBUTTON
# ex. for menu button ( not spumux ):
# mk_return_button "#C6C6C6" black "$WORK_DIR/Main.png"
mk_return_button()
{

    COLR1="$1"
    COLR2="$2"
    TYPE=$3
    OUTBUTTON="$4"
    if [[ $TYPE = "spu" ]]; then
        CLR1="none"
    elif [[ $TYPE = "default" ]]; then
        CLR1="$COLR1"
    fi

    MK_RTN_CMD=(convert -size 100x80 xc:none \
    -strokewidth 1 -stroke "$COLR2" -fill "$CLR1" \
    -draw 'rectangle 0,0 70,62' \
    -fill "$COLR2" -stroke none \
    -draw "polyline 40,10 40,50 10,30 40,10" \
    -draw "polyline 60,10 60,50 30,30 60,10" \
    -fill "$COLR2" -draw "rectangle 6,10 10,50" \
    -resize 30% -trim +repage "$OUTBUTTON")
    echo -e "\nRunning ${MK_RTN_CMD[@]}\n" |format_output >> "$LOG_FILE"
    "${MK_RTN_CMD[@]}"
    RTN_BTN_DIM=$(get_image_dim "$OUTBUTTON")
    rtn_btn_width=$(awk -Fx '{print $1}' <<< $RTN_BTN_DIM )
    rtn_btn_height=$(awk -Fx '{print $2}' <<< $RTN_BTN_DIM )
}
mk_play_button()
{     
    COLR1="$1"
    COLR2="$2"
    TYPE=$3
    OUTBUTTON="$4"
    if [[ $TYPE = "spu" ]]; then
        CLR1="none"
    elif [[ $TYPE = "default" ]]; then
        CLR1="$COLR1"
    fi
    #-fill "$COLR2" -draw "line 40,10 40,50"  \
    MK_PLAY_CMD=(convert -size 100x80 xc:none  \
    # -fill "$COLR2" -draw "rectangle 36,10 40,50" \
    -strokewidth 2 -stroke "$COLR2" -fill "$CLR1" \
    -draw 'rectangle 22,0 92,62' \
    -fill "$COLR2" -stroke none \
    -draw "polyline 40,10 40,50 80,30 40,10" \
    -resize 30% -trim +repage "$OUTBUTTON")
    echo -e "\nRunning ${MK_PLAY_CMD[@]}\n" |format_output >> "$LOG_FILE"
    "${MK_PLAY_CMD[@]}"
    PLAY_BTN_DIM=$(get_image_dim "$OUTBUTTON")
    play_btn_width=$(awk -Fx '{print $1}' <<< $PLAY_BTN_DIM )
    play_btn_height=$(awk -Fx '{print $2}' <<< $PLAY_BTN_DIM )
}

check_menufile()
{
    yecho
    if test -f "$MENU_FILE"; then
        echo "Menu file $MENU_FILE created"
        echo
    else
        runtime_error "Menu file $MENU_FILE not found.  Spumux seems to have had problems"
    fi
}

quick_menu()
{
    unset LEFTPAD TOPPAD RIGHTPAD BOTTOMPAD
    # get width and height of background: we may need to resize it to $VIDSIZE
    if $QUICKMENU_IS_BACKGROUND; then
        BG_VIDEO_STATS=$(idvid -fast "$BG_VIDEO")
        BG_VIDEO_WIDTH=$(awk '/Width:/ {print $2}' <<< "$BG_VIDEO_STATS")
        BG_VIDEO_HEIGHT=$(awk '/Height:/ {print $2}' <<< "$BG_VIDEO_STATS")
        if [[ ${BG_VIDEO_WIDTH}x${BG_VIDEO_HEIGHT} != $VIDSIZE ]]; then
            RESIZE_BG=:
        fi
    fi
    if [[ -n $1 && $1 = "preview" ]]; then
        QM_MENU_TIME=2 && QM_PREVIEW=:
    else
        QM_MENU_TIME=${MENU_LEN[MENU_NUM-1]} && QM_PREVIEW=false
    fi
    # if QUICK_MENU_FILE is a showcase video then we need a temp avi file
    if $QUICKMENU_IS_SHOWCASE; then
        PRE_VHOOK_FILE="$WORK_DIR/quick_tmp.avi" # not needed for mix
        outdir="$WORK_DIR/showcase"
        if $SWITCHED; then
            qm_seek="-ss ${SEEK_VAL[MENU_NUM-1]}"
        else
            qm_seek="-ss $SHOWCASE_SEEK_VAL"
        fi
    # else if we have background file maybe no need for the 1st resize step
    elif $QUICKMENU_IS_BACKGROUND; then
        if ! $RESIZE_BG; then
            PRE_VHOOK_FILE="$BG_VIDEO"
        else
            PRE_VHOOK_FILE="$WORK_DIR/quick_tmp.avi"
        fi
        outdir="$WORK_DIR/bg"
        qm_seek="-ss $BG_SEEK"
    fi
    # find out where vhook lives for ffmpeg
    ffmpeg_prefix=$(which ffmpeg)
    ffmpeg_prefix=$(sed 's/\/bin\/ffmpeg//g' <<< "$ffmpeg_prefix")
    imlib2_vhook="$ffmpeg_prefix/lib/vhook/imlib2.so"

    # check for badly compiled or otherwise unusable vhook
    if $QM_PREVIEW && [[ $MENU_NUM -eq $MN ]]; then
        ! [[ -s "$imlib2_vhook" ]] && runtime_error "Missing ffmpeg's vhook's"
        yecho
        yecho "Making a MPEG for testing ffmpeg's imlib2 vhook"
        convert  -resize $VIDSIZE! xc:"#161514" "$WORK_DIR/dummy.jpg"
        dummy_cmd=(ffmpeg -t 2 -loop_input -i "$WORK_DIR/dummy.jpg" \
        -aspect 4:3  -f mpeg1video -r 29.970 -vcodec mpeg2video -b 5000k \
        -f s16le  -i /dev/zero -acodec ac3 -ac 2 -ar 48000 -ab 224k \
        -y "$WORK_DIR/dummy.mpg")
        if ! "${dummy_cmd[@]}" 2>> "$LOG_FILE"; then
            runtime_error "There was a problem making a dummy.mpg with ffmpeg"
        fi
        if ! ffmpeg -vhook "$imlib2_vhook -i "$WORK_DIR/dummy.jpg"" \
        -i "$WORK_DIR/dummy.mpg" -y "$WORK_DIR/test.mpg" 2>> "$LOG_FILE"; then
            runtime_error "Your ffmpeg's vhook is broken.  No 'quick-menu' :("
        fi
        yecho
    fi
    $QM_PREVIEW && yecho "Creating a quick-menu preview image"
    # convert and resize the bgvideo so that is is framed by ntsc-safe black bg
    if $QUICKMENU_IS_SHOWCASE || $RESIZE_BG; then
        yecho
        if $RESIZE_BG; then
            yecho "resizing background video: $BG_VIDEO"
            QM_TMP_FRAMESIZE=$VIDSIZE
        else
            yecho "resizing and padding showcase file: $SHOWCASE_VIDEO"
            LEFTPAD=$SC_X
            TOPPAD=$SC_Y
            RIGHTPAD="-padright \
            $(( ${VIDSIZE%%x*} - $LEFTPAD - ${SHOWCASE_SIZE%%x*} ))"
            BOTTOMPAD="-padbottom \
            $(( ${VIDSIZE##*x} - $TOPPAD - ${SHOWCASE_SIZE##*x} ))"
            LEFTPAD="-padleft $SC_X"
            TOPPAD="-padtop $SC_Y"
            QM_TMP_FRAMESIZE=$SHOWCASE_SIZE
        fi
        PAD_CMD=(ffmpeg -r $FRAME_RATE -async 1 $qm_seek \
        -t "$QM_MENU_TIME" -i "$QUICK_MENU_FILE" -s $QM_TMP_FRAMESIZE \
        -acodec copy $TOPPAD $BOTTOMPAD $LEFTPAD $RIGHTPAD \
        -r $FRAME_RATE -b 15000k -padcolor $BG_COLOUR \
        -y  "$WORK_DIR/quick_tmp.avi")
        yecho
        yecho "Running ${PAD_CMD[@]}"|fold -bs
        "${PAD_CMD[@]}" 2>&1 |strings >> "$LOG_FILE"
    fi

    # use vhook to add the titles in
    ! $QM_PREVIEW && yecho
    if ! $QM_PREVIEW; then
        yecho "Using ffmpeg's vhook to add titles and background"
    fi
    # don't seek if we already made a padded video with a seek
    $QUICKMENU_IS_SHOWCASE || $RESIZE_BG && qm_seek=""
    VHOOK_CMD=(ffmpeg -t "$QM_MENU_TIME" $qm_seek -s $VIDSIZE \
    -i  "$PRE_VHOOK_FILE"  -an -f mpeg2video -r $FRAME_RATE -tvstd ntsc \
    -b 7000k -maxrate 8000k -bufsize 224KiB -aspect $ASPECT_RATIO \
    -vhook "$imlib2_vhook -x 0 -y 0 -i $WORK_DIR/quick_menu_bg.png" \
    -y "$WORK_DIR/intro.m2v")
    $QM_PREVIEW && yecho
    $QM_PREVIEW && yecho "Running ${VHOOK_CMD[@]}" | fold -bs
    "${VHOOK_CMD[@]}" 2>&1 | strings >> "$LOG_FILE"
    ! $QM_PREVIEW && yecho
    # create preview images if called for
    if $QM_PREVIEW; then
        FFMPEG_CMD=(ffmpeg -i "$WORK_DIR/intro.m2v" -an -ss 1 -vframes 30 \
        "$outdir"/%06d.png)
        yecho "${FFMPEG_CMD[@]}" | strings
        "${FFMPEG_CMD[@]}" 2>&1 | strings >> "$LOG_FILE"
        largest_png=$(du -s "$outdir"/*.png|sort -r |
        awk 'NR>1{exit};1 {print $2}')
        mv "$largest_png" "$PREVIEW_IMG"
        yecho "Removing temporary preview files"
        rm -f "$WORK_DIR/intro.m2v"
        $QUICKMENU_IS_SHOWCASE && rm -f "$WORK_DIR/quick_tmp.avi" \
        "$WORK_DIR"/showcase/*.png
        $QUICKMENU_IS_BACKGROUND && rm -f  "$WORK_DIR"/bg/*.png
    fi
    $QM_PREVIEW && yecho
}

# 3x1 and 4x1 tile only for default arrangement
tile_warning()
{
    yecho
    echo "-tile-3x1 and -tile-4x1 are not showcase options.  Disabling"
    yecho
    $WARN && sleep 5
}
dvdauthor_error()
{
    echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    yecho "todisc encountered an error:"
    yecho "There was a problem creating the DVD structure"
    yecho "Saving files in "$WORK_DIR" so you can examine the situtaion"
    yecho "You can edit "$WORK_DIR/dvdauthor.xml" and rerun: "
    yecho "dvdauthor -x dvdauthor.xml from inside $REAL_WORK_DIR"
    yecho "Remove the symlink in /tmp when you are done"
    echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    exit 1
}

make_dummy()
{
    yecho "Creating a blank mpeg for the vmgm menu"
    convert  -resize $VIDSIZE! xc:"#161514" "$WORK_DIR/dummy.jpg"
    ENC_CMD1=(jpeg2yuv -v 1 -f $FRAME_RATE -I p -n 1 -l 30 -L 1 -b1 \
    -j "$WORK_DIR/dummy.jpg")
    ENC_CMD2=(ffmpeg -f yuv4mpegpipe -i - -an -r $FRAME_RATE -s $VIDSIZE \
    -tvstd $TV_STANDARD $FFMPEG_OPTS -y "$WORK_DIR/dummy.m2v")
    echo "Running: ${ENC_CMD1[@]} | ${ENC_CMD2[@]}"|strings|fold -bs | tee -a "$LOG_FILE"
    if ! ${ENC_CMD1[@]} 2>> "$LOG_FILE"  | ${ENC_CMD2[@]} 2>&1 |strings  >> "$LOG_FILE"; then
        runtime_error
    fi
    VMGM_TIME=$(vid_length "$WORK_DIR/dummy.m2v")
    yecho
    # temporarily use mp2enc for svcd audio as ffmpeg broken # FIXME
    # see r2162 todisc or older for how to fix this block when ffmpeg is fixed
    if [[ $TARGET = "dvd" ]]; then
        BGAUDIO_CMD=(ffmpeg -f s16le -i /dev/zero -t $VMGM_TIME \
        $AUDIO_OPTS -y "$WORK_DIR/dummy.$AUDIO_EXT")
        yecho "${BGAUDIO_CMD[@]}"
        "${BGAUDIO_CMD[@]}" 2>&1 | strings >> "$LOG_FILE"
    else
        # generate wav from /dev/zero
        ffmpeg -f s16le -i /dev/zero -t $VMGM_TIME -ar 48000 \
        -ac 2 -acodec pcm_s16le -y "$WORK_DIR/dummy.wav"
        BGAUDIO_CMD=(mp2enc -r 44100 -o "$WORK_DIR/dummy.$AUDIO_EXT")
        echo "Running "${BGAUDIO_CMD[@]}" < $WORK_DIR/dummy.wav" | fold -bs >> "$LOG_FILE"
        "${BGAUDIO_CMD[@]}" < "$WORK_DIR/dummy.wav" 2>&1 |fold -bs >> "$LOG_FILE.tmp"
    fi
    ! [[ -s "$WORK_DIR/dummy.$AUDIO_EXT" ]] &&  runtime_error

    MPLEX_CMD=(mplex -V -f $MPLEX_FORMAT -o  "$BASEDIR/dummy.mpg" \
     "$WORK_DIR/dummy.$AUDIO_EXT"  "$WORK_DIR/dummy.m2v")
    echo "Running: "${MPLEX_CMD[@]}"" |fold -bs >> "$LOG_FILE"
    ! "${MPLEX_CMD[@]}" 2>&1 |strings >> "$LOG_FILE" && runtime_error
#    $VMGM_ONLY && $SKIP_VMGM && mv "$BASEDIR/dummy.mpg" "$BASEDIR/VMGM.mpg"
}
verify_infiles()
{
    verify_type=$1
    if [[ $verify_type = "infiles" ]]; then
        in_files=( "${IN_FILES[@]}" )
    else
	for f in ${!grouping[@]}; do
            in_files[f]=$(readlink -f "${grouping[f]}")
	done
#        in_files=( "${grouping[@]}" )
    fi
    for ((i=0; i<${#in_files[@]}; i++)); do
        CROP_CMD=()
        IN_FILE="${in_files[i]}"
        if test -e "$IN_FILE"; then
            check_filetype "$IN_FILE"
            if [[ $TYPE = "image" ]]; then
                IMG_STATS=( $(identify -format "%z %w %h" "$IN_FILE") )
                DEPTH=${IMG_STATS[0]}
                IMG_WIDTH=${IMG_STATS[1]}
                IMG_HEIGHT=${IMG_STATS[2]}
                IMG_AR=$(bc_math "$IMG_WIDTH / $IMG_HEIGHT")
                if [[ $ASPECT_RATIO = "4:3" ]]; then
                    NEWSIZE=640x480
                else
                    NEWSIZE=640x360
                fi
                if [[ ${IMG_AR:0:4} != ${AR:0:4} ]]; then
                    CROP_CMD=(-resize  ${NEWSIZE}\> -size $NEWSIZE \
                    xc:black +swap -gravity center -composite)
                fi
                if [[ $verify_type = "infiles" ]]; then
                    # ffmpeg image2 can't handle 16 bit depth - convert it
                    # also convert if not PNG or JPEG or wrong aspect ratio
                    # test IN_FILES for preview - group files tested later
                    if [[ $DEPTH = 16 || -n ${CROP_CMD[@]} ]] || $CONVRT ; then
                        echo "Converting $IN_FILE to proper image format" \
                          >> "LOG_FILE"
                        IMG_CMD=(convert "$IN_FILE" -depth 8 "${CROP_CMD[@]}" \
                        -blur 0.2 "${IN_FILE/.todisc_enc.*}.todisc_enc.png")
                        echo "${IMG_CMD[@]}" |format_output >> "LOG_FILE"
                        "${IMG_CMD[@]}" |format_output >> "$LOG_FILE" 2>&1
                        IN_FILES[i]="${IN_FILE/.todisc_enc.*}.todisc_enc.png"
                    fi
                    if [[ "$SC_FRAMESTYLE" = "glass" ]]; then
                        # make mpeg with ffmpeg now #FIXME
                        image2mpeg2 "${IN_FILES[i]}" stills
                        IN_FILES[i]=${IN_FILES[i]/.todisc_enc.*}.todisc_enc.mpg
                    else
                        file_is_image[i]="yes" # needs to be encoded to mpeg
                    fi
                else
                    grp_file_is_image[i]="yes"
                fi
                spin checking "${IN_FILE##*/}"
#                echo
            elif mencoder -quiet -oac pcm -ovc copy \
            -frames 0 -o /dev/null "$IN_FILE" &>/dev/null; then
                checkfile="${IN_FILE##*/}"
                spin checking "$checkfile"
            else
                usage_error "Sorry, $IN_FILE is not a supported file type"
            fi
        else
            usage_error "Sorry, $IN_FILE does not exist"
        fi
    done
}

##############################################################################
#                          	End of functions                                 #
##############################################################################

trap 'cleanup; exit 13' TERM INT

###############################################################################
#       Process arguments to the script, set up VARS and WORK_DIR             #
###############################################################################

# ***********************************
# EXECUTION BEGINS HERE
# ***********************************
egrep -q 'titleset-mode|switched-mode|menu-only' <<< "$@" && NONAME=:
! $NONAME && yecho $"$SCRIPT_NAME"

while test $# -gt 0; do
    DO_SHIFT=:
    case "$1" in
        "-files" )
            shift
            get_listargs "$@"
            for f in  ${!ARGS_ARRAY[@]}; do
                FILENAMES[f]=${ARGS_ARRAY[f]}
                FILES[f]=$(readlink -f "${ARGS_ARRAY[f]}")
            done
            ;;
        "-titleset" )
            shift
            unset x ARGS_ARRAY
            while test $# -gt 0 && test "$1" != "-end-titleset"; do shift ; done
            if test $# -gt 0 && test x"${1:0:1}" = x"-";then DO_SHIFT=false; fi
            TITLESET_OPTS[y++]=${ARGS_ARRAY[@]}
            DO_TITLESETS=:
            ;;
       "-vmgm" )
            shift
            unset x ARGS_ARRAY
            # Hackish list-parsing
            while test $# -gt 0 && test "$1" != "-end-vmgm"; do
                ARGS_ARRAY[x++]="$1"
                shift
            done
            # Do not skip past the next argument
            if test $# -gt 0 && test x"${1:0:1}" = x"-";then
                DO_SHIFT=false
            fi
            VMGM_OPTS=( "${ARGS_ARRAY[@]}" )
            ;;
        "-group" )
            shift
            ! $GROUPING && mk_workdir
            get_listargs "$@"
            unset group groupkey grp x
            for ((i=1; i<${#ARGS_ARRAY[@]}; i++)); do
                grp[x++]=$(readlink -f "${ARGS_ARRAY[i]}")
            done
            GROUP_IN_FILES=( "${GROUP_IN_FILES[@]}" "${grp[@]}" )
            group="$(for ((b=0; b<${#grp[@]}; b++)); do echo -e "${grp[b]}"; done)"
            groupkey=$(( ${ARGS_ARRAY[0]} - 1))
            GROUP[groupkey]="$group"
            # create symlinks to ease substitution later
            for c in ${!grp[@]}; do
                ln -s "${grp[c]}" $WORK_DIR/${TSET_NUM}-group-$((groupkey+1))-$((c+1)).mpg
            done
            GROUPING=:
            ;;
        "-titles" )
            shift
            get_listargs "$@"
            OIFS=$IFS
            IFS=""
            TITLES=( "${TITLES[@]}" "${ARGS_ARRAY[@]}" )
            IFS=$OIFS
            ;;
        "-submenu-titles" )
            shift
            get_listargs "$@"
            OIFS=$IFS;IFS=""
            SM_TITLES=( "${ARGS_ARRAY[@]}" )
            IFS=$OIFS
            ;;
        "-use-makemenu" )
            USE_MAKEMENU=:
            ;;
        "-out" )
            shift
            OUT_PREFIX="$1"
            ;;
        "-no-ask" | "-noask" )
            NOASK=:
            ;;
        "-no-warn" | "-nowarn" )
            WARN=false
            ;;
        "-keep-files" | "-keepfiles" )
            KEEP_FILES=:
            ;;
        "-dvd" )
            TARGET="dvd"
            ;;
        "-svcd" )
            TARGET="svcd"
            ;;
        "-ntsc" )
            TV_STANDARD="ntsc"
            ;;
        "-pal" )
            TV_STANDARD="pal"
            ;;
        "-aspect" )
            unset ASPECT ASPECT_ARG
            shift
            ASPECT_ARG=$1
            if [[ ${#ASPECT_ARG[@]} -gt 0 ]]; then
            ASPECT_RATIO=$ASPECT_ARG
            [[ $ASPECT_RATIO = "16:9" ]] && AR=1.777
            V_ASPECT="aspect=\"$ASPECT_RATIO\""
            fi
            ;;
        "-widescreen" )
            shift
            get_listargs "$@"
            wsarg=${ARGS_ARRAY[0]}
            [[ -n $wsarg ]] &&  WIDESCREEN=$wsarg || WIDESCREEN="nopanscan"
            WIDE_SCREEN=:
            ;;
        "-showcase-safe-area" )
            ADV_OPT=( "${ADV_OPT[@]}" "$1" )
            shift
            SAFE_AREA="$1"
            let SAFE_OFFSET="86-SAFE_AREA"
            USER_SAFE_AREA=:
            ;;
        "-align" )
            ADV_OPT=( "${ADV_OPT[@]}" "$1" )
            shift
            BUTTON_GRAVITY=$1
            [[ $BUTTON_GRAVITY = "centre" ]] && BUTTON_GRAVITY="center"
            USER_GRAVITY=:
            ;;
        # Menu control options
        "-menu-length" )
            shift
            unset MENU_LEN
            get_listargs "$@"
            MENU_LEN=${ARGS_ARRAY[@]}
            MENU_LEN=( ${MENU_LEN//,/ } )
            USER_MENU_LEN=:
            ;;
        # submenu-length disabled for now
        "-submenu-length" )
            shift
            ANI_SUBMENU_LEN="$1"
            ;;
        "-static" )
            STATIC=:
            ;;
        "-menu-fade" )
            MENU_FADE=:
            AUDIO_FADE=:
            ;;
        "-tile3x1" | "-tile-3x1" )
            THREExONE=:
            ;;
        "-tile4x1" | "-tile-4x1" )
            FOURxONE=:
            ;;
        "-loop" )
            unset pause_time
            shift
            get_listargs "$@"
            pause_time=${ARGS_ARRAY[0]}
            if [[ -n $pause_time ]]; then
                PAUSE_TIME=$pause_time
            else
                # a hack to address a current lack in metagui for todiscgui
                PAUSE_TIME="inf"
            fi
            STATIC_LOOP=:
            ;;
        "-video-pause" | "-slide-pause" )
            shift
            svcd_pause=$1
            get_listargs "$@"
            [[ -n "${ARGS_ARRAY[@]}" ]] && VPAUSE=( "${ARGS_ARRAY[@]}" )
            ;;
        "-group-video-pause" )
            shift
            get_listargs "$@"
            GRP_VPAUSE=( "${ARGS_ARRAY[@]}" )
            ;;
        "-slideshow-audio" )
            shift
            [[ -n $1 ]] && SLIDESHOW_AUDIO=$(readlink -f "$1")
            ;;
        "-slide-menu-mix" )
            shift
            get_listargs "$@"
            [[ -n ${ARGS_ARRAY[@]} ]] && MIX_RANGE=${ARGS_ARRAY[@]}
            DO_SLIDE_MIX=:
            ;;
        "-slide-fade" )
            SLIDE_FADE=:
            ;;
        "-chain-videos" )
            shift
            get_listargs "$@"
            chains_in=${ARGS_ARRAY[@]}
            post_play=${chains_in//,/ }
            CHAIN_VIDEOS=:
            ;;
        "-playall" )
            PLAYALL=:
            ;;
        "-background" )
            shift
            BACKGROUND=$(readlink -f "$1")
            ! [[ -e "$BACKGROUND" ]] && \
            usage_error "background \"$BACKGROUND\" does not exist"
            ;;
        "-intro" )
            shift
            DO_INTRO=:
            INTRO_CLIP=$(readlink -f "$1")
            ! [[ -e "$INTRO_CLIP" ]] && usage_error "intro clip \"$INTRO_CLIP\" does not exist"
            ;;
        "-showcase" )
            shift
            get_listargs "$@"
            unset f
            for f in  ${!ARGS_ARRAY[@]}; do
                SHOWCASE_FILE[f]=$(readlink -f "${ARGS_ARRAY[f]}")
            done
            SHOWCASE=:
            IMG_FMT="png"
            ;;
        "-textmenu" | "-text-menu" )
            shift
            get_listargs "$@"
            arg=${ARGS_ARRAY[0]}
            [[ -n $arg ]] && SPLIT=$arg && USER_SPLIT=:
            TEXTMENU=:
            SHOWCASE=:
            IMG_FMT="png"
            SC_TITLE_ALIGN="west"
            ;;
        "-text-start" )
            ADV_OPT=( "${ADV_OPT[@]}" "$1" )
            shift
            TEXT_YSTART=$1
            ;;
        "-showcase-titles-align" )
            shift
            SC_TITLE_ALIGN="$1"
            [[ SC_TITLE_ALIGN = "centre" ]] && SC_TITLE_ALIGN="center"
            ;;
        "-title-gap" )
            ADV_OPT=( "${ADV_OPT[@]}" "$1" )
            shift
            SPACER=$1
            ;;
        "-rotate" )
            shift
            ROTATE_DEGREES="$1"
            ROTATE="-rotate $ROTATE_DEGREES"
            IMG_FMT="png"
            ;;
        "-wave" )
            shift
            get_listargs "$@"
            wave=${ARGS_ARRAY[0]}
            if [[ -n $wave ]]; then
                if [[ $wave = "default" ]]; then
                    WAVE="-wave -20x556"
                else
                    WAVE="-wave $wave"
                fi
            else
                # a hack to address a current lack in metagui for todiscgui
                WAVE="-wave -20x556"
            fi
            ;;
        "-showcase-framestyle" )
            shift
            SC_FRAMESTYLE="$1"
            ;;
        "-thumb-shape" )
            shift
            THUMB_SHAPE="$1"
            FEATHER=:
            IMG_FMT="png"
            ;;
        "-button-style" )
            shift
            BUTTON_STYLE="$1"
            USER_BSTYLE=:
            ;;
        "-3dthumbs" )
            THUMBS_3D=:
            RAISE="-raise 8x8"
            THUMB_FRAME=""
            ;;
        "-blur" )
            shift
            BLUR="$1"
            ;;
        "-title-colour" | "-title-color" )
            shift
            TITLE_COLOUR="$1"
            ;;
        "-submenu-title-colour" | "-submenu-title-color" )
            shift
            SM_TITLE_COLOUR="$1"
            ;;
        "-stroke-colour" | "-stroke-color" )
            shift
            STROKE="$1"
            ;;
        "-submenu-stroke-colour" | "-submenu-stroke-color" )
            shift
            SUBMENU_STROKE="$1"
            ;;
        "-thumb-text-colour" | "-thumb-text-color" )
            shift
            THUMB_TEXT_COLOUR="$1"
            ;;
        "-highlight-colour" | "-highlight-color" )
            shift
            HLIGHT_CLR="$1"
            ;;
        "-select-colour" | "-select-color" )
            shift
            SELECT_CLR="$1"
            ;;
        "-selectcolour" | "-selectcolor" | "-highlightcolour" | "-highlightcolor" | "-submenu-audiolength" | "-menu-audiolength")
            usage_error "$1 is depricated, option names are now split with logical hyphens where appropriate"
            ;;
        "-text-mist" )
            MIST=:
            ;;
        "-text-mist-opacity" )
            shift
            MIST_OPACITY="$1"
            ;;
        "-text-mist-colour" |"-text-mist-color" )
            shift
            MIST_COLOUR="$1"
            ;;
        "-thumb-mist-colour" |"-thumb-mist-color" )
            unset thumb_bg_colour
            shift
            get_listargs "$@"
            thumb_bg_colour=${ARGS_ARRAY[0]}
            if [[ -n $thumb_bg_colour ]]; then
                THUMB_BG_COLOUR=$thumb_bg_colour
            else
                # a hack to address a current lack in metagui for todiscgui
                THUMB_BG_COLOUR="none"
            fi
            ;;
        "-opacity" )
            shift
            TRANSPARENT=:
            OPACITY="$1"
            ;;
        "-chapters" )
            unset CHAPTERS
            shift
            get_listargs "$@"
            CHAPTERS=${ARGS_ARRAY[@]}
            # user can pass HH:MM:SS chapters, else, remove possible comma sep
            ! [[ "$CHAPTERS" = *:* ]] && CHAPTERS=( ${CHAPTERS//,/ } )
            # a way to tell later if user passed HH:MM:SS chapters
            if [[ "$CHAPTERS" = *:* ]]; then
                [[ "$CHAPTERS" = *+* ]] && grouped_user_chapters=( $CHAPTERS )
                # make array, remove everything after and including 1st '+',
                CHAPTERS=( $CHAPTERS )
                CHAPTERS=( ${CHAPTERS[@]%%+*} ) # in case of grouped chapters
                USER_CHAPTERS=: # user passed HH:MM:SS chapters
            fi
            ;;
        "-subtitles" )
            shift
            SUBTITLES=:
            get_listargs "$@"
            SUBS=${ARGS_ARRAY[@]}
            SUBS_ARRAY=( ${SUBS//,/ } )
            ;;
        "-audio-lang" )
            shift
            get_listargs "$@"
            AUDIO_LANG=${ARGS_ARRAY[@]}
            AUDIO_LANG=( ${AUDIO_LANG//,/ } )
            AUDIOLANG=:
            ;;
        "-bgaudio" )
            shift
            if [[ $1 = "none" ]]; then
                BG_AUDIO="none" # for switched menus
            else
                BG_AUDIO=$(readlink -f "$1")
                if [[ ! -e "$BG_AUDIO" ]]; then
                    usage_error "background audio \"$BG_AUDIO\" does not exist"
                fi
            fi
            ;;
        "-menu-audio-fade" )
            shift
            FADE="$1"
            USER_AUDIO_FADE=:
            AUDIO_FADE=:
            ;;
        "-submenu-audio" )
            shift
            get_listargs "$@"
            for i in ${!ARGS_ARRAY[@]}; do
                if [[ ${ARGS_ARRAY[i]} = "none" ]]; then
                    SM_AUDIO=( "${SM_AUDIO[@]}" "${ARGS_ARRAY[i]}" )
                else
                    SM_AUDIO=( "${SM_AUDIO[@]}" "$(readlink -f "${ARGS_ARRAY[i]}")" )
                fi
            done
            SUBMENU_AUDIO=:
            ;;
        "-submenu-audio-length" )
            shift
            SUBMENU_AUDIOLENGTH="$1"
            ;;
        "-submenu-audio-fade" )
            shift
            SM_FADE="$1"
            SM_AUDIO_FADE=:
            ;;
        "-submenus" )
            SUB_MENU=:
            ;;
        "-ani-submenus" )
            ANI_SUB_MENU=:
            SUB_MENU=:
            ;;
        "-menu-title" )
            shift
            MENU_TITLE="$1"
            ;;
        "-menu-font" )
            shift
            MENU_FONT=$(get_font "$1")
            ;;
        "-menu-fontsize" )
            shift
            MENU_FONTSIZE="$1"
            ;;
        "-thumb-font" )
            shift
            THUMB_FONT=$(get_font "$1")
            ;;
        "-thumb-fontsize" )
            shift
            THUMB_FONTSIZE="$1"
            ;;
        "-seek" )
            shift
            unset SEEK_VAL
            get_listargs "$@"
            SEEK_VAL=${ARGS_ARRAY[@]}
            SEEK_VAL=( ${SEEK_VAL//,/ } )
            USER_SEEK_VAL=:
            ;;
        "-showcase-seek" )
            shift
            SHOWCASE_SEEK_VAL="$1"
            ;;
        "-bgvideo-seek" )
            shift
            BG_SEEK="$1"
            ;;
        "-bgaudio-seek" )
            shift
            BG_AUDIO_SEEK="$1"
            USER_BG_AUDIO_SEEK=:
            ;;
        "-showcase-geo" )
            ADV_OPT=( "${ADV_OPT[@]}" "$1" )
            shift
            USER_SC_GEO=:
            SHOWCASE_GEO=$1
            ;;
        "-menu-title-geo" )
            ADV_OPT=( "${ADV_OPT[@]}" "$1" )
            USER_TITLE_GEO=:
            shift
            TITLE_GRAVITY=$1
            TITLE_GRAVITY=${TITLE_GRAVITY/re/er}
            ;;
        "-menu-title-offset" )
            ADV_OPT=( "${ADV_OPT[@]}" "$1" )
            USER_TITLE_GEO=:
            shift
            [[ $1 =~ \([-+][0-9]+\)\([-+][0-9]+\) ]];
            [[ -n ${BASH_REMATCH[1]} ]] && title_xoffset=${BASH_REMATCH[1]}
            [[ -n ${BASH_REMATCH[2]} ]] && title_yoffset=${BASH_REMATCH[2]}
            ;;
        "-outlinewidth" )
            ADV_OPT=( "${ADV_OPT[@]}" "$1" )
            shift
            OUTLINEWIDTH="\"$1\""
            ;;
        "-rotate-thumbs" )
            shift
            parse_rotateargs "$@"
            ROTATE_ARRAY=( "${ARGS_ARRAY[@]}" )
            IMG_FMT="png"
            ROTATE_THUMBS=:
            ;;
        "-tovidopts" )
            shift
            TOVID_OPTS="$1"
            ;;
        "-titleset-mode" )
            # used internally by todisc, do NOT pass as a user option !
            AUTHOR=false
            TITLESET_MODE=:
            ;;
        "-switched-mode" )
            # used internally by todisc, do NOT pass as a user option !
            SWITCHED_MODE=:
            TEXTMENU=:
            SC_TITLE_ALIGN="west"
            SHOWCASE=:
            ;;
        "-menu-only" ) # internal use only
            VMGM_ONLY=:
            ;;
        "-basedir" ) # internal use only
            shift
            BASEDIR="$1"
            ;;
        "-tset_num" ) # internal use only
            shift
            TSET_NUMS="$1"
            TSET_NUM=${TSET_NUMS/*-}
            TSET_TOT=${TSET_NUMS/-*}
            ;;
        "-todisc-pids" ) # internal use only
            shift
            todisc_pids="$todisc_pids $1"
            ;;
        "-menu_num" ) # internal use only
            shift
            MENU_NUM="$1"
            ;;
        "-title_count" ) # internal use only
            shift
            ALLTITLES=( $1 )
            ;;
        "-quick-nav" )
            QUICK_NAV=:
            ;;
        "-switched-menus" )
            SWITCHED_MENUS=:
            TEXTMENU=:
            SHOWCASE=:
            SC_TITLE_ALIGN="west"
            ;;
        "-skip-vmgm" )
            SKIP_VMGM_MENU=:
            ;;
        "-no-vmgm-menu" | "-no-vmgm" )
            VMGM_MENU=false
            ;;  
	    "-no-top-menu" )
	        MONTAGE_MENU=false
            ;;
        "-videos-are-chapters" )
            MENUBUTTONS_ARE_CHAPTS=:
            ;;
        "-is_titleset" ) #FIXME - this is useless
            TSET_MODE=:
            ;;
        "-burn" )
            BURN=:
            ;;
        "-device" )
            shift
            BURN_DEVICE="$1"
            ;;
        "-speed" )
            shift
            SPEED="$1"
            BURN_SPEED="-speed $SPEED"
            ;;
        "-quick-menu" )
            SHOWCASE=:
            QUICK_MENU=:
            SC_TITLE_ALIGN="west"
            ;;
        "-bg-colour" | "-bg-color" )
            shift
            BG_COLOUR="$1"
            BG_COLOUR=${BG_COLOUR/\#/} # in case user passed #ffffff syntax
            ;;
        "-submenu-bg-colour" | "-submenu-bg-color" )
            shift
            SUBMENU_BG_COLOUR="$1"
            SUBMENU_BG_COLOUR=${BG_COLOUR/\#/} # in case user passed #ffffff syntax
            ;;
    esac
    $DO_SHIFT && shift
done

##############################################################################
#                      Sanity checks and preliminaries                       #
##############################################################################

# get script pid so we can kill the parent if doing recursive todisc's
todisc_pids="$todisc_pids $$"

# link WORK_DIR to /tmp for easy solution to spaces, illegal chars bugs
! $GROUPING && mk_workdir
# set some other vars now that depended on *WORK_DIR being set
SPUMUX_XML="$WORK_DIR/spumux.xml"
DVDAUTHOR_XML="$WORK_DIR/dvdauthor.xml"
PREVIEW_IMG="$WORK_DIR/preview.jpg"

# Make sure equal, nonzero number of titles and files were provided
if ! $VMGM_ONLY && ! $DO_TITLESETS; then
    if [[ ${#FILES[@]} -eq 0 ]]; then
        usage_error "Please provide at least one file."
    elif [[ -n ${TITLES[@]} ]] && [[ ${#FILES[@]} -ne ${#TITLES[@]} ]]; then
        usage_error "Please give the same number of files as titles.
        You gave ${#FILES[@]} files and ${#TITLES[@]} titles"
    fi
fi
$SWITCHED && MN=2 || MN=1
if [[ ${#TITLES[@]} -eq 0 ]]; then
    if [[ $MENU_NUM = $MN ]] && ! $DO_TITLESETS; then
        yecho
        yecho "You did not provide any titles with -titles"
        yecho "Using the basename of each file provided (minus the extension)."
        yecho
        $WARN && sleep 5
    fi
    for i in ${!FILENAMES[@]}; do
        TITLE=${FILENAMES[i]##*/}
        TITLES[i]="${TITLE%%.*}"
    done
fi
if ! $TITLESET_MODE && ! $DO_TITLESETS && $QUICK_NAV && ! $VMGM_ONLY; then
    QUICK_NAV=false
    yecho
    yecho "No -quick-nav unless doing titlesets ... disabling this option"
    $WARN && sleep 5
    yecho
fi
if $DO_TITLESETS && ! $VMGM_MENU && ! $QUICK_NAV; then
    usage_error "You can not use -no-vmgm if doing titlesets unless using -quick-nav"
fi
# some things the vmgm menu does not support
if $VMGM_ONLY; then
    PLAYALL=false
    SUB_MENU=false
    ANI_SUB_MENU=false
    QUICK_MENU=false
    SM_TITLES=""
fi
if [[ -n "$SM_TITLES" ]]; then
    if test ${#SM_TITLES[@]} -ne ${#TITLES[@]}; then
    usage_error "Please give the same number of submenu titles as titles.
    You gave ${#SM_TITLES[@]} submenu titles and ${#TITLES[@]} titles"
    fi
fi
# titlesets use BASEDIR which is the WORK_DIR of the calling todisc
# BASEDIR is supplied by the calling todisc with -basedir
: ${BASEDIR:="$WORK_DIR"}

# Make sure -out was provided
if test -n "$OUT_PREFIX"; then
    OUT_DIR=$(readlink -f "$OUT_PREFIX")
    [[ $TARGET = "svcd" ]] && OUT_FILE="$OUT_DIR"
     if egrep -q '<|>|&' <<< "$OUT_DIR"; then
        usage_error "Sorry, dvdauthor will not let you use a -out name with '>', '<' or '&' in it.  Please choose another directory or name for -out  You used: "$OUT_DIR""
    fi
else
    usage_error "Please provide an output name with -out"
fi
# for dvdauthor.xml, if -intro was used
$DO_INTRO && INTRO="<vob file=\"$INTRO_CLIP\"/>"

# switched menus need more than one video file
if $SWITCHED_MENUS && [[ ${#FILES[@]} -eq 1 ]]; then
    usage_error "You can not use switched menus with only one file"
fi

# don't make submenus on each recursive call in switched mode
if $SWITCHED_MODE; then
    ANI_SUB_MENU=false && SUB_MENU=false
fi

if $VMGM_ONLY; then SWITCHED_MODE=false && SWITCHED_MENUS=false; fi
# need a way to get back to the VMGM menu, so -no-vmgm-menu requires -quicknav ? FIXME
# -no-vmgm requires -skip-vmgm for now; pass -no-vmgm-menu to subshells via NO_VMGM
if ! $VMGM_MENU; then
    SKIP_VMGM_MENU=:
    NO_VMGM="-no-vmgm-menu"
fi
# initialize MENU_AUDIOLENGTH now that options have been read
[[ -n $BG_AUDIO ]] && MENU_AUDIOLENGTH=${MENU_LEN[MENU_NUM-1]}

# honour -noask for functions and called scripts that use them
$NOASK && NO_ASK="-noask"
# Warn if thumb labels have more than 16 characters
if ! $SHOWCASE; then
    for ((i=0; i<${#TITLES[@]}; i++)); do
        val=${#TITLES[i]}
        [ -z "$MAX_CHARS" ] || ((val > MAX_CHARS)) && MAX_CHARS=$val && key=$i
    done
    if [[ ${#TITLES[@]} -gt 6 && $MAX_CHARS -gt 16 ]]; then
        yecho
        yecho "WARNING! Some titles are longer than 16 characters; they may be chopped off."
        yecho
        #echo "\"${TITLES[key]}\" is too long; please use a shorter title."
        #exit 1
    fi
fi
# set some vars for switched menus so we know where we are
$SWITCHED_MODE && SWITCHED_MENUS=false
($SWITCHED_MODE || $SWITCHED_MENUS) && SWITCHED=:
#
# sanity checks for button style ( -button-style ) for menu buttons
#

# FIXME checks have not been consolidated as options were added - needs cleanup

# use a suitable button style
for ((i=0; i<=NUM_FILES; i++)); do
    if test $(wc -l <<< "$(echo -e "${TITLES[i]}")") -gt 1; then
        MULTILINE_TITLE=:
        if $FEATHER && [ $THUMB_SHAPE != "normal" ]; then
            # multiline titles not suitable for text buttons
            BUTTON_STYLE="text-rect"
        elif $TEXTMENU; then
            [[ $BUTTON_STYLE != "line" ]] && BUTTON_STYLE="text-rect"
        else
            [[ $BUTTON_STYLE != "text-rect" ]] &&  ! $USER_BSTYLE && BUTTON_STYLE="rect"
        fi
    fi
done
# disallow spaces in thumb titles for text button style
if [ "$BUTTON_STYLE" = "text" ]; then
    for ((i=0; i<${#TITLES[@]}; i++)); do
        if grep "  " <<< "${TITLES[i]}" >/dev/null; then
            echo "Sorry, a maximum of one consecutive space is allowed in titles for text buttons"
            echo "\"${TITLES[i]}\" has more than one consecutive space in it"
            exit 1
        fi
    done
    if $SHOWCASE; then
        BUTTON_STYLE="line"
        yecho
        yecho "***** WARNING *****"
        yecho "You can not use text button style with showcase or textmenu"
        yecho "Changing button style to 'line' style instead"
        yecho "If you would rather use 'text-rect', or 'rect' for showcase,"
        yecho "please ctrl-c now to exit and rethink things"
        yecho
        $WARN && sleep 15
    fi
    if $TITLESET_MODE && $VMGM_MENU && $PLAYALL && ! $SHOWCASE; then
        BUTTON_STYLE="rect"
        yecho
        yecho "Warning ************"
        yecho "You can not use text button style when using both playall and titlesets"
        yecho "because of spumux and space limitations"
        yecho "Changing to 'rect' style of buttons"
        $WARN && sleep 15
    fi
fi
if [[ $BUTTON_STYLE = "line" ]] && ! $SHOWCASE; then
    yecho
    yecho "Sorry, button style 'line' is only for showcase and textmenu styles"
    yecho "Using button style 'rect' instead"
    yecho
    BUTTON_STYLE="rect"
    $WARN && sleep 10
elif $USER_BSTYLE && $TEXTMENU && [[ $BUTTON_STYLE = "rect" ]]; then
    $MULTILINE_TITLE && BUTTON_STYLE="text-rect" || BUTTON_STYLE="line"
    if [[ $MENU_NUM -eq 2 ]] ||  (! $SWITCHED_MODE && ! $SWITCHED_MENUS); then
        yecho
        yecho "Using button style '$BUTTON_STYLE' instead of 'rect' for textmenu menu"
        yecho
        $WARN && sleep 10
    fi
fi
# allow multiline titles in submenu
if [[ -n "$SM_TITLES" ]]; then
    for i in ${!SM_TITLES[@]}; do
        if [[ $(echo -e "${SM_TITLES[i]}" |wc -l) -gt 1 ]]; then
            SM_TITLES[i]="$(echo -e  "${SM_TITLES[i]}")"
        fi
    done
fi
# check if user passed a usable button shape
if [[ -n $THUMB_SHAPE ]]; then
    ! egrep -q  '^egg$|^oval$|^plectrum$|^normal$' <<< "$THUMB_SHAPE"  && \
        usage_error "Please supply a usable thumb shape with -thumb-shape option. You gave \"$THUMB_SHAPE\""
fi
# rotation doesn't play well with all options
if [[ -n ${ROTATE_ARRAY[@]} ]]; then
    $SHOWCASE && [[ $BUTTON_STYLE != text-rect ]] && BUTTON_STYLE="line"
    if ! $SHOWCASE; then
        if [[ $BUTTON_STYLE != "text" ]]; then
            BUTTON_STYLE="text"
            yecho
            yecho "Setting button style to 'text' so it will work with rotatation"
            yecho
            $WARN && sleep 10
        fi
    fi
fi
# multiline titles not allowed unless showcase style
# TODO move this down so to get rid of some && 's
if $MULTILINE_TITLE && ! $SHOWCASE && ! $SWITCHED && ! $QUICK_MENU; then
    usage_error "Sorry, multiline titles only allowed for showcase and textmenu styles"
fi
# no rect button style with rotated thumbs yet, so use text-rect fallback
if ([[ -n ${ROTATE_ARRAY[@]} ]] && $MULTILINE_TITLE) && [[ $BUTTON_STYLE = "rect" ]]; then
    BUTTON_STYLE="text-rect"
    yecho
    yecho "Using 'text-rect' instead of 'rect' button style for rotated thumbs"
    yecho
    $WARN && sleep 15
fi

# line or text-rect for "none" bg
if ! $USER_BSTYLE && $SHOWCASE; then # line or text-rect for "none" bg
    [[ $BUTTON_STYLE != "text-rect" ]] && BUTTON_STYLE="line"
fi
#
# end of button-style checks
#

# transparent border around text so rect spumux outline can fit
if [[ $BUTTON_STYLE = "text-rect" ]]; then
    TEXT_BORDER="-bordercolor Transparent -border 8x8"
fi

# set a maximum # of videos
# -rotate-thumbs broken for 3dthumbs and shaped thumbs
if ($FEATHER || $THUMBS_3D) && $ROTATE_THUMBS; then
    if ! $SHOWCASE; then
        yecho
        yecho "Sorry, rotated thumbs does not work currently"
        yecho "if you use shaped or 3d thumbs unless using showcase style"
        yecho "Disabling this option for you"
        yecho "Please ctrl-c now to exit if you wish to examine the situation"
        yecho
        $WARN && sleep 15
        unset ROTATE_ARRAY; ROTATE=false
    fi
fi

# If output directory already exists, print a message and exit
if test -e "$OUT_DIR"; then
    echo "Cleaning up created dirs"
    yecho
    echo "A file or directory named\"$OUT_DIR\" already exists."
    echo "Please use a different -out name, or (re)move the existing file or directory."
    rm -rf "$REAL_WORK_DIR"
    rm -f "$WORK_DIR"
    exit 1
fi
# see if advanced options were used and give warning if so
if [[ -n "${ADV_OPT[@]}" ]] && ! $SWITCHED_MODE; then
    yecho
    yecho "***** WARNING *****"
    yecho "You have used the following advanced options:"
    yecho "${ADV_OPT[@]}" | format_output
    yecho "With these options it is possible to create a menu where things overlap or"
    yecho "are offscreen, or that has other problems, so please check it with the preview."
    yecho "These are things that todisc tries to avoid normally, so if you have problems, please leave them out."
    yecho
    $WARN && sleep 15
fi

# Do text-only menu if requested
if $USE_MAKEMENU; then
    call_makemenu
    exit
fi
# copy symlinks for -group hack
if $GROUPING && $TITLESET_MODE; then
    find "$WORK_DIR"/  -type l -name \*group\*.mpg -exec cp -P {} "$BASEDIR" \;
fi
# Remove any existing log file
if ! $SWITCHED_MODE && ! $TITLESET_MODE && ! $DO_TITLESETS; then
    test -f "$LOG_FILE" && rm -fv "$LOG_FILE"
fi
if $SWITCHED_MENUS; then
    # call todisc recursively, collect intro.mpg, exit
    switched_menu_mode "${args[@]}"
fi
if $DO_TITLESETS; then
    # call todisc recursively, collect parts and author.  Then exit
    titleset_mode "${args[@]}"
    yecho Goodbye
    exit
fi

# set some vars for the last run of switched menus (non-recursive )
$SWITCHED_MENUS && SHOWCASE_FILE=${FILES[0]}

yecho
yecho "Creating work directories"
yecho

# create an array of grouped files. Hopefully LC_ALL=C takes care of sort issues
if $GROUPING; then
    LC_ALL="C" declare -a grouping=( $WORK_DIR/${TSET_NUM}-group*.mpg )
fi

# do some locale debugging
echo "You are using the following locale settings:" >> "$LOG_FILE"
locale >>  "$LOG_FILE" 2>&1
# if no bg supplied, use template.png so we can add a frame (-quick-menu only)
if [[ -z $BACKGROUND ]]; then
    BACKGROUND="$WORK_DIR/bg.png"
    convert  -resize $VIDSIZE! xc:'#'$BG_COLOUR $BACKGROUND
fi 
# check file type of background file and assign to BG_VIDEO or BG_IMAGE
if [[ -n $BACKGROUND ]]; then
    check_filetype "$BACKGROUND"
    if [[ $TYPE = "image" ]]; then
        BG_PIC="$BACKGROUND"
    elif [[ $TYPE = "video" ]]; then
#        $QUICK_MENU && usage_error "Sorry, image background only for -quick-menu"
        BG_VIDEO="$BACKGROUND"
    else
        usage_error "Sorry, can not identify "$BACKGROUND""
    fi
fi

# if $SHOWCASE, find out if using SHOWCASE_VIDEO or SHOWCASE_IMG or ! SC_THUMB
if $SHOWCASE; then
    if [[ -n ${SHOWCASE_FILE[@]} ]]; then
        check_filetype "${SHOWCASE_FILE[@]}"
        if [[ $TYPE = "image" ]]; then
            SHOWCASE_IMG=${SHOWCASE_FILE[@]}
        elif [[ $TYPE = "video" ]]; then
            SHOWCASE_VIDEO=${SHOWCASE_FILE[@]}
        else
            usage_error "Can not identify showcase file: "${SHOWCASE_FILE[@]}""
        fi
    else
        SC_THUMB=false
        SHOWCASE_IMG="dummy"
    fi
fi
if $QUICK_MENU; then
    if [[ -n $SHOWCASE_VIDEO ]]; then
        QUICK_MENU_FILE="$SHOWCASE_VIDEO"
        QUICKMENU_IS_SHOWCASE=:
    elif [[ -n $BG_VIDEO ]]; then
        QUICK_MENU_FILE="$BG_VIDEO"
        QUICKMENU_IS_BACKGROUND=:
    fi
fi
if $QUICK_MENU && ! $QUICKMENU_IS_SHOWCASE && ! $QUICKMENU_IS_BACKGROUND; then
    if ! $VMGM_ONLY && ! $SWITCHED; then
        yecho
        yecho "***** WARNING *****"
        yecho "-quick-menu needs a -showcase VIDEO or a -background VIDEO"
        yecho "Disabling -quick-menu for you as it is not needed"
        yecho "Ctrl-c now if you wish to exit and examine the situation"
        yecho
        QUICK_MENU=false
        $WARN && sleep 10
    fi
fi
$QUICKMENU_IS_BACKGROUND && SHOWCASE_IMG=""
# some checks for -quick-menu
if $QUICK_MENU; then
# quick-menu needs TEXTMENU=: , and does its own showcase and bg with ffmpeg
    TEXTMENU=:
    SC_THUMB=false
    STATIC=false # no static quickmenus, imagemagick is fast enough for this
fi
if [[ $SC_FRAMESTYLE = "glass" ]] && [[ -z $SHOWCASE_IMG && -z $SHOWCASE_VIDEO ]]; then
    yecho
    yecho "You must use -showcase option for '-showcase-framestyle. Either '"
    yecho "-showcase IMAGE, -showcase VIDEO, -showcase mix, or '-showcase'"
    yecho "Disabling this option for you - please ctrl-c now to exit"
    yecho "if you wish to reexamine the situation"
    yecho
    SC_FRAMESTYLE="none"
fi
if [[ $SC_FRAMESTYLE = "glass" ]] && $QUICK_MENU; then
    yecho
    yecho "You can not use 'glass' frame style with -quick-menu, disabling this option"
    yecho
    SC_FRAMESTYLE="none"
fi
# disable submenus for svcd
if $SUB_MENU && [ "$TARGET" = "svcd" ]; then
    usage_error "Sorry, no submenu for svcd, please remove -submenu option"
fi
[[ $TARGET = "svcd" ]] && $SHOWCASE && ! $TEXTMENU && \
usage_error "Sorry, showcase disabled for svcd target"
$SUB_MENU && $GROUPING && usage_error "Sorry, no submenus when using -group"
# allow user to only specify one audio file for all submenus
if [ ${#SM_AUDIO[@]} -eq 1 ]; then
    SM_AUDIO_FILE=${SM_AUDIO[0]}
fi
# if more than one audio file for submenu make sure they equal video #
if [[ ${SM_AUDIO[@]} &&  ${#FILES[@]} -ne ${#SM_AUDIO[@]} &&  ${#SM_AUDIO[@]} -ne 1 ]]; then
    usage_error "Please give the same number of submenu audios as videos.
    You gave ${#FILES[@]} video files and ${#SM_AUDIO[@]} audio files"
fi
# Get absolute pathnames of all files
if ! $VMGM_ONLY; then
    for i in "${FILES[@]}"; do
        IN_FILES=("${IN_FILES[@]}" "$(readlink -f "$i")")
        [[ ${#FILES[@]} -lt 30 ]] && echo "Adding: $i"
    done
fi
$VMGM_ONLY && V_TOTAL=$(( ${#TITLES[@]} - 1 )) || V_TOTAL=${#IN_FILES[@]}
$VMGM_ONLY && NUM_FILES=$(( ${#TITLES[@]} - 1 )) || NUM_FILES=$((V_TOTAL - 1))
# slide mix sets MONTAGE_MENU to false
$DO_SLIDE_MIX && MONTAGE_MENU=false
# some vars for slide mix
if $DO_SLIDE_MIX; then
    if [[ -n ${GROUP[@]} ]]; then
        mixgroup=( "$WORK_DIR"/${TSET_NUM}-group-*.mpg )
        for g in ${!mixgroup[@]}; do
            MIXFILES[g]=$(readlink -f "${mixgroup[g]}")
        done
#        MIXFILES=( "${IN_FILES[@]}" "$WORK_DIR"/${TSET_NUM}-group-*.mpg )
    else
        MIXFILES=( "${IN_FILES[@]}" )
    fi
   # randomize order to produce the final 'mix'
    for f in "${MIXFILES[@]}"; do
        a=$RANDOM
        while [[ ${shuffled[a]} ]]; do
            a=$RANDOM
        done
        shuffled[a]="$f"
    done
    # remove holes in the array and reassign to MIXFILES
    MIXFILES=( "${shuffled[@]}" )
    unset r
#    for b in "${shuffled[@]}"; do
#        MIXFILES[r++]="$b"
#    done
    if [[ -n $MIX_RANGE ]]; then
        for ((i=0; i<MIX_RANGE; i++)); do
            MIX_IN=( "${MIX_IN[@]}" "${MIXFILES[i]}" )
        done
    else
        MIX_IN=( "${MIXFILES[@]}" )
    fi
fi

# switch title position when appropriate so it doesn't get covered up
! $USER_TITLE_GEO && [[ $BUTTON_GRAVITY = *south* ]] && TITLE_GRAVITY="north"
if [[ $BUTTON_GRAVITY = *east* || $BUTTON_GRAVITY = *west* ]]; then
    ! $USER_GEO &&  XGEO=45 && YGEO=45
    ! $SHOWCASE && ! $USER_TITLE_GEO && TITLE_GRAVITY=north
fi
! $SHOWCASE && [[ $BUTTON_GRAVITY = "center" ]] && ! $USER_TITLE_GEO && TITLE_GRAVITY="north"

# dvdauthor stuff: make an array of possible vars for dvdauthor post calls
if $CHAIN_VIDEOS; then
    if [ -z "$post_play" ]; then
        for ((i=0; i<NUM_FILES; i++)); do
                POST_PLAY[i]=chain
            done
    else
        for j in $post_play; do
            if [[ $j = *-* ]]; then
                for ((i=${j/-*}; i<=${j/*-}; i++)); do
                    POST_PLAY[i-1]=chain
                done
            elif [[ $j != *[^0-9]* ]]; then
                POST_PLAY[j-1]=chain
            fi
        done
    fi
    echo
    for ((n=0; n<=NUM_FILES; n++)); do
        if [ "${POST_PLAY[n]}" = "chain" ]; then
            if [ $n -lt $NUM_FILES ]; then
                echo "video $((n+1)) will be chained with video $((n+2))"
            else
                echo "video $((n+1)) will be chained with video 1"
            fi
        fi
    done
    echo
fi
# make array, remove everything after and including 1st '+',
#CHAPTERS=( ${CHAPTERS%%+*} ) # in case of grouped chapters
# allow user to pass HH:MM:SS chapters
$USER_CHAPTERS && CHAPT_ARRAY=( ${CHAPTERS[@]} )
# if arbitrary grouped chapters passed, make an array of them
if $GROUPING && $USER_CHAPTERS; then
    for i in ${!IN_FILES[@]}; do
        if [[ -n ${GROUP[i]} ]]; then
            group_arbitrary_chapters[i]="${grouped_user_chapters[i]//+/ }"
        else
            group_arbitrary_chapters[i]=""
        fi
    done
fi
# if treating each video as a chapter, use 1 chapter.  No playall allowed here
if $MENUBUTTONS_ARE_CHAPTS; then
    if [[ -n ${grouping[@]} ]]; then
        usage_error "-videos-are-chapters can not be used with -group"
    else
         CHAPTERS=1 && PLAYALL=false
    fi
fi
# allow specifying one # of chapters for all videos if not given in HH:MM:SS
if [[ ${#CHAPTERS[@]} -eq 1 && -z ${CHAPT_ARRAY[@]} ]]; then
    for ((i=0; i<=NUM_FILES; i++)); do
        CHAPTERS[i]=${CHAPTERS[0]}
    done
fi
# make sure if -video-pause is given it equals the # of videos
if [[ -n ${VPAUSE[@]} && ${#VPAUSE[@]} -ne 1 ]]; then
    if [[ ${#VPAUSE[@]} -ne ${#IN_FILES[@]} ]]; then
        usage_error "# of -video-pause args must equal 1 or the # of videos"
    fi
fi
# make sure if -group-video-pause is given it equals the # of videos
if [[ -n ${GRP_VPAUSE[@]} && ${#GRP_VPAUSE[@]} -ne 1 ]]; then
    if [[ ${#GRP_VPAUSE[@]} -ne ${#grouping[@]} ]]; then
        usage_error "# of -video-pause args must equal 1 or the # of videos"
    fi
fi
# allow specifying one # for -video-pause
if [[ -n ${VPAUSE[@]} && ${#VPAUSE[@]} -eq 1 ]]; then
    for ((i=0; i<=NUM_FILES; i++)); do
        VPAUSE[i]=${VPAUSE[0]}
    done
fi
# allow specifying one # for -group-video-pause
if [[ -n ${GRP_VPAUSE[@]} && ${#GRP_VPAUSE[@]} -eq 1 ]]; then
    for i in ${!grouping[@]}; do
        GRP_VPAUSE[i]=${GRP_VPAUSE[0]}
    done
fi
#        if [[ ${CHAPTERS[@]} = *:* && ${CHAPTERS[i]} != *:* ]]; then
#            usage_error "if passing HH:MM:SS chapters, all video chapters must have this format"
#        fi


# if more than one value for CHAPTERS, make sure they equal video #
if $SUB_MENU &&  [[ ${#FILES[@]} -ne ${#CHAPTERS[@]} ]]; then
    $USER_CHAPTERS && string="chapter point string" || string="chapter"
    usage_error "Please give the same number of ${string}s as videos.
    You gave ${#FILES[@]} video files and ${#CHAPTERS[@]} ${string}(s)"
fi
# get normal CHAPTERS VAR,i.e.: 'how many chapters'
# Check if 1st is 00:00:00 and all chapters have HH:MM:SS format
if $USER_CHAPTERS; then
    for i in ${!CHAPT_ARRAY[@]}; do
        [[ ${CHAPTERS[i]} != *:* ]] && usage_error \
        "for HH:MM:SS style chapters all video chapters must have this format"
        if [[ ${CHAPT_ARRAY[i]:0:8} != 00:00:00 ]];then
            usage_error \
            "1st chapter must be 00:00:00. ${IN_FILES[i]} used ${CHAPT_ARRAY[i]}"
        fi
        CHAPTERS[i]=$(wc -w <<< "${CHAPT_ARRAY[i]//,/ }")
    done
fi

# find out longest chapter value (number of chapters)
if $SUB_MENU; then
    for ((i=0; i<${#CHAPTERS[@]}; i++)); do
        chapt_val=${CHAPTERS[i]}
#        [[ $chapt_val = *:* ]] && chapt_val=$(unformat_time $chapt_val)
        [ -z "$MAX_CHAPTERS" ] || ((chapt_val > MAX_CHAPTERS)) && MAX_CHAPTERS=$chapt_val && max_chapt_key=$i
        [ -z "$MIN_CHAPTERS" ]  || ((chapt_val < MIN_VAL)) && MIN_CHAPTERS=$chapt_val && min_chapt_key=$i
    done
fi
# do not let user use -chapters 0 (-chapters 5 0 6)
no_chapters=false
for ((i=0; i<${#CHAPTERS[@]}; i++)); do
    if ((${CHAPTERS[i]} == 0)); then
        no_chapters=:
    fi
done
if $SUB_MENU && $no_chapters; then
    usage_error "Please use -chapters 1 not -chapters 0, if you do not want
     chapters.  -chapters 0 is a special case that makes each video a chapter."
fi
# create_dirs
echo
yecho "Creating pics directories..."
for ((i=0; i<=NUM_FILES; i++)); do
    mkdir -p "$REAL_WORK_DIR/pics/$i"
done
yecho "${#FILES[@]} pics directories created"
# textmenu is static unless there is an animated background or showcase video
if $TEXTMENU && [[ -z $SHOWCASE_VIDEO && -z $BG_VIDEO ]]; then STATIC=:; fi
# prevent user from using mutually exclusive options
if $STATIC; then
    MENU_FADE=false
fi
if $MENU_FADE || test -n "$BG_VIDEO"; then mkdir -v "$REAL_WORK_DIR/bg"; fi
mkdir -v "$REAL_WORK_DIR/animenu"
if $ANI_SUB_MENU; then
    for ((i=0; i<MAX_CHAPTERS; i++)); do
        mkdir -v "$REAL_WORK_DIR/animenu/$i"
    done
fi
if $SUB_MENU && ! $ANI_SUB_MENU; then
    mkdir -v "$REAL_WORK_DIR/submenu"
fi
if [[ -n "$SHOWCASE_VIDEO" ]]; then
    mkdir -v "$REAL_WORK_DIR/showcase"
fi
# if Fading menu, and no BG IMAGE OR VIDEO, fade thumbs right in after title
if $MENU_FADE && [[ -z "$BG_PIC" && -z "$BG_VIDEO" ]]; then
    THUMBS_FADE_IN_START_TIME=2.5
fi
# if more than one value for AUDIO_LANG, make sure they equal video #
if $AUDIOLANG &&  [[ ${#FILES[@]} -ne ${#AUDIO_LANG[@]} &&  ${#AUDIO_LANG[@]} -ne 1 ]]; then
    usage_error "Please give the same number of audio channels as videos.
    You gave ${#FILES[@]} video files and ${#AUDIO_LANG[@]} audio channel values"
fi
# make sure number of -rotate-thumbs arguments equals number of videos
if [[ -n ${ROTATE_ARRAY[@]} ]]; then
    if  [[ ${#FILES[@]} -ne ${#ROTATE_ARRAY[@]} ]]; then
        usage_error "Please give the same number of thumb rotate values as videos.
        You gave  ${#FILES[@]} video files and ${#ROTATE_ARRAY[@]} thumb rotate values."
    fi
fi
# if only one seek value, then use for all videos
if [ ${#SEEK_VAL[@]} -eq 1 ]; then
    for ((i=0; i<=NUM_FILES; i++)); do
        SEEK_VAL[i]=${SEEK_VAL[0]}
        SEEK[i]="-ss ${SEEK_VAL[i]}" # create seek value for each video
    done   
fi

if [ ${#MENU_LEN[@]} -eq 1 ]; then
    for ((i=0; i<=NUM_FILES; i++)); do
        MENU_LEN[i]=${MENU_LEN[0]}
    done
fi
# allow -seek to have HH:MM:SS format passed
for ((i=0; i<=NUM_FILES; i++)); do
    if [[ "${SEEK_VAL[i]}" = *:* ]]; then
        SEEK_VAL[i]=$(unformat_time ${SEEK_VAL[i]})
    fi
done
# make sure if more than one seek value, they equal the number of video
if ! $VMGM_ONLY &&  [[ ${#FILES[@]} -ne ${#SEEK_VAL[@]} &&  ${#SEEK_VAL[@]} -ne 1 ]]; then
    usage_error "Please give the same number of seek times as videos, or just use one value.
    You gave ${#FILES[@]} video files and ${#SEEK_VAL[@]} seek times"
fi
# make sure if more than one -menu-length value, they equal the number of video
if ! $VMGM_ONLY &&  [[ ${#FILES[@]} -ne ${#MENU_LEN[@]} &&  ${#MENU_LEN[@]} -ne 1 ]]; then
    usage_error "Please give the same number of -menu-length times as
    videos, or just use one value.  You gave ${#FILES[@]} video files
    and ${#MENU_LEN[@]} -menu-length times"
fi
if ! $VMGM_ONLY; then
    # two values for length of video(frames) and audio(secs) for slides
    slen=4
    alen=$(bc_math "4 / $FRAME_RATE") # 0.16 or 0.133
    echo
    echo "Verifying that input files are video or image files"
    verify_infiles infiles
    if $GROUPING; then 
        echo
        echo "Verifying that grouped input files are video or image files"
        verify_infiles group
        echo
    fi
    echo
fi
echo
# All files must be images for slide mix.
# if all are images, then we are doing a slideshow.
echo 
if [[ ${#file_is_image[@]} = ${#IN_FILES[@]} \
 && ${#grp_file_is_image[@]} = ${#grouping[@]} ]]; then
    if ! $VMGM_ONLY; then
        SLIDESHOW=:
        DO_STATS=false
        [[ -z ${GROUP[@]} ]] && DO_FRAME=false
        [[ -z ${GROUP[@]} ]] && DO_BUTTONS=false
    fi
else
    $DO_SLIDE_MIX && usage_error "All files must be images for a slideshow"
fi
# no playall for single slideshow
if $SLIDESHOW && [[ -z ${#grouping[@]} ]]; then
    PLAYALL=false
fi
# set a maximum # of videos
if $SHOWCASE; then
    $TEXTMENU && file_max=30 || file_max=10
    test  ${#FILES[@]} -gt $file_max && \
    ! $SLIDESHOW && usage_error \
     "Sorry, a maximum of $file_max titles is allowed for this style
    You gave ${#FILES[@]} videos as input"
else
    if test ${#FILES[@]} -gt 30; then
        # SVCD without titles or without a menu can support 97 videos/slides
        if [[ $TARGET = "svcd" ]]; then
            :
        else
            ! $SLIDESHOW && usage_error \
             "Sorry, a maximum of 30 videos (thumbs) is supported
             You gave ${#FILES[@]} videos as input"
        fi
    fi
fi

$DO_SLIDE_MIX && [[ ${#GROUP[@]} -gt 0 ]] && usage_error \
"you can not do a 'slide mix' menu if using -group ( ie. more than one
slideshow in the menu).  If you were wanting to do only one slideshow
use for example: -files images/*.jpg "  
# [[ $TARGET = "svcd" ]] && ! $VMGM_MENU && DO_MENU=false #FIXME
if $SLIDESHOW ; then
    [[ -z ${grouping[@]} ]] && PLAYALL=false
    ! $MONTAGE_MENU && DO_MENU=false
fi

# for slides or short files, seeking/fading will not work: set them to 0
# if user has not set a value from the command line
for i in ${!IN_FILES[@]}; do
    SHORTFILE=false
    if [[ ${file_is_image[i]} = "yes" ]]; then
        SHORTFILE=:
    else
        FRAME_CK=$(vid_length ${IN_FILES[i]} 90)
        [[ $(bc_math "$FRAME_CK < 2") -eq 1 ]] && SHORTFILE=:
    fi
    if $SHORTFILE; then
        ! $USER_SEEK_VAL && SEEK_VAL[i]=0
#        ! $USER_AUDIO_FADE && FADE=0 # FIXME 
        STATIC=:
        ! $USER_CHAPTERS && CHAPTERS[i]=1
    fi
done
if [[ $FADE -eq 0 ]]; then # in case user thinks he needs to specify 0 for fade
    AUDIO_FADE=false
elif [[ $SM_FADE -eq 0 ]]; then
    SM_AUDIO_FADE=false
fi
##############################################################################
# Font defaults
##############################################################################

if $DO_MENU; then
    # Menu title font size
    test $TARGET = "dvd" && : ${MENU_FONTSIZE:="30"}
    test $TARGET = "svcd" && : ${MENU_FONTSIZE:="26"}
    # Thumbnail title font size
    if test -z "$THUMB_FONTSIZE"; then
    # if not -thumb-fontsize N passed, use default, based on the following:
        if $SHOWCASE; then
            if test "$NUM_FILES" -lt 2; then
                THUMB_FONTSIZE=20
            elif  test "$NUM_FILES" -eq 2; then
                THUMB_FONTSIZE=18
            elif  test "$NUM_FILES" -ge 3; then
                THUMB_FONTSIZE=16
            fi
        else
            THUMB_FONTSIZE=10
        fi
    fi

    # See if "Helvetica" or "helvetica" are available as default fonts
    if convert -size 50x20 xc:none -font Helvetica -gravity Center \
    -draw "text 0,0 'test'" "$WORK_DIR/font.png"; then
        DEFAULT_FONT="Helvetica"
    elif convert -size 200x100 xc:none -font helvetica -gravity Center \
    -draw "text 0,0 'test'" "$WORK_DIR/font.png"; then
        DEFAULT_FONT="helvetica"
    fi
    # If user did not specify fonts, use default
    test -z "$MENU_FONT" && MENU_FONT=$DEFAULT_FONT
    test -z "$THUMB_FONT" && THUMB_FONT=$DEFAULT_FONT
    rm -f "$WORK_DIR/font.png"


    # Some user feedback
    if ! $SLIDESHOW; then
        yecho
        if $VMGM_ONLY; then
            yecho "Disc title: \"$MENU_TITLE\""
        else
            yecho "Menu title: \"$MENU_TITLE\""
        fi
        yecho "  (adjust with -menu-title)"
        yecho "Including the following files:"
        # do not echo all of long or multiline titles AND files
        for ((i=0; i<${#TITLES[@]}; i++)); do
            if [[ ${#TITLES[i]} -gt 35 || \
            $(echo -e "${TITLES[i]}" |wc -l) -gt 1 ]]; then
                TITLE[i]=$(sed 's/^  *//'<<<${TITLES[i]//\\n/ }) # no spaces or \n
                TITLE[i]=${TITLE[i]:0:35} # cut down to 35 characters maximum
                if [ ${#TITLES[i]} -gt 35 ]; then
                    echo "  \"${TITLE[i]}...\" (${IN_FILES[i]})" # "..." if cut off
                else
                    echo "  \"${TITLE[i]}\" (${IN_FILES[i]})"
                fi
            else # echo titles "as is"
                echo "  \"${TITLES[i]}\" (${IN_FILES[i]})"
            fi
            if [[ $(echo -e "${TITLES[i]}" |wc -l) -gt 1 ]]; then
                # if there is a multiline title we need to align to right of thumbs
                SC_TITLE_ALIGN=east
                ALIGN_OVERRIDE=:
            fi
        done
        yecho "Current font settings: "
        yecho "  -menu-font $MENU_FONT"
        yecho "  -menu-fontsize $MENU_FONTSIZE"
        yecho "  -thumb-font $THUMB_FONT"
        yecho "  -thumb-fontsize $THUMB_FONTSIZE"
        if ! $VMGM_ONLY; then
            yecho "Current menu settings: "
            if  ! $STATIC; then
                yecho "  -menu-length ${MENU_LEN[MENU_NUM-1]} seconds"
            fi
            if $ANI_SUB_MENU; then
                yecho "  -submenu-length $ANI_SUBMENU_LEN seconds"
                if $SUBMENU_AUDIO; then
                    yecho "  -submenu-audio-fade $SM_FADE second(s)"
                fi
            fi
                for ((i=0; i<=NUM_FILES; i++)); do
                    echo -n "Video $((i+1)):"
                    echo -n "  -seek ${SEEK_VAL[i]} second(s)"
                    echo "  -chapters ${CHAPTERS[i]}"
                done
            if [ ! $STATIC ]; then
                yecho "  -menu-audio-fade $FADE second(s)"
            fi
            yecho
        fi
    fi
fi

# TODO: Merge these globals with the ones up top
# only the 1st 6 are mergable - keeping them here for debugging this beast :)
DVD_GEO_ARRAY=(320x240 272x204 192x144 192x144 184x138 184x138 136x102 136x102 \
120x90 120x90 120x90 120x90 96x72 96x72 96x72 96x72 96x72 96x72 \
96x72 96x72 80x60 80x60 80x60 80x60 80x60 80x60 80x60 80x60 \
80x60 80x60 60x40 40x30 40x30 40x30 40x30 40x30 40x30 40x30 \
40x30 40x30)
for i in {41..98}; do DVD_GEO_ARRAY[i]="40x30"; done
# 10/row, 8 in 1st row
SVCD_GEO_ARRAY=(240x240 180x180 120x120 120x120 120x120 120x120 96x96 96x96 \
96x96 80x80 80x80 80x80 64x64 64x64 64x64 64x64 64x64 64x64 \
64x64 64x64 48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48 \
48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48 \
48x48 48x48 40x40 40x40 40x40 40x40 40x40 40x40 40x40 40x40 \
40x40 40x40 36x36 36x36 36x36 36x36 36x36 36x36 36x36 36x36 \
36x36 36x36 30x30 30x30 30x30 30x30 30x30 30x30 30x30 30x30)
#for i in {4..98}; do SVCD_GEO_ARRAY[i]="36x36"; done
for i in {67..98}; do SVCD_GEO_ARRAY[i]="36x36"; done
# 15 per row
TILE_ARRAY=(1x1 2x1 2x2 2x2 3x2 3x2 4x2 4x2 3x3 4x3 4x3 4x3 4x4 4x4 4x4 \
4x4 5x4 5x4 5x4 5x4 5x5 5x5 5x5 5x5 5x5 6x5 6x5 6x5 6x5 6x5 \
6x6 6x6 6x6 6x6 6x6 6x6 7x6 7x6 7x6 7x6 7x6 7x6 7x6 7x7 7x7 \
7x7 7x7 7x7 7x7 8x7 8x7 8x7 8x7 8x7 8x7 8x7 8x8 8x8 8x8 8x8 \
8x8 8x8 8x8 8x8 9x8 9x8 9x8 9x8 9x8 9x8  9x8 9x9 9x9 9x9 9x9 \
9x9 9x9 9x9 9x9 9x9 10x9 10x9 10x9 10x9 10x9 10x9 10x9 10x9 10x9 10x10 \
10x10 10x10 10x10 10x10 10x10 10x10 10x10)
SHOWCASE_THUMB_Y_ARRAY=("166" "110 240" "75 175 275" "68 148 228 308" \
"68 131 194 257 320" "75 175 275 75 175 275" "68 148 228 308 68 148 228" \
"68 148 228 308 68 148 228 308" "68 131 194 257 320 68 131 194 257" \
"68 131 194 257 320 68 131 194 257 320")
SHOWCASE_TITLES_Y_ARRAY=("144" "88 218" "54 154 254" \
"50 130 210 290" "49 112 175 238 301" "54 154 254 54 154 254" \
"50 130 210 290 50 130 210" "50 130 210 290 50 130 210 290" \
"49 112 175 238 301 49 112 175 238" \
"49 112 175 238 301 49 112 175 238 301")
SHOWCASE_THUMB_X_ARRAY=("86" "86 86" "86 86 86" "86 86 86 86" \
"86 86 86 86 86" "86 86 86 538 538 538" "86 86 86 86 554 554 554" \
"86 86 86 86 554 554 554 554" "86 86 86 86 86 574 574 574 574" \
"86 86 86 86 86 574 574 574 574 574")
SHOWCASE_THUMB_X_ARRAY=( ${SHOWCASE_THUMB_X_ARRAY[NUM_FILES]} )
SHOWCASE_THUMB_Y_ARRAY=( ${SHOWCASE_THUMB_Y_ARRAY[NUM_FILES]} )
SHOWCASE_TITLES_X_ARRAY=( ${SHOWCASE_THUMB_X_ARRAY[@]} )
SHOWCASE_TITLES_Y_ARRAY=( ${SHOWCASE_TITLES_Y_ARRAY[NUM_FILES]} )
if $TEXTMENU ; then
    ! $USER_SPLIT && SPLIT=13 # max number of text only titles in one column (-textmenu)
    if [[ $NUM_FILES -gt 12 ]] && ! $USER_SPLIT; then
        SPLIT=$((V_TOTAL / 2))
        [[ $(( SPLIT * 2)) -ne $V_TOTAL ]] && let SPLIT=SPLIT+1
    fi
#    for ((b=0; b<=NUM_FILES; b++)); do
#        ((b < SPLIT)) && SHOWCASE_TITLES_X_ARRAY[b]=86 || SHOWCASE_TITLES_X_ARRAY[b]=360
#    done
fi
# needed to centre showcase img: col 1 will always be larger value than col 2
if $SHOWCASE && ! $TEXTMENU; then
    ((NUM_FILES < 5)) && SPLIT=$((NUM_FILES+1))
    ((NUM_FILES == 5)) && SPLIT=3
    ((NUM_FILES >= 6)) && SPLIT=4
    ((NUM_FILES >= 8)) && SPLIT=5
fi
# Montage geometry: closer together for large arrangements
((NUM_FILES >= 30)) && MTG_GEO=+2+2
if  [ $TARGET = "dvd" ]; then
    AUDIO_EXT="ac3"
    SAMPLERATE="48000"
    MPLEX_FORMAT="8"
    GEO_ARRAY=("${DVD_GEO_ARRAY[@]}")
    FFMPEG_OPTS="-b 7000k  -maxrate 8000k -bufsize 224KiB -aspect 4:3"
    ASPECT="-aspect $ASPECT_RATIO"
    SHOWCASE_SIZE=384x256
    BURN_TGT="$OUT_DIR"
    BURN_TGT_STR="DVD directory"
    BURN_PROG="makedvd"
    if [ $TV_STANDARD = "ntsc" ]; then
        VIDSIZE="720x480"
        FRAME_RATE=29.970
    elif [ $TV_STANDARD = "pal" ]; then
        VIDSIZE="720x576"
        FRAME_RATE=25
    fi
elif [ $TARGET = "svcd" ]; then
    AUDIO_EXT="mp2"
    SAMPLERATE="44100"
    MPLEX_FORMAT="4"
    GEO_ARRAY=("${SVCD_GEO_ARRAY[@]}")
    FFMPEG_OPTS="-b 2200k -minrate 2200k -maxrate 2200k -bufsize 112KiB -aspect 4:3"
    ASPECT="-aspect $ASPECT_RATIO"
    SHOWCASE_SIZE=256x256
    BURN_TGT="${OUT_FILE}.xml"
    BURN_TGT_STR="SVCD image"
    BURN_PROG="makevcd"
    BURN_DEVICE=/dev/cdrw
    [[ -n $svcd_pause ]] && SVCD_PAUSE="-pause $svcd_pause"
    if [ $TV_STANDARD = "ntsc" ]; then
        VIDSIZE="480x480"
        FRAME_RATE=29.970
    elif [ $TV_STANDARD = "pal" ]; then
        VIDSIZE="480x576"
        FRAME_RATE=25
    fi
fi
THUMB_SIZE=${GEO_ARRAY[NUM_FILES]}
if $SHOWCASE; then
    if [ -z ${BLUR/.*} ]; then
        BLUR=0.${BLUR/*.}
    fi
    if [ ${BLUR/.*} -ge 2 ]; then
        BLUR=2.0
    fi
    if [ $V_TOTAL -lt 3 ]; then
        THUMB_SIZE=${GEO_ARRAY[10]}
    elif [ $V_TOTAL -eq 3 ]; then
        THUMB_SIZE=${GEO_ARRAY[13]}
    elif [ $V_TOTAL -eq 4 ]; then
        THUMB_SIZE=${GEO_ARRAY[23]}
    elif [ $V_TOTAL -eq 5 ]; then
        THUMB_SIZE=${GEO_ARRAY[30]}
    elif [ $V_TOTAL -eq 6 ]; then
        THUMB_SIZE=${GEO_ARRAY[13]}
    elif [[ $V_TOTAL -ge 7 && $V_TOTAL -le 8 ]]; then
        THUMB_SIZE=${GEO_ARRAY[23]}
    elif [[ $V_TOTAL -ge 9 && $V_TOTAL -le 10 ]]; then
        THUMB_SIZE=${GEO_ARRAY[30]}
    fi
fi

#create seek value for each video
for ((i=0; i<=NUM_FILES; i++)); do
    # translate SEEK_VAL into frames for transcode
    SEEK_FRAMES[i]=$(bc_math "${SEEK_VAL[i]} * $FRAME_RATE" int)
done

# some choices needed for different title alignments
if $SHOWCASE && ! $TEXTMENU; then
    if [ $V_TOTAL -le 5 ]; then
        if [[ $SC_TITLE_ALIGN = "east" ]]; then
            SHOWCASE_SIZE=288x216  # smaller to allow for titles
            [ $TARGET = "svcd" ] && SHOWCASE_SIZE=216x216
        else
            SHOWCASE_SIZE=384x256
            [ $TARGET = "svcd" ] && SHOWCASE_SIZE=256x256
        fi
        AUTOORDER="rows"       # spumux var
    else
        SHOWCASE_SIZE=288x216  # smaller showcase thumb because we have 2 rows
        [ $TARGET = "svcd" ] && SHOWCASE_SIZE=216x216
        AUTOORDER="columns"
        if $SC_THUMB && [[ "$SC_TITLE_ALIGN" = "east" ]] && [[ -n $SHOWCASE_FILE ]]; then
            usage_error "Sorry, there is no room for the showcase thumb " \
            "if you use more than 5 videos with -showcase-titles-align " \
            "east|west (also multiline titles). Either change the problem " \
            "option, remove the showcase image/video, or use -textmenu.  Or " \
            "consider using -bgimage or -bgvideo instead of a showcase thumb."
        fi
    fi
elif ! $SHOWCASE && ! $TEXTMENU; then
    AUTOORDER="rows"
elif $TEXTMENU; then
    AUTOORDER="columns"
fi
$TEXTMENU && LEFT_MAX=$SPLIT || LEFT_MAX=5
if [ "$SC_TITLE_ALIGN" = "west" ] || $TEXTMENU; then #FIXME
    THUMB_TITLE_ALIGN="west" # for non TEXTMENU menu
    for ((i=0; i<=NUM_FILES; i++)); do
        if [ $i -lt $LEFT_MAX ]; then
            SHOWCASE_THUMB_X_ARRAY[i]=$(( ${SHOWCASE_THUMB_X_ARRAY[i]} - SAFE_OFFSET ))
            SHOWCASE_TITLES_X_ARRAY[i]=$(( ${SHOWCASE_TITLES_X_ARRAY[i]} - SAFE_OFFSET ))
        fi
        if ! $TEXTMENU && ! [[ $SHOWCASE_FILE ]]; then
            if [ ${SHOWCASE_THUMB_X_ARRAY[i]} -gt $(( ${VIDSIZE/x*} / 2 )) ]; then
                SHOWCASE_THUMB_X_ARRAY[i]=$(( ${VIDSIZE/x*} / 2 ))
                SHOWCASE_TITLES_X_ARRAY[i]=$(( ${VIDSIZE/x*} / 2 ))
            fi
        fi
    done
fi
# centre aligned titles are not for textmenu style
if $TEXTMENU && [[ $SC_TITLE_ALIGN = "center" ]]; then
    yecho
    yecho "Sorry, you can not use center align for textmenu titles"
    yecho "Using title alignment of 'west': please check the preview"
    yecho
    SC_TITLE_ALIGN="west"
    $WARN && sleep 10
fi
if  [[ $BUTTON_STYLE = "text-rect" ]] && ! $SHOWCASE; then
    yecho  "You can only use text-rect button style with showcase or textmenu arrangements"
    yecho "Setting button style to 'rect'"
    yecho "If you would rather use 'text' style please ctrl-c now to exit and reform your command"
    BUTTON_STYLE="rect"
    $WARN && sleep 15
fi
#  -align east uses text-rect
if [[ $BUTTON_STYLE = "text-rect" ]] && ! [[ $SC_TITLE_ALIGN = "east" ]] && ! $TEXTMENU; then
    yecho "***Warning*** \
    text-rect buttons need to be aligned east of thumbs: \
    by using: '-showcase-titles-align east'"
    if [[ -n $SHOWCASE_FILE ]]; then
        echo "However, you are using a -showcase FILE, so choosing 'line' buttons instead"
        echo "If you wish you may use instead: '-button-style rect' - in which case exit now . . ."
        BUTTON_STYLE="line"
    else
        SC_TITLE_ALIGN="east"
    fi
    yecho
    $WARN && sleep 10
fi
if $SHOWCASE && [ "$SC_TITLE_ALIGN" = "east" ] && ! $TEXTMENU; then
    THUMB_TITLE_ALIGN="west" # align titles left to allow longer titles
    for ((i=0; i<=NUM_FILES; i++)); do
        if [ $i -lt $LEFT_MAX ] && ! $ALIGN_OVERRIDE; then
            SHOWCASE_THUMB_X_ARRAY[i]=$(( ${SHOWCASE_THUMB_X_ARRAY[i]} - SAFE_OFFSET ))
            SHOWCASE_TITLES_X_ARRAY[i]=$(( ${SHOWCASE_TITLES_X_ARRAY[i]} - SAFE_OFFSET ))
        fi
        if [ ${SHOWCASE_THUMB_X_ARRAY[i]} -gt 360 ]; then
            SHOWCASE_THUMB_X_ARRAY[i]=360
        fi
        if ! $TEXTMENU; then
            SHOWCASE_TITLES_X_ARRAY[i]=$(( ${SHOWCASE_THUMB_X_ARRAY[i]} + ${THUMB_SIZE/x*} + 5 ))
            SHOWCASE_TITLES_Y_ARRAY[i]=$(( ${SHOWCASE_TITLES_Y_ARRAY[i]} + 18 ))
        fi
    done
fi
if ($USER_GRAVITY && $SHOWCASE && ! $TEXTMENU) && [[ $BUTTON_GRAVITY != north ]]; then
    SW_CORNER=$(( ${SHOWCASE_THUMB_Y_ARRAY[SPLIT-1]} + ${THUMB_SIZE/*x} ))
    if [[ $BUTTON_GRAVITY = *south* ]]; then
        Y_OFFSET=$(( ( ${VIDSIZE/*x} - SAFE_AREA) - SW_CORNER ))
    elif [[ $BUTTON_GRAVITY = *st* ]] || [[ $BUTTON_GRAVITY = *center* ]]; then
        COL1_HEIGHT=$(( SW_CORNER - ${SHOWCASE_TITLES_Y_ARRAY[0]} ))
        Y_OFFSET=$(( ( ${VIDSIZE/*x} / 2) - (COL1_HEIGHT / 2) ))
        Y_OFFSET=$(( Y_OFFSET - ${SHOWCASE_TITLES_Y_ARRAY[0]} ))
    fi
    for ((i=0; i<=NUM_FILES; i++)); do
        SHOWCASE_THUMB_Y_ARRAY[i]=$(( ${SHOWCASE_THUMB_Y_ARRAY[i]} + Y_OFFSET ))
        SHOWCASE_TITLES_Y_ARRAY[i]=$(( ${SHOWCASE_TITLES_Y_ARRAY[i]} + Y_OFFSET ))
    done
fi

# find out the showcase thumb "-page" array for this arrangement
for ((i=0; i<=NUM_FILES; i++)); do
    if $TEXTMENU; then
        SHOWCASE_THUMB_PAGES_ARRAY[i]=+${SHOWCASE_TITLES_Y_ARRAY[i]}+${SHOWCASE_TITLES_X_ARRAY[i]}
    else
        SHOWCASE_THUMB_PAGES_ARRAY[i]=+${SHOWCASE_THUMB_X_ARRAY[i]}+${SHOWCASE_THUMB_Y_ARRAY[i]}
    fi
done

PATTERN=$(for ((i=1; i<=79; i++)); do echo -n \*; done)
printf "%s\n%s\n%s\n\n\n" "$PATTERN" \
"todisc from the tovid suite - log for `date`" \
"$PATTERN" >> "$LOG_FILE"

# Do everything in $WORK_DIR
echo -e "**** NOTE ****\n"
echo "Doing all work in directory $REAL_WORK_DIR"
echo "$WORK_DIR will be a symlink pointing to this directory"
echo -e "\n**************"
sleep 1
cd "$WORK_DIR"
# BASEDIR is the dir of the calling script, if unset, use WORK_DIR (For vmgm)
: ${BASEDOR:-$WORK_DIR}

# default of no blur if using 3D thumbs
if $THUMBS_3D; then
    BLUR=0.1
fi

$FOURxONE && $SHOWCASE && FOURxONE=false && tile_warning
$THREExONE && $SHOWCASE && THREExONE=false && tile_warning
# allow specifically setting the geometry for 3 videos to 1x3 page
if $THREExONE && [ $V_TOTAL -eq 3 ]; then
    TILE_ARRAY[2]=3x1
elif $FOURxONE && [[ $V_TOTAL -eq 4 ]]; then
    TILE_ARRAY[3]=4x1
    THUMB_SIZE=${GEO_ARRAY[6]}
fi
if ( ($DO_TITLESETS || $TITLESET_MODE) && $VMGM_MENU ) || $PLAYALL; then
    if [[ $BUTTON_GRAVITY = "south" ]]; then
        BUTTON_GRAVITY="center"
        yecho "Changing thumb alignment to 'center' to make room for navigation button"
    fi
fi

# do not use frame for showcase-framestyle glass
if [[ "$SC_FRAMESTYLE" = "glass" && -n "$SHOWCASE_VIDEO" ]] ; then
    unset SC_FRAME
fi
if $SHOWCASE; then
    THUMB_BG_COLOUR="none"   # mist backgrounds look a bit funny with showcase
fi
# easier to have non transparent showcase use the transparent block
if $SHOWCASE && ! $TRANSPARENT; then TRANSPARENT=:; fi
AUDIO_OPTS="-ab 224k -ar $SAMPLERATE -ac 2 -acodec $AUDIO_EXT"
# spumux and dvdauthor vars
$WIDE_SCRREN || [[ -n "$V_ASPECT" ]] && TITLES_VID_TAG="<video " 
$WIDE_SCREEN && TITLES_VID_TAG=" $TITLES_VID_TAG <widescreen=\"$WIDESCREEN\""
[[ -n "$V_ASPECT" ]] && TITLES_VID_TAG="$TITLES_VID_TAG $V_ASPECT"
[[ -n $TITLES_VID_TAG ]] && TITLES_VID_TAG="$TITLES_VID_TAG />"
START="00:00:00.0"
$PLAYALL && TITLESET_PRE="g4=0;"
$ITLESET_MODE && TITLESET_PRE="$TITLESET_PRE g2=1;"

if $AUDIOLANG; then
    # if only one -audio-lang value, then use for all videos
        for ((i=0; i<=NUM_FILES; i++)); do
            if [ ${#AUDIO_LANG[@]} -eq 1 ]; then
                AUDIO_PRE[i]="audio=${AUDIO_LANG[0]};"
            else
                AUDIO_PRE[i]="audio=${AUDIO_LANG[i]};"
            fi
        done
    for ((i=0; i<=NUM_FILES; i++)); do # create audio tag for dvdauthor
        VOB_PRE[i]="        <pre> ${AUDIO_PRE[i]} </pre>"
    done
fi

MAIN_POST="        <post> jump cell 1; </post>"
if $MENU_FADE; then
    . todisc-fade-routine
    END_TIME=$(format_seconds $THUMBS_FADE_OUT_END_TIME)
    END=" end=\"$END_TIME\""
    START=$(format_seconds $THUMBS_FADE_IN_START_TIME)
    POST="<post> jump cell 1; </post>"
fi
if $STATIC; then
    if ! $STATIC_LOOP; then
        VMGM_PAUSE_TIME="inf"
    else
        VMGM_PAUSE_TIME=$PAUSE_TIME
    fi
else
    VMGM_PAUSE_TIME=$PAUSE_TIME
fi
# pausing a faded menu gives a long a period of unselectable thumbs so we use 0
$MENU_FADE && VMGM_PAUSE_TIME=0
if [ "$PAUSE_TIME" = "inf" ]; then
    unset MAIN_POST
fi
###############################################################################
#     generate title_txt png, and template.png needed for all operations       #
###############################################################################

if [ -z "$BG_PIC" ]; then
    echo
    echo "Creating a black background"
    BG_PIC="$WORK_DIR/pics/template.png"
    $QUICK_MENU && template_colour="none" || template_colour='#'$BG_COLOUR
    convert  -resize $VIDSIZE! xc:$template_colour "$BG_PIC"
else
    convert -resize $VIDSIZE! "$BG_PIC" "$WORK_DIR/pics/template.png"
fi
if $MENU_FADE; then
    cp "$WORK_DIR/pics/template.png" "$WORK_DIR/pics/template.bk.png"
fi

if $MENU_FADE || $FEATHER; then
    convert -size $VIDSIZE xc:"#161514" "$WORK_DIR/black.jpg"
fi
DIMY=$(cut -f1 -dx <<< $THUMB_SIZE)
DIMX=$(cut -f2 -dx <<< $THUMB_SIZE)
DIMY1=$((DIMY / 20))
DIMX1=$((DIMX / 20))
DIMY2=$((DIMY - DIMY1))
DIMX2=$((DIMX - DIMY1))
DIMY3=$(($DIMY2 / 2))
DIMX3=$(($DIMX2 / 2))
DIMY4=$((DIMY / 2))
DIMX4=$((DIMX / 2))
DIMY5=$((DIMY / 3))
DIMX5=$((DIMX4 / 3))
BLUR_CMD=(convert - -blur 0x$BLUR -channel RGBA +matte miff:-)
if $THUMBS_3D && $SHOWCASE && [ "$THUMB_SHAPE" = "normal" ]; then
    MASK_DIM="0,0 $DIMY,$DIMX"
    BLUR_CMD=(convert - miff:-)
else
    MASK_DIM="$DIMY1,$DIMY1 $DIMY2,$DIMX2"
fi

if [[ -n "$THUMB_SHAPE" ]]; then
    # make a mask for the mist if called for
    convert -size $THUMB_SIZE xc:none -fill  "$THUMB_BG_COLOUR" -stroke none \
    -draw "rectangle $DIMY1,$DIMY1 $DIMY2,$DIMX2" "$WORK_DIR/feather_orig.png"
    convert "$WORK_DIR/feather_orig.png" -channel RGBA \
    -blur 0x60 "$WORK_DIR/feather_mask2.png"
fi
if [[ -z "$THUMB_TEXT_COLOUR" ]]; then
    if $FEATHER && ! $SHOWCASE &&  [ $THUMB_BG_COLOUR != none ]; then
        THUMB_TEXT_COLOUR="#161514" # dark font for misted backgrounds
    else
        THUMB_TEXT_COLOUR="#C6C6C6"
    fi
fi
if test "$THUMB_SHAPE" = "normal"; then
    THUMB_MASK="$WORK_DIR/feather_mask.png"
    yecho "Creating normal mask with the following command:"
    MASK_CMD="convert -size $THUMB_SIZE xc:black -fill white \
    -draw \"Rectangle $MASK_DIM\" \
    +matte -compose CopyOpacity miff:- | \
    convert - -bordercolor none -border 8x8 miff:- |
    ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | \
    convert -resize $THUMB_SIZE! - $THUMB_MASK"

elif test "$THUMB_SHAPE" = "oval"; then
    THUMB_MASK="$WORK_DIR/oval_mask.png"
    yecho "Creating oval mask with the following command:"
    MASK_CMD="convert -size $THUMB_SIZE xc:black -fill white \
    -draw \"RoundRectangle $DIMY1,$DIMY1 $DIMY2,$DIMX2, $DIMY3,$DIMX3\" \
    +matte -compose CopyOpacity miff:- | \
    convert - -bordercolor none -border 6x6 miff:- |
    ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | \
    convert -resize $THUMB_SIZE! - $THUMB_MASK"
    MASK_HILITE_CMD="convert -size $THUMB_SIZE xc:none \
    -draw \"RoundRectangle $DIMY1,$DIMY1 $DIMY2,$DIMX2, $DIMY3,$DIMX3\" \
    -negate  -channel A -gaussian 0x8 $WORK_DIR/oval_highlight.png"

elif test "$THUMB_SHAPE" = "egg"; then
    THUMB_MASK="$WORK_DIR/egg_mask.png"
    yecho "Creating egg-shaped mask with the following command:"
    MASK_CMD="convert -size $THUMB_SIZE xc:black -fill white \
    -draw \"circle $DIMY4,$DIMX4 $DIMY5,$DIMX5\" \
    +matte -compose CopyOpacity miff:- | \
    ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | \
    convert -resize $THUMB_SIZE! - $THUMB_MASK"

elif test "$THUMB_SHAPE" = "plectrum"; then
    THUMB_MASK="$WORK_DIR/plectrum_mask.png"
    yecho "Creating plectrum-shaped mask with the following command:"
    MASK_CMD="convert -size 200x200 xc:none -fill white \
    -draw 'circle 100,100 150,150' miff:- |
    convert -background none -wave -50x456 - miff:- |
    convert - -bordercolor none -border 3x3 -trim +repage miff:- |
    convert - -bordercolor none -border 18x18 miff:- |
    ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} |
    convert -resize $THUMB_SIZE! - $THUMB_MASK"
fi

# Print and execute the thumb-shape mask command
if $DO_MENU; then
    if [[ -n $MASK_CMD ]]; then
        yecho "$MASK_CMD"
        cmd_exec "$MASK_CMD"
    fi
    yecho "Creating a title image"
    if [[ -z "$BG_PIC" && -z "$BG_VIDEO" ]]; then
        STROKE=none
    elif [ -z "$STROKE" ]; then
        STROKE=gray
    fi

    # make a title image
    #! [[ -z ${STR// /} || -z $STR ]] && TRIM_CMD="-trim +repage -blur 0x0.4 "
    TRIM_CMD="-trim +repage -blur 0x0.4"
    TITLE_CMD=(convert  -size 620x100 xc:none -font "$MENU_FONT" -pointsize \
      $MENU_FONTSIZE -fill black -stroke black -gravity center  -annotate +0+0 \
      "$MENU_TITLE" -fill "$TITLE_COLOUR" -stroke "$STROKE" -strokewidth 1 \
      -annotate +1+1 "$MENU_TITLE")
    TITLE_CMD1=(convert - $TRIM_CMD  "$WORK_DIR/title_txt.png")

    echo "Running ${TITLE_CMD[@]} miff:- | ${TITLE_CMD1[@]}" |
      format_output|tee -a "$LOG_FILE"
    "${TITLE_CMD[@]}" miff:- | "${TITLE_CMD1[@]}" >> "$LOG_FILE" 2>&1
    # make thumb titles if $SHOWCASE
    if $SHOWCASE; then
        for ((i=0; i<=NUM_FILES; i++)); do
            unset ts_dim j
            THUMB_TITLE_CMD=(convert  -size 620x300 xc:none \
            -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE \
            -fill black -stroke black -gravity $THUMB_TITLE_ALIGN  \
            -annotate +0+0 "${TITLES[i]}" \
            -fill $THUMB_TEXT_COLOUR  -stroke "$STROKE" -strokewidth 1 \
            -annotate +1+1 "${TITLES[i]}")
            TT_CMD1=(convert - -trim +repage \
              $TEXT_BORDER "$WORK_DIR/thumb_title${i}.png")
            echo "Running ${THUMB_TITLE_CMD[@]} miff:- | ${TT_CMD1[@]}" |
              fold -bs >> "$LOG_FILE"
            "${THUMB_TITLE_CMD[@]}" miff:- | "${TT_CMD1[@]}" 2> /dev/null

            # find out dimension of the thumb title png
            TT_DIM=( ${TT_DIM[@]} $(get_image_dim \
              "$WORK_DIR/thumb_title${i}.png") )
            # get widest png in each colum for use later for alignment use
            if ((i < SPLIT)); then
                val=${TT_DIM[i]/x*}
                [ -z "$WIDEST_TITLE" ] || ((val > WIDEST_TITLE)) \
                  && WIDEST_TITLE=$val
            else
                val2=${TT_DIM[i]/x*}
                [ -z "$WIDEST_TITLE2" ] || ((val2 > WIDEST_TITLE2)) \
                  && WIDEST_TITLE2=$val2
            fi
            # get just X demension to help determine final title pos below
            tt_dim=${TT_DIM[i]/x*}
            # thumb pos + 1/2 (X dim) of thumbsize - 1/2 (X dim) of title size
            if [ "$SC_TITLE_ALIGN" = "center" ]; then
                f=$(( ${THUMB_SIZE/x*} / 2 ))
                j=$(( (f + ${SHOWCASE_THUMB_X_ARRAY[i]}) - (tt_dim / 2) ))
                k=( ${k[@]} "$j" )
                l=$((j + tt_dim))
                if [ $j -lt 48 ]; then
                    off_left=$j
                    titlesafe_error $off_left
                elif [ $l -gt 672 ]; then
                    off_right=$((720 - l))
                    titlesafe_error $off_right
                fi
            fi
        done
        if $TEXTMENU; then
            # text-rect is OK with a small space between titles for spumux
            [[ $BUTTON_STYLE = "text-rect" ]] && \
              SPACER=${SPACER:-"10"} || SPACER=${SPACER:-"15"}
            # get an array of title Y positions
            offsets1=$(for ((c=0; c<NUM_FILES; c++)); do
            ((c < (LEFT_MAX-1))) && echo $((${TT_DIM[c]#*x} + SPACER)); done)
            if [[ $NUM_FILES -ge $SPLIT ]]; then
                offsets2=$(for ((d=0; d<=NUM_FILES; d++)); do
                ((d >= LEFT_MAX)) && echo $((${TT_DIM[d]#*x} + SPACER)); done)
                [[ $offsets2 ]] && offsets2="$TEXT_YSTART $offsets2"
                tt_ygeos_col2=$(running_total <<< $offsets2)
            fi
            offsets1="$TEXT_YSTART $offsets1"
            tt_ygeos_col1=$(running_total <<< $offsets1)
            tt_ygeos="$tt_ygeos_col1 $tt_ygeos_col2"
            unset SHOWCASE_TITLES_Y_ARRAY
            SHOWCASE_TITLES_Y_ARRAY=( $tt_ygeos_col1 $tt_ygeos_col2 )
            # get the y position of the last title in 1st column (tt_ygeos_col1)
            endtitle_col1=$(wc -w <<< "$tt_ygeos_col1")
            endtitle_col1_ygeo=${SHOWCASE_TITLES_Y_ARRAY[endtitle_col1-1]/*x}
            # add y dimension of the last title size to the above y position
            SW_YCORNER=$((${TT_DIM[endtitle_col1-1]/*x} + $endtitle_col1_ygeo))
            avail_space1=$(( ( ${VIDSIZE/*x} - SAFE_AREA ) - $SW_YCORNER ))
            # if there are 2 columns, get same data for column 2
            if [[ -n $tt_ygeos_col2 ]]; then
                endtitle_col2=$NUM_FILES
                endtitle_col2_ygeo=${SHOWCASE_TITLES_Y_ARRAY[endtitle_col2]/*x}
                endtitle_col2_xgeo=${SHOWCASE_TITLES_Y_ARRAY[endtitle_col2]/x*}
                SE_YCORNER=$((${TT_DIM[endtitle_col2]/*x} + $endtitle_col2_ygeo))
                avail_space2=$(( ( ${VIDSIZE/*x} - SAFE_AREA ) - $SE_YCORNER ))
            fi
            # available space is lowest value of 2 *space* vars ( if 2 columns)
            if [[ -n $tt_ygeos_col2 ]] && ((SE_YCORNER > SW_YCORNER)); then
                avail_space=$avail_space2
            else
                avail_space=$avail_space1
            fi
            # get the height of each column for -align centre
            if [[ $BUTTON_GRAVITY = "center" \
              || $BUTTON_GRAVITY = "east" || $BUTTON_GRAVITY = "west" ]]; then
                WEST_YSPACE=$(( SW_YCORNER - TEXT_YSTART))
                EAST_YSPACE=$((SE_YCORNER - TEXT_YSTART))
                ((WEST_YSPACE > EAST_YSPACE)) && YSPACE=$WEST_YSPACE \
                  || YSPACE=$EAST_YSPACE
                CANVAS=$(( ${VIDSIZE/*x} - (SAFE_AREA * 2) ))
                NEW_TEXT_YSTART=$(( ((CANVAS - YSPACE) / 2) + SAFE_AREA ))
                TEXT_YSTART_OFFSET=$((NEW_TEXT_YSTART - TEXT_YSTART))
            fi
            # add available space to each title position for south alignment
            if [[ $BUTTON_GRAVITY = *south* ]] && ((avail_space > 0)); then
                for ((d=0; d<=NUM_FILES; d++)); do
                    SHOWCASE_TITLES_Y_ARRAY[d]=$(( $avail_space + \
                      ${SHOWCASE_TITLES_Y_ARRAY[d]} ))
                done
            elif  [[ $BUTTON_GRAVITY = "center" \
              || $BUTTON_GRAVITY = "east" || $BUTTON_GRAVITY = "west" ]]; then
                for ((d=0; d<=NUM_FILES; d++)); do
                    SHOWCASE_TITLES_Y_ARRAY[d]=$(($TEXT_YSTART_OFFSET + \
                      ${SHOWCASE_TITLES_Y_ARRAY[d]} ))
                done
            fi
                # justify titles to the right on the east side of the menu
                ((NUM_FILES >= SPLIT-1)) && WIDE_TITLE=$WIDEST_TITLE2 \
                  || WIDE_TITLE=$WIDEST_TITLE
                for ((d=0; d<=NUM_FILES; d++)); do
                    ([[ "$BUTTON_GRAVITY" = *east* ]] \
                      || [[ -n $tt_ygeos_col2 ]]) && \
                        east_offset=$(( ( ${VIDSIZE/x*} - SAFE_AREA ) - ${TT_DIM[d]/x*} ))
                    if (($NUM_FILES < SPLIT)); then
                        SHOWCASE_TITLES_X_ARRAY[d]=$SAFE_AREA
                        [[ "$BUTTON_GRAVITY" = *east* ]] && \
                          SHOWCASE_TITLES_X_ARRAY[d]=$east_offset
                    else
                        if ((d >= LEFT_MAX)); then
                            SHOWCASE_TITLES_X_ARRAY[d]=$east_offset
                        else
                            SHOWCASE_TITLES_X_ARRAY[d]=$SAFE_AREA
                        fi
                    fi
                done
            unset MAX_VAL val max_key
        fi
        # make SHOWCASE_PAGE arrayS for thumbs and THUMBTITLES_ARRAY for titles
        # use preset values unless doing centre align for titles
        for ((i=0; i<=NUM_FILES; i++)); do
            if [ "$SC_TITLE_ALIGN" != "center" ]; then
                SHOWCASE_TITLES_ARRAY[i]=+${SHOWCASE_TITLES_X_ARRAY[i]}+${SHOWCASE_TITLES_Y_ARRAY[i]}
            else
                SHOWCASE_TITLES_ARRAY[i]=+${k[i]}+${SHOWCASE_TITLES_Y_ARRAY[i]}
            fi

            SHOWCASE_THUMB_PAGES[i]="-page ${SHOWCASE_THUMB_PAGES_ARRAY[i]}"
            THUMBTITLES_ARRAY[i]="-page ${SHOWCASE_TITLES_ARRAY[i]}"
        done
    fi
fi

# make a button for playall and one for jumping to the vmgm menu, if called for
# or make a 'play' button if doing a montage slideshow menu
if { $PLAYALL && $DO_MENU ; } ||  \
 { $SLIDESHOW && [[ -z ${grouping[@]} ]] ; }; then
    if ($TITLESET_MODE && $VMGM_MENU) && ! $VMGM_ONLY; then
        $SHOWCASE && PLAYALL_BTN_yOFFSET=50 || PLAYALL_BTN_yOFFSET=80
        PLAYALL_BTN_xOFFSET=50
    else
        PLAYALL_BTN_xOFFSET=50 && PLAYALL_BTN_yOFFSET=55
    fi
    PLAYALL_BTN_OFFSETS="+$PLAYALL_BTN_xOFFSET+$PLAYALL_BTN_yOFFSET"
    mk_play_button  "#C6C6C6" black default  "$WORK_DIR/Playall.png"
    ADD_PLAYALL_BTN=("$WORK_DIR/Playall.png" -gravity SouthEast -geometry \
      "$PLAYALL_BTN_OFFSETS" -composite)
    # make the button for spumux too
    mk_play_button  "$HLIGHT_CLR" "$HLIGHT_CLR" spu \
     "$WORK_DIR/Playall_${HLIGHT_CLR/\#}.png"
    mk_play_button   "$SELECT_CLR" "$SELECT_CLR" spu \
     "$WORK_DIR/Playall_${SELECT_CLR/\#}.png"
    # coordinates for spumux
    X0=$(( ${VIDSIZE/x*} - PLAYALL_BTN_xOFFSET - play_btn_width))
    Y0=$((${VIDSIZE/*x} - PLAYALL_BTN_yOFFSET - play_btn_height))
    X1=$((X0 + play_btn_width))
    Y1=$((Y0 + play_btn_height))
    # spumux needs the coordinates to be divisible by 2
    ((X0%2 && X0--));  ((Y0%2 && Y0--))
    ((X1%2 && X1--));  ((Y1%2 && Y1--))
    if $SHOWCASE; then
        if $SLIDESHOW && [[ -z ${grouping[@]} ]]; then
            :
        else
            btn_geos[NUM_FILES+1]="x0=\"$X0\" y0=\"$Y0\" x1=\"$X1\" y1=\"$Y1\""
        fi
    fi
    if ! $SHOWCASE && \
     { $SLIDESHOW && [[ -z ${grouping[@]} ]] ; }; then
       btn_geos[0]="x0=\"$X0\" y0=\"$Y0\" x1=\"$X1\" y1=\"$Y1\""
    fi 
    
fi
if ($TITLESET_MODE && $VMGM_MENU) && ! $VMGM_ONLY; then
    RTN_BTN_yOFFSET=50; RTN_BTN_xOFFSET=50
    RTN_BTN_OFFSETS="+$RTN_BTN_xOFFSET+$RTN_BTN_yOFFSET"
    # put return button on left side for showcase, right side if not showcase
    if $SHOWCASE; then
        RTN_BTN_GRAVITY=SouthWest
        ind=$((NUM_FILES+2))
    else
        RTN_BTN_GRAVITY=SouthEast
        ind=$((NUM_FILES+1))
    fi
    mk_return_button "#C6C6C6" black default "$WORK_DIR/Main.png"
    ADD_RTN_BTN=("$WORK_DIR/Main.png" -gravity $RTN_BTN_GRAVITY \
    -geometry "$RTN_BTN_OFFSETS" -composite)
    # make the image for spumux while we at add it
    mk_return_button "$HLIGHT_CLR" "$HLIGHT_CLR" spu \
     "$WORK_DIR/Main_${HLIGHT_CLR/\#}.png"
    mk_return_button  "$SELECT_CLR" "$SELECT_CLR" spu \
     "$WORK_DIR/Main_${SELECT_CLR/\#}.png"
    # coordinates for spumux
    X0=$RTN_BTN_xOFFSET
    if ! $SHOWCASE && $SLIDESHOW && [[ -z ${grouping[@]} ]]; then
        X0=$((${VIDSIZE/x*} - $RTN_BTN_xOFFSET - rtn_btn_width))
    fi
    Y0=$((${VIDSIZE/*x} - RTN_BTN_yOFFSET - rtn_btn_height))
    X1=$((X0 + rtn_btn_width))
    Y1=$((Y0 + rtn_btn_height))
    # spumux needs the coordinates to be divisible by 2
    ((X0%2 && X0--)); ((Y0%2 && Y0--))
    ((X1%2 && X1++)); ((Y1%2 && Y1++))
    # single slideshow has hidden button - no spumux geometries needed
    if $SHOWCASE; then
        if $SLIDESHOW && [[ -z ${grouping[@]} ]]; then
            :
        else # else pass on button geometries for making spumux xml
            btn_geos[ind]="x0=\"$X0\" y0=\"$Y0\" x1=\"$X1\" y1=\"$Y1\""
        fi
    fi
    if ! $SHOWCASE && \
     { $SLIDESHOW && [[ -z ${grouping[@]} ]] ; }; then
       $TITLESET_MODE && $VMGM_MENU && \
       btn_geos[1]="x0=\"$X0\" y0=\"$Y0\" x1=\"$X1\" y1=\"$Y1\""
    fi 
fi

if [[ -n $MENU_TITLE ]] && $DO_MENU; then
    TITLE_TEXT_DIM=$(get_image_dim "$WORK_DIR/title_txt.png")
    TITLE_TEXT_XDIM=${TITLE_TEXT_DIM/x*}
    TITLE_TEXT_YDIM=${TITLE_TEXT_DIM/*x}
fi
if $MIST; then
    echo
    echo "Making a white or colored png for the misted title background"
    echo
    # make a white/coloured png for misted background effect, only for user bg
    # add 10 pixels to width and height compared to title text png
    y=$((TITLE_TEXT_YDIM + 40))
    x=$((TITLE_TEXT_XDIM + 40))
    newX=$((TITLE_TEXT_XDIM + 30))
    newY=$((TITLE_TEXT_YDIM + 30))
    DIM=${x}x${y}
    convert -size $DIM xc:none -fill $MIST_COLOUR -stroke none \
    -draw "rectangle 10,10 $newX,$newY" "$WORK_DIR/white_orig.png"
    convert $WORK_DIR/white_orig.png -channel RGBA -blur 0x4 \
      "$WORK_DIR/white.png"
    unset X Y x y
fi
# offsets for placing title and mist for Y dimension
# place menu title lower if not text mist and -title-geo is not supplied
if $MIST; then
    if [[ $TITLE_GRAVITY = *south* || $TITLE_GRAVITY = *north* ]]; then
        title_yoffset=${title_yoffset:-"+65"}
        mist_yoffset="$(( ${title_yoffset#*[-+]} - 20))"
    else
        title_yoffset=${title_yoffset:-"+0"}
        mist_yoffset="$(( ${title_yoffset#*[-+]} - 0))"
    fi
else
    title_yoffset=${title_yoffset:-"+50"}
fi
[[ ${mist_yoffset:0:1} != [+-] ]] && mist_yoffset=+${mist_yoffset}
# offsets placing title and mist for X dimension
if $MIST; then
    mist_dim=$(get_image_dim "$WORK_DIR/white.png" )
    mist_xdim=${mist_dim/x*}
    mist_xdim_offset=$(( (mist_xdim - TITLE_TEXT_XDIM) / 2 ))
    if [[ $TITLE_GRAVITY = *st* ]]; then
        title_xoffset=${title_xoffset:-"+50"}
        mist_xoffset="$(bc_math "${title_xoffset#*[-+]} \
          - $mist_xdim_offset" int)"
        [[ ${mist_xoffset:0:1} != [+-] ]] && mist_xoffset=+${mist_xoffset}
    else
        title_xoffset=${title_xoffset:-"+0"}
        mist_xoffset=$title_xoffset
    fi
else
        title_xoffset=${title_xoffset:-"+0"}
fi
###############################################################################
#      generate a basic preview of the main menu                              #
###############################################################################
# generate images for montage and title and resize them
if [[ -n "$BG_VIDEO" ]] && ! $QUICKMENU_IS_BACKGROUND; then
    echo "Getting background video images from $BG_VIDEO"
    FFMPEG_CMD=(ffmpeg -i "$BG_VIDEO" -s $VIDSIZE -ss $BG_SEEK -vframes 1 \
    -vcodec png -an  -f rawvideo -y "$WORK_DIR/pics/template.png")
    echo -e "\nRunning: "${FFMPEG_CMD[@]}"\n" | fold -bs >> "$LOG_FILE"
    SED_VAR="frame="
    if ! "${FFMPEG_CMD[@]}" 2>&1 |strings  >> "$LOG_FILE";then
        runtime_error "Problem creating images from the video."
    fi
fi
if $SHOWCASE && ($SC_THUMB || $QUICK_MENU); then
    if [[ $SC_TITLE_ALIGN = "east" ]] && ! $TEXTMENU; then
        TS="+ ${THUMB_SIZE/x*}"
    else
        TS=0
    fi
    if (( (WIDEST_TITLE + SAFE_AREA + TS + \
      ${SHOWCASE_SIZE/x*}) > ( ${VIDSIZE/x*} - SAFE_AREA) )); then
            SHOWCASE_SIZE=288x216
            [[ $TARGET = "svcd" ]] && SHOWCASE_SIZE=216x216
    fi
    if $TEXTMENU && [[ -n $tt_ygeos_col2 ]]; then
        SHOWCASE_SIZE=288x216
        [[ $TARGET = "svcd" ]] && SHOWCASE_SIZE=216x216
    fi

    if [[ -n "$SHOWCASE_VIDEO" ]]; then
        echo "Getting video images from $SHOWCASE_VIDEO"
        if [[ "$SC_FRAMESTYLE" = "glass" ]]; then
            # some vars for get_framed_pics()
            D=2
            OUTDIR="$WORK_DIR/showcase"
            OUT="$WORK_DIR/showcase_img.png"
            VOUT="png:z=7"; FRAMES=30
            FRAME_SIZE=$SHOWCASE_SIZE
            MPLAYER_SEEK_VAL=$SHOWCASE_SEEK_VAL
            $SWITCHED && MPLAYER_SEEK_VAL=${SEEK_VAL[MENU_NUM-1]}
            echo "Using mplayer to get framed images from the showcase video"
            yecho
            echo "Running: mplayer -ss $MPLAYER_SEEK_VAL -vo $VOUT \
            -vf expand=-5:-5,rectangle=384:256,rectangle=382:254,rectangle=380:252,rectangle=378:250 \
            -ao null -zoom -x 384 -y 256  -ss 0:0:05 -frames $FRAMES \
            "$SHOWCASE_VIDEO"" | format_output | tee -a "$LOG_FILE"
            yecho
            get_framed_pics "$SHOWCASE_VIDEO" >> "$LOG_FILE" 2>&1

            largest_png=$(du -s "$WORK_DIR"/000000*.png|sort -r |
                                awk 'NR>1{exit};1 {print $2}')
            mv -v "$largest_png" "$OUT"
            rm -f "$WORK_DIR"/00000*.png
            convert "$WORK_DIR/showcase_img.png" \
            -background none $ROTATE $WAVE miff:-|
            convert - -resize $SHOWCASE_SIZE! "$WORK_DIR/showcase_img.png"
        elif [ "$SC_FRAMESTYLE" = "none" ]; then
            if $SWITCHED; then
                FFMPEG_SEEK_VAL=${SEEK_VAL[MENU_NUM-1]}
            else
                FFMPEG_SEEK_VAL=$SHOWCASE_SEEK_VAL
            fi
            
            FFMPEG_CMD=(ffmpeg -i "$SHOWCASE_VIDEO" -ss $FFMPEG_SEEK_VAL \
            -s $SHOWCASE_SIZE  -vframes 1 -vcodec png -an -f rawvideo -y \
            "$WORK_DIR/showcase_img.png")
            echo -e "\nRunning: "${FFMPEG_CMD[@]}"\n" | fold -bs \
              |tee -a "$LOG_FILE"
            SED_VAR="frame="
            if ! "${FFMPEG_CMD[@]}" 2>&1 | strings >> "$LOG_FILE";then
                runtime_error "Problem creating images from the video."
            fi

            echo "Running convert "$WORK_DIR/showcase_img.png" -mattecolor gray"
            echo "$SC_FRAME "$WORK_DIR/showcase_img.png"" |format_output
            convert "$WORK_DIR/showcase_img.png" $SC_FRAME miff:- |
            convert -background none $ROTATE $WAVE - miff:-|
            convert - -resize $SHOWCASE_SIZE! "$WORK_DIR/showcase_img.png"
        fi
    elif [[ -n "$SHOWCASE_IMG" ]]; then
        echo "Running convert -resize $SHOWCASE_SIZE! "$SHOWCASE_IMG" miff:- | \
        convert -background none $ROTATE $WAVE -bordercolor Transparent \
        -border 8x8 - miff:- | convert - -trim +repage -resize \
        $SHOWCASE_SIZE! "$WORK_DIR/showcase_img.png"" |format_output
        convert "$SHOWCASE_IMG" -resize $SHOWCASE_SIZE!  $SC_FRAME miff:- |
        convert - -background none -bordercolor Transparent -border 8x8 \
        $ROTATE $WAVE miff:- | convert - -trim +repage \
        -resize $SHOWCASE_SIZE! "$WORK_DIR/showcase_img.png"
    fi
fi
# transcode makes it harder to switch between PNG and JPEG for output
if [ $IMG_FMT = "jpg" ]; then
    EXPORT="-y jpg,null"
elif [ $IMG_FMT = "png" ]; then
    EXPORT="-y im -F png"
fi

# create the preview images
if ! $TEXTMENU && $DO_MENU; then
    $SLIDESHOW && echo -e "\nCreating preview images from the slides"
    for ((i=0; i<=NUM_FILES; i++)) ; do
        # don't make titles if all input files are images
        # pass -f image2 to ffmpeg if its an image (not always needed but ...)
        [[ ${file_is_image[i]} = "yes" ]] && fmt="-f image2" || fmt=""
#        if $SLIDESHOW; then
#            :
#        else
#            echo
            spin "[$((i + 1)) of ${#FILES[@]}] Seeking to ${SEEK_VAL[i]} seconds in "${IN_FILES[i]##*/}""
#        fi

        FFMPEG_CMD=(ffmpeg $fmt -i "${IN_FILES[i]}" -an -ss ${SEEK_VAL[i]} -vframes 1 \
        -s $THUMB_SIZE $WORK_DIR/pics/$i/%06d.$IMG_FMT)
        CMD=( "${FFMPEG_CMD[@]}" )
        SED_VAR="frame="
        ! [[ "$SC_FRAMESTYLE" = "glass" ]] && echo -e "\nRunning: "${CMD[@]}"\n" | fold -bs >> "$LOG_FILE"
        # some vars for get_framed_pics()
        VOUT="png:z=7"; FRAMES=30
        FRAME_SIZE=$THUMB_SIZE
        D=2

        if [ "$SC_FRAMESTYLE" = "glass" ]; then
            MPLAYER_SEEK_VAL=${SEEK_VAL[i]}
            get_framed_pics "${IN_FILES[i]}"  >> "$LOG_FILE" 2>&1
            largest_png=$(du -s $WORK_DIR/000*.png | sort -r |
                                        awk 'NR>1{exit};1 {print $2}')
            mv -fv $largest_png $WORK_DIR/pics/$i/$(printf "%06d%s"  0 .$IMG_FMT)
            rm -f "$WORK_DIR"/00000*.png
        elif [ "$SC_FRAMESTYLE" = "none" ]; then
            if ! "${FFMPEG_CMD[@]}" 2>&1 |strings >> "$LOG_FILE";then
                runtime_error "Problem creating images from the video."
            fi
        fi

        wait
        unset NAVSEEK_CMD rectangle run_transcode FFMPEG_CMD TRANSCODE_CMD
    done
    echo
fi
# overlay menu title and thumb titles on template
if $MIST; then
    # overlay white.png onto background
    echo "Running:
    composite -dissolve $MIST_OPACITY -gravity $TITLE_GRAVITY \
    -geometry ${mist_xoffset}${mist_yoffset} "$WORK_DIR/white.png" \
    "$WORK_DIR/pics/template.png" "$WORK_DIR/pics/template.png"" |format_output
    composite -dissolve $MIST_OPACITY -gravity $TITLE_GRAVITY \
      -geometry ${mist_xoffset}${mist_yoffset} \
      "$WORK_DIR/white.png" "$WORK_DIR/pics/template.png" \
      "$WORK_DIR/pics/template.png"
fi
if $SHOWCASE && $DO_MENU; then
    for ((i=0; i<=NUM_FILES; i++)); do
        sc_thumb_title_cmd=( "${sc_thumb_title_cmd[@]}" "${THUMBTITLES_ARRAY[i]}"  \
        "$WORK_DIR/thumb_title${i}.png")
    done
    echo "Running:
    convert  -size $VIDSIZE -background none "$WORK_DIR/pics/template.png"
    ${sc_thumb_title_cmd[@]} -page +210+400 "$WORK_DIR/title_txt.png" \
    -mosaic "$WORK_DIR/pics/template.png" "| format_output
    convert -size $VIDSIZE -background none "$WORK_DIR/pics/template.png" \
    ${sc_thumb_title_cmd[@]} -mosaic "$WORK_DIR/pics/template.png"
    convert "$WORK_DIR/pics/template.png" "$WORK_DIR/title_txt.png" \
    -gravity $TITLE_GRAVITY -geometry ${title_xoffset}${title_yoffset} \
    -composite -background none "$WORK_DIR/pics/template.png"
    
fi
if $PLAYALL || ($TITLESET_MODE && $VMGM_MENU) ; then
    if ! $VMGM_ONLY; then
        convert "$WORK_DIR/pics/template.png" -background none "${ADD_PLAYALL_BTN[@]}" \
        "${ADD_RTN_BTN[@]}" "$WORK_DIR/pics/template.png"
        convert "$WORK_DIR/pics/template.png" "$WORK_DIR/pics/template.jpg"
    fi
fi

# copy the preview for -quick-menu
if $QUICK_MENU && [[ -s "$WORK_DIR/showcase_img.png" ]]; then
    cp -v "$WORK_DIR/pics/template.png" "$WORK_DIR/quick_menu_bg.png"
fi

# lets be sure of order by using a loop
for ((i=0; i<=NUM_FILES; i++)); do
    PICS=( "${PICS[@]}" \
    $(find $WORK_DIR/pics/$i/  -maxdepth 1 -name 000\*.$IMG_FMT) )
done
if ! $TEXTMENU && $DO_MENU && $DO_BUTTONS; then
    for ((i=0; i<${#PICS[@]}; i++)); do
        [[ -n ${ROTATE_ARRAY[@]} ]] && THUMB_ROTATE="-background none -rotate ${ROTATE_ARRAY[i]}"
        if $THUMBS_3D && [ "$THUMB_SHAPE" != "normal" ]; then
        CURVE_VARS="5 3 5 1 1"
        . todisc-fade-routine
        fi
        PVIEW_CMD=(composite -compose CopyOpacity $THUMB_MASK +matte \
        "${PICS[i]}")
        PVIEW_CMD0=(convert "${PICS[i]}" $RAISE)
        PVIEW_CMD1=(convert - $RAISE)
        PVIEW_CMD2=(convert - -write mpr:${i}img -fx A  +matte \
        -blur 0x$( LC_ALL="C" bash -c "printf  "%.2f" $(bc_math "6.9 + .${CURVE_ARRAY[i]/.}")" ) \
        -shade $(bc_math "115 + ${CURVE_ARRAY[i]}" int)x30 -normalize mpr:${i}img -compose \
        Overlay -composite mpr:${i}img  -matte  -compose Dst_In -composite)
        PVIEW_CMD3=(convert -trim +repage - "${PICS[i]}")
        if $FEATHER; then
            if $THUMBS_3D; then
                if $SHOWCASE; then
                    if [ "$THUMB_SHAPE" != "normal" ]; then
                        "${PVIEW_CMD[@]}" miff:- |
                        "${PVIEW_CMD2[@]}" miff:- |
                        "${PVIEW_CMD3[@]}"
                    else # normal thumb shape
                        "${PVIEW_CMD0[@]}" miff:- | "${PVIEW_CMD1[@]}" miff:- |
                        "${PVIEW_CMD3[@]}"
                    fi
                else  # not $SHOWCASE
                    if [ "$THUMB_SHAPE" != "normal" ]; then
                        "${PVIEW_CMD[@]}" miff:- |
                        "${PVIEW_CMD2[@]}" "${PICS[i]}"
                    else # normal thumb shape
                        echo "Running
                        "${PVIEW_CMD0[@]}" miff:- | "${PVIEW_CMD3[@]}"
                        "|format_output
                        "${PVIEW_CMD0[@]}" miff:- | "${PVIEW_CMD3[@]}"
                    fi
                fi
            else # not 3D
                "${PVIEW_CMD[@]}" miff:- | "${PVIEW_CMD3[@]}"
            fi
        else # not FEATHER
            "${PVIEW_CMD0[@]}" miff:- | "${PVIEW_CMD3[@]}"
        fi

        IM_CMD=(convert -background none $THUMB_FRAME -bordercolor "#444744" $RAISE "${PICS[i]}")
        IM_CMD0=(composite -gravity center -compose DstOver "$WORK_DIR/feather_mask2.png" "${PICS[i]}")
        IM_CMD1=(montage "${PICS[i]}" -geometry +4+4 -compose Copy  \
        -background  none -fill "$THUMB_TEXT_COLOUR" -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE \
        -title "${TITLES[i]}")
        IM_CMD2=(convert -resize $THUMB_SIZE! -)
        IM_CMD3=(composite -gravity center -compose DstOver "$WORK_DIR/feather_mask2.png" - )
        IM_CMD4=(convert -background none -frame 3x3 \
        -bordercolor "#444744" -)
        IM_CMD5=(convert - $THUMB_ROTATE -resize $THUMB_SIZE! "${PICS[i]}")
        if $FEATHER; then
            if $SHOWCASE; then
                "${IM_CMD0[@]}" miff:- | "${IM_CMD5[@]}"
            else  # feather, but not showcase
                "${IM_CMD1[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
                "${IM_CMD3[@]}" miff:- | "${IM_CMD5[@]}"
            fi
        else  # not feather
            if $SHOWCASE; then
                "${IM_CMD[@]}" miff:- | "${IM_CMD5[@]}"
            else # not feather and not showcase
                "${IM_CMD1[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
                "${IM_CMD4[@]}" miff:- | "${IM_CMD5[@]}"
            fi
        fi
    done
fi

##############################################################################
#                 create button layer for spumux                             #
##############################################################################
if $DO_BUTTONS && [[ $TARGET = "dvd" ]]; then
    echo
    echo "Creating the highlight and selection PNGs for the main menu"
    if [ "$BUTTON_STYLE" = "rect" ]; then
        MENU_BUTTON_SIZE=$THUMB_SIZE
        get_button_geo
    (
    cat  <<EOF
rectangle 2,2 $GEO
EOF
)  > "$WORK_DIR/draw_file"
    fi
    if [ $BUTTON_STYLE = "text-rect" ]; then
        for ((i=0; i<=NUM_FILES; i++)); do
            MENU_BUTTON_SIZE=${TT_DIM[i]}
            get_button_geo
    (
    cat <<EOF
rectangle 1,1 $GEO
EOF
    )  > "$WORK_DIR/draw_file${i}"
        done
    fi

    PNG_IS_DONE=false
    for ((t=0; t<${#TITLES[@]}; t++)); do
        unset BUTTON_CMD6b BUTTON_CMD7b
        if $FEATHER; then FRAME=0; else FRAME=3x3;fi
        [[ -n ${ROTATE_ARRAY[@]} ]] && \
         THUMB_ROTATE="-background none -rotate ${ROTATE_ARRAY[t]}"
        BUTTON_SIZE=$THUMB_SIZE
        BUTTON_CMD=(montage -size $THUMB_SIZE xc:none -geometry +4+4 \
        -background none -mattecolor none -bordercolor none -stroke none \
        -fill "$SELECT_CLR" -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE \
        -title "${TITLES[t]}" -compose CopyOpacity)
        BUTTON_CMD1=(montage -size $THUMB_SIZE xc:none -geometry +4+4 \
        -background none -mattecolor none -bordercolor none -stroke none \
        -fill "$HLIGHT_CLR" -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE \
        -title "${TITLES[t]}" -compose CopyOpacity)
        BUTTON_CMD2=(convert -mattecolor none -background none \
        -bordercolor none -frame 3x3 -)
        BUTTON_CMD3=(convert - $THUMB_ROTATE -resize ${THUMB_SIZE}! +antialias)
        BUTTON_CMD4=(convert -size "${THUMB_SIZE}+5+5"  xc:none -fill none \
        +antialias -stroke "$SELECT_CLR" -strokewidth 4 -draw @draw_file \
        -colors 3 $THUMB_ROTATE -resize ${THUMB_SIZE}! "$WORK_DIR/Selectx1.png")
        BUTTON_CMD5=(convert -size "${THUMB_SIZE}+5+5" xc:none -fill none \
        +antialias -stroke "$HLIGHT_CLR" -strokewidth 4 -draw @draw_file \
        -colors 3 $THUMB_ROTATE -resize ${THUMB_SIZE}! "$WORK_DIR/Highlightx1.png")
        BUTTON_CMD6=(convert -size ${THUMB_SIZE}+5+5 xc:none +antialias -fill none \
        -stroke "$SELECT_CLR" -strokewidth 4 -draw @draw_file "$WORK_DIR/Selectx1.png")
        BUTTON_CMD6b=(convert -size ${TT_DIM[t]} xc:none +antialias -fill none \
        -stroke "$SELECT_CLR" -strokewidth 2 -draw @draw_file${t} \
        "$WORK_DIR/$(printf %06d%s%s ${t} -select .png)")
        BUTTON_CMD7=(convert -size ${THUMB_SIZE}+5+5 xc:none +antialias \
        -fill none -stroke "$HLIGHT_CLR" -strokewidth 4 -draw @draw_file \
        "$WORK_DIR/Highlightx1.png")
        BUTTON_CMD7b=(convert -size ${TT_DIM[t]} xc:none +antialias -fill none \
        -stroke "$HLIGHT_CLR" -strokewidth 2 -draw @draw_file${t} \
        "$WORK_DIR/$(printf %06d%s%s ${t} -highlight .png)")

        if [ "$BUTTON_STYLE" = "text" ]; then
            if $FEATHER; then
                "${BUTTON_CMD[@]}" miff:- | "${BUTTON_CMD3[@]}" \
                "$WORK_DIR/$(printf %06d%s%s ${t} -select .png)"
                "${BUTTON_CMD1[@]}" miff:- | "${BUTTON_CMD3[@]}" \
                "$WORK_DIR/$(printf %06d%s%s ${t} -highlight .png)"
            else
                "${BUTTON_CMD[@]}" miff:- | "${BUTTON_CMD2[@]}" miff:- |
                "${BUTTON_CMD3[@]}" \
                "$WORK_DIR/$(printf %06d%s%s ${t} -select .png)"
                "${BUTTON_CMD1[@]}" miff:- | "${BUTTON_CMD2[@]}" miff:- |
                "${BUTTON_CMD3[@]}" \
                "$WORK_DIR/$(printf %06d%s%s ${t} -highlight .png)"
            fi
        elif [ $BUTTON_STYLE = "rect" ]; then
            if  ! $PNG_IS_DONE; then
                if $SHOWCASE; then
                    "${BUTTON_CMD6[@]}"
                    "${BUTTON_CMD7[@]}"
                else
                    "${BUTTON_CMD4[@]}" 2> /dev/null
                    "${BUTTON_CMD5[@]}" 2> /dev/null
                fi
            fi
        elif [ $BUTTON_STYLE = "text-rect" ]; then
            "${BUTTON_CMD6b[@]}"
            "${BUTTON_CMD7b[@]}"
        fi
        # do not loop over creating same png
        [[ -z ${ROTATE_ARRAY[@]} ]] && PNG_IS_DONE=:
    done
    if [ "$BUTTON_STYLE" = "rect" ]; then
        BUTTON_DIM=$(get_image_dim "$WORK_DIR/Highlightx1.png")
        for button in Select Highlight; do
            if $SHOWCASE; then
                unset sc_spumux_cmd fake_montage_cmd
                convert -size $BUTTON_DIM xc:none -background none \
                $WORK_DIR/empty-button.png
                fake_montage=( $WORK_DIR/Highlightx1.png \
                $(for ((i=0; i<NUM_FILES-1; i++)); do \
                echo $WORK_DIR/empty-button.png; done))
                for ((i=0; i<=NUM_FILES; i++)); do
                    fake_montage_cmd=( ${fake_montage_cmd[@]} \
                    ${SHOWCASE_THUMB_PAGES[i]} "${fake_montage[i]}")
                    sc_spumux_cmd=( ${sc_spumux_cmd[@]} \
                    ${SHOWCASE_THUMB_PAGES[i]} "$WORK_DIR/${button}x1.png" )
                done
                convert  -size $VIDSIZE xc:none -background none \
                ${fake_montage_cmd[@]} -mosaic "$WORK_DIR/fake_montage.png"
                convert  -size $VIDSIZE xc:none -background none \
                ${sc_spumux_cmd[@]} -mosaic "$WORK_DIR/${button}.png"
            else
                montage -background none \
                $(for ((i=0; i<=NUM_FILES; i++)); do echo $WORK_DIR/${button}x1.png;done) \
                -tile ${TILE_ARRAY[NUM_FILES]} -geometry ${THUMB_SIZE}${MTG_GEO} \
                -bordercolor none -mattecolor transparent miff:- |
                convert  -colors 3 -size $VIDSIZE xc:none - -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} \
                -composite  "$WORK_DIR/${button}.png"
                convert -size $BUTTON_DIM xc:none -background none $WORK_DIR/empty-button.png
                fake_montage=( $WORK_DIR/Highlightx1.png $(for ((i=0; i<NUM_FILES-1; i++)); do
                echo $WORK_DIR/empty-button.png; done))
                montage -background none ${fake_montage[@]} \
                -tile ${TILE_ARRAY[NUM_FILES]} -geometry ${THUMB_SIZE}${MTG_GEO} \
                -bordercolor none -mattecolor transparent miff:- |
                convert  -size $VIDSIZE xc:none - -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} \
                -composite "$WORK_DIR/fake_montage.png"
            fi
        done
    elif [[ "$BUTTON_STYLE" = *text* ]]; then
        if $SHOWCASE && [[ $BUTTON_STYLE = "text-rect" ]]; then
            select_buttons=( ${select_buttons[@]} \
            $(find $WORK_DIR/ -name 00\*select.png |sort) )
            highlight_buttons=( ${highlight_buttons[@]} \
            $(find $WORK_DIR/ -name 00\*highlight.png |sort) )
            for ((i=0; i<=NUM_FILES; i++)); do
                sc_select_cmd=(${sc_select_cmd[@]} ${THUMBTITLES_ARRAY[i]} "${select_buttons[i]}")
                sc_highlight_cmd=(${sc_highlight_cmd[@]} ${THUMBTITLES_ARRAY[i]} "${highlight_buttons[i]}")
            done
            convert -colors 3 -size $VIDSIZE xc:none -background none \
            ${sc_highlight_cmd[@]} -mosaic "$WORK_DIR/Highlight.png"
            convert  -colors 3 -size $VIDSIZE xc:none -background none \
            ${sc_select_cmd[@]} -mosaic "$WORK_DIR/Select.png"
        else
            select_buttons=( ${select_buttons[@]} \
            $(find $WORK_DIR/ -name 00\*select.png |sort) )
            highlight_buttons=( ${highlight_buttons[@]} \
            $(find $WORK_DIR/ -name 00\*highlight.png |sort) )
            montage -background none ${select_buttons[@]} \
            -tile ${TILE_ARRAY[NUM_FILES]} -geometry ${THUMB_SIZE}${MTG_GEO} \
            -bordercolor none -mattecolor transparent miff:- |
            convert  -size $VIDSIZE xc:none - -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} \
            -composite "$WORK_DIR/Select.png"
            montage -background none ${highlight_buttons[@]} \
            -tile ${TILE_ARRAY[NUM_FILES]} -geometry ${THUMB_SIZE}${MTG_GEO} \
            -bordercolor none -mattecolor transparent miff:- |
            convert  -size $VIDSIZE xc:none - -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} \
            -composite "$WORK_DIR/Highlight.png"
            BUTTON_DIM=$(get_image_dim "$WORK_DIR/000000-highlight.png")
            convert -size $BUTTON_DIM xc:none -background none $WORK_DIR/empty-button.png
            fake_montage=( $WORK_DIR/000000-highlight.png $(for ((i=0; i<NUM_FILES-1; i++)); do
            echo $WORK_DIR/empty-button.png; done))
        fi
        if $SHOWCASE; then
            if [[ $BUTTON_STYLE = "text-rect" ]]; then
                convert  -size $VIDSIZE xc:none -background none \
                ${THUMBTITLES_ARRAY[MENU_NUM-1]} \
                $WORK_DIR/$(printf "%06d%s" $((MENU_NUM-1)) -highlight.png) \
                -mosaic "$WORK_DIR/fake_montage.png"
            fi
        else
            montage -background none ${fake_montage[@]} \
            -tile ${TILE_ARRAY[NUM_FILES]} -geometry ${THUMB_SIZE}${MTG_GEO} \
            -bordercolor none -mattecolor transparent miff:- |
            convert  -size $VIDSIZE xc:none - -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} \
            -composite "$WORK_DIR/fake_montage.png"
        fi
    elif $SHOWCASE && [[ "$BUTTON_STYLE" = "line" ]]; then
        for i in ${!TITLES[@]}; do
            XPT1=$( cut -f2 -d+ <<< ${THUMBTITLES_ARRAY[i]} )
            XPT2=$(( XPT1 + ${TT_DIM[i]%%x*} ))
            YPT=$( cut -f3 -d+ <<< ${THUMBTITLES_ARRAY[i]} )
            YPT=$(( YPT + ${TT_DIM[i]##*x} ))
            # Y0,X0,Y0,Y1 is for later, for spumux button geometries
            Y0=$YPT
            X0=$XPT1
            X1=$XPT2
            # for line button just add 2 to Y geo
            Y1=$((Y0+2))
            # make sure coordinates are even
            ((X0%2 && X0--)); ((Y0%2 && Y0--))
            ((X1%2 && X1++)); ((Y1%2 && Y1++))
            btn_geos[i]="x0=\"$X0\" y0=\"$Y0\" x1=\"$X1\" y1=\"$Y1\"" #FIXME
            echo  "line ${XPT1},${YPT} ${XPT2},${YPT}" >> "$WORK_DIR/spumux_drawfile"
            [[ $i -eq $((MENU_NUM-1)) ]] && echo \
            "line ${XPT1},${YPT} ${XPT2},${YPT}" >> "$WORK_DIR/fake_montage.mvg"
        done
            convert -size $VIDSIZE xc:none -fill none -stroke $SELECT_CLR \
            -strokewidth 2 -draw @spumux_drawfile "$WORK_DIR/Select.png"
            convert -size $VIDSIZE xc:none -fill none -stroke $HLIGHT_CLR \
            -strokewidth 2 -draw @spumux_drawfile "$WORK_DIR/Highlight.png"
            convert  -size $VIDSIZE xc:none -fill none -stroke $HLIGHT_CLR \
            -strokewidth 2 -draw @fake_montage.mvg "$WORK_DIR/fake_montage.png"
    fi
    if $TITLESET_MODE && ! $VMGM_ONLY && $VMGM_MENU; then
        convert -gravity $RTN_BTN_GRAVITY -geometry "$RTN_BTN_OFFSETS" \
        "$WORK_DIR/Select.png" "$WORK_DIR/Main_${SELECT_CLR/\#}.png" \
        -composite "$WORK_DIR/Select.png"
        convert -gravity $RTN_BTN_GRAVITY -geometry "$RTN_BTN_OFFSETS" \
        "$WORK_DIR/Highlight.png" "$WORK_DIR/Main_${HLIGHT_CLR/\#}.png" \
         -composite "$WORK_DIR/Highlight.png"
    fi
    if $PLAYALL && ! $VMGM_ONLY; then
        convert -gravity SouthEast -geometry "$PLAYALL_BTN_OFFSETS" \
        "$WORK_DIR/Select.png" "$WORK_DIR/Playall_${SELECT_CLR/\#}.png" \
        -composite "$WORK_DIR/Select.png"
        convert -gravity SouthEast -geometry "$PLAYALL_BTN_OFFSETS" \
        "$WORK_DIR/Highlight.png" "$WORK_DIR/Playall_${HLIGHT_CLR/\#}.png" \
        -composite "$WORK_DIR/Highlight.png"
    fi

fi
# for dvd slideshow we need just a Select.png unless grouping or MONTAGE_MENU
if $SLIDESHOW && [[ ${#GROUP[@]} -le 1 && $TARGET = "dvd" ]]; then
    if $TITLESET_MODE && ! $VMGM_ONLY && $VMGM_MENU; then
        convert -size $VIDSIZE xc:none -fill none  \
        "$WORK_DIR/Main_${SELECT_CLR/\#}.png" -gravity $RTN_BTN_GRAVITY \
        -geometry "$RTN_BTN_OFFSETS" -composite "$WORK_DIR/Select.png"
        convert -size $VIDSIZE xc:none -fill none \
        "$WORK_DIR/Main_${HLIGHT_CLR/\#}.png" -gravity $RTN_BTN_GRAVITY \
        -geometry "$RTN_BTN_OFFSETS" -composite "$WORK_DIR/Highlight.png"
        
        convert -gravity SouthEast -geometry "$PLAYALL_BTN_OFFSETS" \
        "$WORK_DIR/Select.png"  "$WORK_DIR/Playall_${SELECT_CLR/\#}.png" \
        -composite "$WORK_DIR/Select.png"

        convert -gravity SouthEast -geometry "$PLAYALL_BTN_OFFSETS" \
        "$WORK_DIR/Highlight.png" "$WORK_DIR/Playall_${HLIGHT_CLR/\#}.png" \
        -composite "$WORK_DIR/Highlight.png"
    else
        convert -size $VIDSIZE xc:none -fill none  \
        "$WORK_DIR/Playall_${SELECT_CLR/\#}.png" -gravity SouthEast \
        -geometry "$PLAYALL_BTN_OFFSETS" -composite "$WORK_DIR/Select.png"
        convert -size $VIDSIZE xc:none -fill none  \
        "$WORK_DIR/Playall_${HLIGHT_CLR/\#}.png" -gravity SouthEast \
        -geometry "$PLAYALL_BTN_OFFSETS" -composite "$WORK_DIR/Highlight.png"

#        convert -size $VIDSIZE xc:none -fill blue -pointsize 20 \
#        -gravity southeast -annotate +50+50 "Loading" "$WORK_DIR/Select.png"
#        convert -size $VIDSIZE xc:none -fill none -pointsize 20 \
#        -gravity southeast -annotate +50+50 "Loading" "$WORK_DIR/Highlight.png"
    fi
    OUTLINEWIDTH="\"14\"" # needed for text button
fi
if [[ $TARGET = "dvd" ]]; then
    # this reduces colours so spumux is happy
    for button in Select Highlight; do
        mogrify -channel A -threshold 99% "$WORK_DIR/${button}.png"
    done
fi
if $SHOWCASE && $DO_MENU; then # silly, but someone might try it
    if $SC_THUMB; then
        # find out where to put the showcase image/video in the X axis
        sc_size=$(get_image_dim "$WORK_DIR/showcase_img.png")
        sc_width=${sc_size/x*}
        sc_height=${sc_size/*x}
    fi
    $QUICK_MENU && sc_width=${SHOWCASE_SIZE/x*} && sc_height=${SHOWCASE_SIZE/*x}
    if $SC_THUMB || $QUICK_MENU; then #&& ! $TEXTMENU; then
        if [[ "$SC_TITLE_ALIGN" = "center" ]]; then
            if [[ $WIDEST_TITLE -ge ${THUMB_SIZE/x*} ]]; then
                BUTTON_COLUMN1=$(( (${THUMB_SIZE/x*} / 2) + (WIDEST_TITLE / 2) ))
            else
                BUTTON_COLUMN1=${THUMB_SIZE/x*}
            fi
        elif [[ "$SC_TITLE_ALIGN" = "west" ]]; then
            if [[ $WIDEST_TITLE -ge ${THUMB_SIZE/x*} ]]; then
                BUTTON_COLUMN1=$((WIDEST_TITLE + 5))
            else
                BUTTON_COLUMN1=${THUMB_SIZE/x*}
            fi
        elif [[ "$SC_TITLE_ALIGN" = "east" ]]; then
            BUTTON_COLUMN1=$(( ${THUMB_SIZE/x*} + WIDEST_TITLE ))
        fi
        if ! $TEXTMENU; then
        sc_space=$((${VIDSIZE%x*} - \
            ${SHOWCASE_THUMB_X_ARRAY[0]} - BUTTON_COLUMN1 - SAFE_AREA))
        SC_X=$(( ${SHOWCASE_THUMB_X_ARRAY[0]} + BUTTON_COLUMN1 \
            + (sc_space / 2) - (sc_width / 2) ))
        else
            BUTTON_COLUMN1=$((WIDEST_TITLE + 5))
            sc_space=$((${VIDSIZE%x*} - \
                ${SHOWCASE_TITLES_X_ARRAY[0]} - BUTTON_COLUMN1 - SAFE_AREA))
            SC_X=$(( ${SHOWCASE_TITLES_X_ARRAY[0]} + BUTTON_COLUMN1 \
            + (sc_space / 2) - (sc_width / 2) ))
            if [[ $BUTTON_GRAVITY = *east* ]]; then
                BUTTON_COLUMN1=$WIDEST_TITLE
                sc_space=$((${VIDSIZE%x*} - (SAFE_AREA * 2) - BUTTON_COLUMN1))
                SC_X=$((SAFE_AREA + (sc_space / 2) - (sc_width / 2) ))
            fi
        fi
        # find out where to put the showcase image in the Y axis
        if ! $TEXTMENU; then
            Y1=${SHOWCASE_THUMB_Y_ARRAY[0]}; Y2=${SHOWCASE_THUMB_Y_ARRAY[NUM_FILES]}
            ((NUM_FILES >= LEFT_MAX)) && Y2=${SHOWCASE_THUMB_Y_ARRAY[SPLIT-1]}
            Y_SPACE=$(( (Y2 - Y1) + ${THUMB_SIZE/*x} ))
            Y_SPACE=$(( Y_SPACE - sc_height ))
            SC_Y=$(( Y_SPACE / 2))
            SC_Y=$(( ${SHOWCASE_THUMB_Y_ARRAY[0]} + SC_Y ))
        else # TEXTMENU
#            ((NUM_FILES < SPLIT)) && split=$NUM_FILES || split=$((SPLIT - 1))
            # if there is a menu title, move the showcase thumb up or down
            if [[ -n $MENU_TITLE ]] && ! $USER_SC_GEO && ! $USER_TITLE_GEO; then
                [[ $TITLE_GRAVITY = "south" ]] && TITLE_SPACE="- $(( (title_yoffset + TITLE_TEXT_YDIM) / 2))"
                [[ $TITLE_GRAVITY = "north" ]] && TITLE_SPACE="+ $(( (title_yoffset + TITLE_TEXT_YDIM) / 2))"
            fi
            Y_SPACE=${VIDSIZE#*x}
            SC_Y=$(( (Y_SPACE / 2) - (sc_height / 2) $TITLE_SPACE ))

        fi

        ! $TEXTMENU && [[ $V_TOTAL -gt 5 ]] && SC_X=$(( ( ${VIDSIZE/x*} / 2 ) - (sc_width / 2) ))
        $TEXTMENU && [[ -n $tt_ygeos_col2 ]] && SC_X=$(( ( ${VIDSIZE/x*} / 2 ) - (sc_width / 2) ))
        $USER_SC_GEO && SC_X=${SHOWCASE_GEO/x*}
        $USER_SC_GEO && SC_Y=${SHOWCASE_GEO/*x}

        # make sure its divisible by 2 for ffmpeg's padding with -quick-menu
        if $QUICK_MENU; then
            SC_Y=$(( (SC_Y /2) * 2 ))
            SC_X=$(( (SC_X / 2) * 2 ))
        fi
        SC_IMG_PAGE="-page +$SC_X+$SC_Y"
        SC_IMG_CMD="$SC_IMG_PAGE "$WORK_DIR/showcase_img.png""
    fi
    if ! $SC_THUMB; then unset SC_IMG_CMD ; fi
    if [[ -n "$SHOWCASE_IMG" || -n "$SHOWCASE_VIDEO" ]]; then
        unset sc_cmd
        for ((i=0; i<=NUM_FILES; i++)); do
            sc_cmd=( ${sc_cmd[@]} ${SHOWCASE_THUMB_PAGES[i]} "${PICS[i]}")
        done
        $TEXTMENU && unset sc_cmd
        if $TRANSPARENT; then
            IM_CMD0=(convert  -size $VIDSIZE xc:none -background none \
            ${sc_cmd[@]} $SC_IMG_CMD -mosaic)
            IM_CMD1=(convert -size $VIDSIZE -background none \
            - ${sc_thumb_title_cmd[@]} -mosaic)
            IM_CMD2=(composite -size $VIDSIZE -background none \
            -gravity NorthWest  -dissolve $OPACITY - "$WORK_DIR/pics/template.png" \
            -background none)
            IM_CMD3=(convert - -background none $WORK_DIR/title_txt.png  \
            -gravity $TITLE_GRAVITY -geometry ${title_xoffset}${title_yoffset} \
            -composite "$PREVIEW_IMG" )
            echo "Running
            "${IM_CMD0[@]}" miff:- | "${IM_CMD1[@]}" miff:- |
            "${IM_CMD2[@]}" miff:- | "${IM_CMD3[@]}"
            " |format_output
            "${IM_CMD0[@]}" miff:- | "${IM_CMD1[@]}" miff:- |
            "${IM_CMD2[@]}" miff:- | "${IM_CMD3[@]}"
        else
            echo "Running:
            convert  -size $VIDSIZE "$WORK_DIR/pics/template.png"
            -background none ${sc_cmd[@]} $SC_IMG_CMD \
            -mosaic "$PREVIEW_IMG" "|sed "s/    */ /g;s/^ *//"|fold -bs
            convert  -size $VIDSIZE "$WORK_DIR/pics/template.png" \
            -background none ${sc_cmd[@]} $SC_IMG_CMD \
            -mosaic "$PREVIEW_IMG"
        fi
        unset sc_cmd IM_CMD05 IM_CMD04 IM_CMD03 IM_CMD4
    fi
elif ! $SHOWCASE && $DO_MENU; then # not showcase
    if $TRANSPARENT; then
        yecho "Running:
        montage ${PICS[@]} -blur 0x.3 -tile ${TILE_ARRAY[NUM_FILES]} \
        -geometry ${THUMB_SIZE}${MTG_GEO} -background none -bordercolor '#444744' miff:- |
        composite -dissolve $OPACITY \
        -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} - \
        $WORK_DIR/pics/template.png -background none miff:- |
        convert - $WORK_DIR/title_txt.png  \
        -gravity $TITLE_GRAVITY -geometry ${title_xoffset}${title_yoffset} \
        -composite $PREVIEW_IMG" | fold -bs
        montage ${PICS[@]} -blur 0x.3 -tile ${TILE_ARRAY[NUM_FILES]} \
        -geometry ${THUMB_SIZE}${MTG_GEO} -background none -bordercolor '#444744' miff:- |
        composite -dissolve $OPACITY \
        -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} - \
        "$WORK_DIR/pics/template.png" -background none miff:- |
        convert - -background none "$WORK_DIR/title_txt.png"  \
        -gravity $TITLE_GRAVITY -geometry ${title_xoffset}${title_yoffset} \
        -composite "$PREVIEW_IMG"
    else # Not transparent
        montage ${PICS[@]} -tile ${TILE_ARRAY[NUM_FILES]} \
        -geometry ${THUMB_SIZE}${MTG_GEO}  -background none -bordercolor "#444744" miff:- |
        convert "$WORK_DIR/pics/template.png" "$WORK_DIR/title_txt.png"  -gravity $TITLE_GRAVITY \
        -geometry ${title_xoffset}${title_yoffset} -composite -  -gravity $BUTTON_GRAVITY \
        -geometry +${XGEO}+${YGEO} -composite "$PREVIEW_IMG"
    fi
fi
# if there is quickmenu bg, cut out transparent hole for showcase image/video
if $QUICK_MENU; then
    if $QUICKMENU_IS_SHOWCASE && [[ -n "$BACKGROUND" ]]; then
        #[[ -n $SC_MATTECOLOR ]] && SC_MATTECOLOR="-mattecolor $SC_MATTECOLOR"
        # make a blank png for cutting out showcase area (cookie cutter)
        convert -size $SHOWCASE_SIZE xc:black "$WORK_DIR/showcase_blank.png"
        # make a similar framed blank to composite onto the background
        frame_cmd=(convert -size $SHOWCASE_SIZE xc:black \
        $SC_FRAME "$WORK_DIR/showcase_frame.png")
        yecho "Running ${frame_cmd[@]}" | fold -bs
        "${frame_cmd[@]}" >> "$LOG_FILE"
        # composite the framed blank onto background subtracting the width \
        # of the frame (border) when calculating XxY geometry
        convert "$WORK_DIR/pics/template.png" \
        "$WORK_DIR/showcase_frame.png" -geometry \
        +$((SC_X-${SC_BORDERWIDTH/x*}))+$((SC_Y-${SC_BORDERWIDTH/x*})) \
        -composite "$WORK_DIR/pics/template.png"
        # add blank to a transparent image the size of the menu video
        convert -size  $VIDSIZE xc:none "$WORK_DIR/showcase_blank.png" \
	    -geometry +$SC_X+$SC_Y -composite "$WORK_DIR/cookie_cutter.png"
        # cut out transparent hole in background with this 'cookie cutter'
        convert "$WORK_DIR/cookie_cutter.png" "$WORK_DIR/pics/template.png" \
        -compose Xor -composite "$WORK_DIR/quick_menu_bg.png"
    else
        cp "$WORK_DIR/pics/template.png" "$WORK_DIR/quick_menu_bg.png"
    fi
fi
$QUICK_MENU && quick_menu preview
if ! $NOASK && $VMGM_MENU && $MONTAGE_MENU && $DO_MENU; then
    echo "Creating and displaying a preview of the main menu."
    echo "(Press 'q' or ESC in the preview window to close it.)"
fi
# make the fake montage with highlighted 1st button and display it
if $DO_MENU && [[ $TARGET = "dvd" ]] && ! $SLIDESHOW; then
    composite -compose Over "$WORK_DIR/fake_montage.png" \
      "$PREVIEW_IMG" "$PREVIEW_IMG"
fi
if ! $NOASK && $VMGM_MENU && $MONTAGE_MENU; then
    display -title "todisc preview - close window to continue" "$PREVIEW_IMG"
    confirm_preview
fi
# copy the template back if using $MENU_FADE
if $MENU_FADE; then
    rm -v "$WORK_DIR/pics/template.png"
    cp -v "$WORK_DIR/pics/template.bk.png" "$WORK_DIR/pics/template.png"
fi
#rm -fv "${PICS[@]}"
unset PICS IM_CMD1 IM_CMD2 IM_CMD3 IM_CMD4 IM_CMD5

###############################################################################
#   get information about input videos, and some post preview preliminaries   #
###############################################################################

# if -bgvideo selected, but not -bgaudio, offer to use audio from bgvideo
# if "none" is passed for BG_AUDIO it means we are doing switched menus
# in which case we want to skip this step anyway
if ! $NOASK && ! $SWITCHED; then
    BGVIDEO_STATS=$(idvid -terse -fast "$BG_VIDEO" 2>&1)
    if [[ -n "$BG_VIDEO" && -z "$BG_AUDIO" ]]; then
        if grep -q "A_NOAUDIO=:" <<< "$BGVIDEO_STATS"; then
            :
        else
            echo "***** NOTE *****"
            echo "You selected -bgvideo but not -bgaudio"
            echo "If you want to use the audio from "$BG_VIDEO" please type: yes"
            read bgaudio
            if [ ! -z "$bgaudio" -a "$bgaudio" = "yes" ]; then
                BG_AUDIO="$BG_VIDEO"
                echo "Using audio from "$BG_VIDEO""
            else
                echo "No audio selected, will use silence for main menu"
            fi
        fi
    fi
fi

# find out the length of the -bgaudio FILE, if there is one
if [[ -n "$BG_AUDIO" ]]; then
    $SLIDESHOW && end_pos="" || end_pos=${MENU_LEN[MENU_NUM-1]}
    BG_AUDIOLENGTH=$(audio_length "$BG_AUDIO" $end_pos)
    yecho
    yecho "Getting length of bg audio"
    yecho
    # make sure user isn't trying to get a longer menu than the audio allows
    if [[ $(bc <<< "${MENU_LEN[MENU_NUM-1]} > $BG_AUDIOLENGTH" 2>/dev/null)  -eq 1 ]]; then
        MENU_AUDIOLENGTH=$BG_AUDIOLENGTH
    fi
fi
# if static menu and no background audio, ignore MENU_AUDIOLENGTH
$STATIC && [[ -z "$BG_AUDIO" ]] && ! $SWITCHED && unset MENU_AUDIOLENGTH
# for slideshow: set length of slides; check menu length is long enough
if $DO_SLIDE_MIX; then
    if $USER_MENU_LEN; then # user passed menu length takes precedence
        MIX_SLIDE_LEN=$(bc_math "${MENU_LEN[MENU_NUM-1]} / ${#MIX_IN[@]}")
    elif [[ -n $BG_AUDIO ]]; then # else use audio length
        MIX_SLIDE_LEN=$(bc_math "$BG_AUDIOLENGTH / ${#MIX_IN[@]}")
    else # if neither user menu length or slideshow audio passed: use 20s
        MIX_SLIDE_LEN=$(bc_math "${MENU_LEN[MENU_NUM-1]} / ${#MIX_IN[@]}")
    fi
    # subtract transition time from the slide length
#    TT=$(bc_math "(${#MIX_IN[@]} - 1) / ${#MIX_IN[@]}")
    TT=1
    $SLIDE_FADE && MIX_SLIDE_LEN=$(bc_math "$MIX_SLIDE_LEN - $TT")
    if [[ $(bc_math "$MIX_SLIDE_LEN < 0") -eq 1 ]]; then
        runtime_error "Your menu length is not long enough to use -menu-fade.
        For slideshows where -bgaudio FILE is supplied, this is determined by:
        1. -menu-length argument if supplied
        2. length of the supplied -bgaudio
        
        If -menu-length is not supplied, the length of the menu is the length
        the -bgaudio FILE, or 20 secs if silent background (no -bguaudio FILE)
        (Note: the fade effect duration is 1 second for each slide in the menu"
    fi
    MIX_ALEN=$MIX_SLIDE_LEN
    MIX_VFRAMES=$(bc_math "$MIX_SLIDE_LEN * $FRAME_RATE" int)
fi
# Check input files for compliance; offer to tovid-encode non-compliant files
# run this twice for switched menus for 1st menu made and last
# to make sure files get symlinked properly (Hack)
if [[ $MENU_NUM = [1-2] || -n ${file_is_image[@]}  ]]; then
    echo
    check_compliance
    $GROUPING && check_compliance group
fi
# -slide-mix joins the slides and can add audio (-slideshow-audio)
echo
if $DO_SLIDE_MIX; then
    for f in ${!MIX_IN[@]}; do
        this_file="${MIX_IN[f]/.todisc_enc.mpg}"
        MIX_ENC_CMD=(ffmpeg -r $FRAME_RATE -f image2 -loop_input -vframes \
         $MIX_VFRAMES -i "$this_file" -r $FRAME_RATE \
         -s $VIDSIZE -f mpeg2video -b 10000k -aspect $ASPECT_RATIO \
         -y "${MIX_IN[f]/.todisc_enc.*}.todisc_enc.m2v")
        spin "Creating slide 'mix' files:  ${this_file##*/}"
	echo "Running: ${MIX_ENC_CMD[@]}" >> "$LOG_FILE"
        "${MIX_ENC_CMD[@]}" >> "$LOG_FILE" 2>&1
        MIX_FILES=( "${MIX_FILES[@]}" \
          "${MIX_IN[f]/.todisc_enc.*}.todisc_enc.m2v" )

        # effects unfinished - only dissolve in/out for now
        if $SLIDE_FADE; then
            if [[ $f -lt ${#MIX_IN[@]} ]]; then
                overlay_png="$WORK_DIR/slide-overlay.png"
                base_png="$WORK_DIR/slide-base.png"
                convert  "${MIX_IN[f]/.todisc_enc.mpg}" -resize ${VIDSIZE}! \
                 "$base_png"
                if [[ $f -eq $((${#MIX_IN[@]} - 1)) ]]; then
                    overlay="${MIX_IN[0]/.todisc_enc.mpg}"
                else
                    overlay="${MIX_IN[f+1]/.todisc_enc.mpg}"
                fi    
                convert  "$overlay" -resize ${VIDSIZE}! \
                 "$overlay_png"
                [[ $TV_STANDARD = "ntsc" ]] && fade_frames=30 || fade_frames=25
                fade_incr=$(bc -l <<< "100 / $fade_frames")
                for ((i=1; i<=fade_frames; i++)); do
                    BLEND_AMT=$(bc_math "$i * $fade_incr")
                    composite -blend $BLEND_AMT "$overlay_png" \
                     "$base_png" "$WORK_DIR/animenu/fade$(printf %0d%s $i .jpg)"
                done
                if [[ $f -eq $((${#MIX_IN[@]} - 1)) ]]; then
                    convert "$overlay" -resize ${VIDSIZE}! \
                     "$WORK_DIR/overlay.jpg"
                    for s in {1..15}; do
                        # copy a few extra frames for looping end frame
                        cp "$WORK_DIR/overlay.jpg" \
                         "$WORK_DIR/animenu/fade$(printf %0d%s $((fade_frames + s)) .jpg)"
                    done
                fi
                
                ENC2M2V_CMD=(ffmpeg -f image2 -r $FRAME_RATE \
                 -i "$WORK_DIR"/animenu/fade%0d.jpg -f mpeg2video -b 8000k \
                 -aspect $ASPECT_RATIO -y "$WORK_DIR/fade${f}.m2v")
                "${ENC2M2V_CMD[@]}" >> "$LOG_FILE" 2>&1
                cat "${MIX_FILES[f]}" "$WORK_DIR/fade${f}.m2v" \
                 > "$WORK_DIR"/$(printf %06d%s $f .m2v)
                MIX_FILES[f]="$WORK_DIR"/$(printf %06d%s $f .m2v)
            else
                break
            fi
        fi
    done
    echo
 
    cat "${MIX_FILES[@]}"  > \
      "$WORK_DIR/slidesho.m2v"
    # use transcode to create SVCD compat mpeg
#    transcode -i  "$WORK_DIR/slidesho.m2v" -C 2 -J pp=dr=pre -J pp=tn=pre -J hqdn3d=pre=1 \
#    transcode -i  "$WORK_DIR/slidesho.m2v" -C 2 -J pp=dr -J pp=tn -J hqdn3d=1 \
    echo
    yecho "Transcoding the joined files into $TV_STND_CAPS $TGT_CAPS format"
    transcode -i  "$WORK_DIR/slidesho.m2v" -y mpeg2enc,null -J pp=dr -J pp=tn \
     -J unsharp=luma=-0.5:luma_matrix=3x3:chroma=-0.5:chroma_matrix=3x3:pre=1 \
     --export_prof ${TARGET}-${TV_STANDARD} -Z fast -o "$WORK_DIR/slideshow" \
     >> "$LOG_FILE" 2>&1
    # get length
    bgaudio_time=$(vid_length "$WORK_DIR/slideshow.m2v")
    
    if [[ -n $BG_AUDIO ]]; then
        # convert background audio to wav
        BGAUDIO_CMD=(ffmpeg -i "$BG_AUDIO" -t $bgaudio_time -ar 48000 \
         -ac 2 -acodec pcm_s16le -y $WORK_DIR/slideshow.wav)
    else
        # generate silence
        BGAUDIO_CMD=(ffmpeg -f s16le -t $bgaudio_time -i /dev/zero -ar 48000 \
        -ac 2 -acodec pcm_s16le -y $WORK_DIR/slideshow.wav)
    fi
    echo
    echo "Encoding audio to wav with: ${BGAUDIO_CMD[@]}" | format_output | tee -a "$LOG_FILE"
    echo
    "${BGAUDIO_CMD[@]}" >> "$LOG_FILE" 2>&1
    # fade wav if background audio used and user did not disable fading
    if [[ -n $BG_AUDIO ]] && $AUDIO_FADE; then
        sox "$WORK_DIR/slideshow.wav" "$WORK_DIR/slideshow-faded.wav" \
         fade t $FADE $bgaudio_time $FADE
        rm -f "$WORK_DIR/slideshow.wav"
        mv "$WORK_DIR/slideshow-faded.wav" "$WORK_DIR/slideshow.wav"
    fi

    # convert the wav to target format #FIXME get working for dvd
    echo
    echo "Converting wav to $TARGET format"
    if [[ $TARGET = "svcd" ]]; then
        BGAUDIO_CMD=(mp2enc -r 44100 -o "$WORK_DIR/slideshow.mp2")
        echo "Running ${BGAUDIO_CMD[@]} < $WORK_DIR/slideshow.wav" |
         format_output >> "$LOG_FILE"
        "${BGAUDIO_CMD[@]}" < "$WORK_DIR/slideshow.wav" 2>&1 |
         format_output >> "$LOG_FILE"
    else
        BGAUDIO_CMD=(ffmpeg -i "$WORK_DIR/slideshow.wav" \
         $AUDIO_OPTS -y "$WORK_DIR/slideshow.ac3")
        echo "Runnning ${BGAUDIO_CMD[@]}" | tee -a "$LOG_FILE"
        "${BGAUDIO_CMD[@]}" | format_output >> "$LOG_FILE" 2>&1
    fi
    echo
    # multiplex to mpeg-2 ( svcd or dvd )
    MPLEX_CMD=(mplex -V -f $MPLEX_FORMAT -o "$WORK_DIR/slideshow.mpg" \
    "$WORK_DIR/slideshow.$AUDIO_EXT" "$WORK_DIR/slideshow.m2v")
    yecho
    echo "Running ${MPLEX_CMD[@]}" |format_output |tee -a "$LOG_FILE"
    "${MPLEX_CMD[@]}" |format_output >> "$LOG_FILE" 2>&1
    yecho
    if [[ -s "$WORK_DIR/slideshow.mpg" ]]; then
        if [[ $TARGET = "svcd" ]]; then
            SLIDE_MENU=( -menu "$WORK_DIR/slideshow.mpg")
        else
            mv "$WORK_DIR/slideshow.mpg" "$WORK_DIR/intro.mpg"
        fi
    else
        runtime_error "The joined slideshow file was not created"
    fi
        
fi

# check bgvideo and showcase VIDEO for compliance ( if present ) #FIXME
if [[ -n $BG_VIDEO ]]; then
    if ! idvid -isformat ${TV_STANDARD}-${TARGET} "$BG_VIDEO" >/dev/null; then
        tovid_reencode "$BG_VIDEO" $BG_SEEK background
    fi
elif [[ -n $SHOWCASE_VIDEO ]]; then
    if ! $SWITCHED && ! $QUICK_MENU; then
        if ! idvid -isformat \
          ${TV_STANDARD}-${TARGET} "$SHOWCASE_VIDEO" >/dev/null; then
            tovid_reencode "$SHOWCASE_VIDEO" $SHOWCASE_SEEK_VAL showcase
        fi
    fi
fi

# symlink IN_FILES in $WORK_DIR to solve some quoting issues for dvdauthor
if [[ $MENU_NUM -eq 1 ]]; then
    yecho "Symlinking files to $WORK_DIR"
    for i in ${!IN_FILES[@]}; do
        (cd "$REAL_WORK_DIR" &&  ln -s "${IN_FILES[i]}" "$BASEDIR/${TSET_NUM}-$((i+1)).mpg")
    done
fi
$SLIDESHOW && echo "Getting stats on the slides now"
for ((i=0; i<${#IN_FILES[@]}; i++)); do
    if [[ $MENU_NUM -eq 1 ]]; then
        ! $SLIDESHOW && echo
        ! $SLIDESHOW && echo "Getting stats on "${IN_FILES[i]}""
        idvid_stats[i]="$(idvid -terse "${IN_FILES[i]}" 2>/dev/null)"
    fi
    if [ -s  "${IN_FILES[i]}.nav_log" ]; then
        length[i]="$(( $(awk '{ field = $2 }; END{ print field }' \
	 "${IN_FILES[i]}.nav_log") + 1))"
    fi
done

if $GROUPING &&  [[ $MENU_NUM -eq 1 ]]; then
    echo
    echo ". . . Getting stats on grouped files now . . ."
    echo
    for u in ${!grouping[@]}; do
        CUR_VID=$(readlink "${grouping[u]}")
        spin "Getting stats on "${CUR_VID##*/}""
        group_idvid_stats[u]="$(idvid -terse "$CUR_VID" 2>/dev/null)"
        if [ -s "$CUR_VID.nav_log" ]; then
            group_length[u]="$(( $(awk '{ field = $2 }; END{ print field }' \
            "$CUR_VID.nav_log") + 1))"
        fi
    done
    echo
fi

# get length of videos in a separate loop from other stats
# if we are doing SVCD there will be no nav_seek file
for i in ${!IN_FILES[@]}; do
    # if we have a non empty nav_log get the length from that
    if [ -s "${IN_FILES[i]}".nav_log ]; then
        VID_LEN[i]=$(bc_math "${length[i]} / $FRAME_RATE")
    else # otherwise, we run mencoder to get the length
        VID_LEN[i]=$(vid_length  "${IN_FILES[i]}" )
    fi
    if [[ ${VID_LEN[i]%.*} -lt ${SEEK_VAL[i]%.*} ]]; then
        usage_error "A seek of ${SEEK_VAL[i]} seconds is too large for ${IN_FILES[i]}. The file is only ${VID_LEN[i]} seconds long"
    fi
    # add -force to makevcd if short file
    if [[ ${VID_LEN[i]%.*} -lt 5 && $TARGET = "svcd" ]]; then
        BURN_PROG="makevcd -force"
    fi
    # wait for input on short files (slides) unless -video-pause passed
    if [[ $(bc_math "${VID_LEN[i]} < 1") -eq 1 ]]; then
        [[ $TARGET = "svcd" && -z $SVCD_PAUSE ]] && SVCD_PAUSE="-pause -1"
        [[ $TARGET = "dvd" && -z ${VPAUSE[i]} ]] && VPAUSE[i]="inf"
        # 1 chapter per short file, (altered below if group short file)
        ! $USER_CHAPTERS && CHAPTERS[i]=1 # each 'slide' is a chapter 
    fi
done
# make sure we have the length of grouped files as well
for g in ${!grouping[@]}; do
    # if we have a value for ${group_length[g]}  get the length from that
    if [[ -n "${group_length[g]}" ]]; then
        GROUP_VID_LEN[g]=$(bc_math "${group_length[g]} / $FRAME_RATE")
    else # otherwise, we run mencoder to get the length
        GROUP_VID_LEN[g]=$(vid_length "${grouping[g]}")
    fi
done
if $GROUPING; then
    index=0
    for i in "${!IN_FILES[@]}"; do
        if [[ ${GROUP[i]} ]]; then
            iter=( $BASEDIR/${TSET_NUM}-group-$((i+1))-*.mpg )
            for ((t=index; t<index+${#iter[@]}; t++)); do
                # get lengths of group videos also in a seperate loop
                # concatenate the group lengths in a string
                GROUP_VID_LENGTHS[i]="${GROUP_VID_LENGTHS[i]} ${GROUP_VID_LEN[t]}"
                # if short file, assume it is a slideshow, and use pause="inf"
                if [[ $(bc_math "${GROUP_VID_LEN[t]} < 1") -eq 1 ]]; then
                    # but only if -group-video-pause was not passed
                    [[ -z ${GRP_VPAUSE[i]} ]] && GRP_VPAUSE[i]="inf"
                    ! $USER_CHAPTERS && CHAPTERS[i]=0 # each slide's a chapter
                fi
		        # replacement for comma delimited locales
            done
            index=$((index+${#iter[@]}))
            unset iter
            # a string of the joined grouped lengths and 1st video in the group
            GROUP_VID_LENGTHS[i]="${VID_LEN[i]} ${GROUP_VID_LENGTHS[i]}"
            # total length for the whole group - for chapter creation
            GROUP_TOT_LEN[i]=$(awk_total <<< "${GROUP_VID_LENGTHS[i]}")
        fi
    done
fi
# put in the log file in case anyone is interested
if ! $VMGM_ONLY &&  [[ $MENU_NUM -eq 1 ]] && $DO_STATS; then
    get_stats files
    echo
fi
if ! $VMGM_ONLY &&  [[ $MENU_NUM -eq 1 ]] && $GROUPING && $DO_STATS; then
    get_stats group
    echo; echo $SEPARATOR
fi
echo

# run quick_menu to create an almost finished menu file ( intro.m2v )
$QUICK_MENU && quick_menu
# if doing switched menus, use the bgaudio from each video
# unless "none" is passed for -bgaudio
if $SWITCHED; then
    yecho
    let vid=MENU_NUM-1
    SHOWCASE_SEEK_VAL=${SEEK_VAL[vid]}
    # use silence if a short file ( probably a slide )
    [[ $( bc_math "${VID_LEN[vid]} < 1") -eq 1 ]] && BG_AUDIO="none"
    # if no audio is detected in the video
    if grep -q "A_NOAUDIO=:" <<< "${idvid_stats[vid]}"; then
        # if -bgaudio is not passed, or passed as 'none', use silence
        if [[ -z $BG_AUDIO || $BG_AUDIO = "none" ]]; then
            yecho "Using silence as audio background for "${FILES[vid]}""
        # if -bgaudio is passed, use the provided file
        else
            yecho "Using $BG_AUDIO as audio background for "${FILES[vid]}""
        fi    
    else # audio detected in the video
        if [[ -z $BG_AUDIO && $BG_AUDIO != "none" ]]; then
            # use the audio from each video for each switched menu
            BG_AUDIO=${IN_FILES[vid]}
            if $STATIC; then
                [[ -z $MENU_AUDIOLENGTH ]] && MENU_AUDIOLENGTH=${MENU_LEN[MENU_NUM-1]}
                # start audio at the beginning unless user passes -bgaudio-seek
                ! $USER_BG_AUDIO_SEEK && BG_AUDIO_SEEK=0
                # make sure MENU_AUDIOLENGTH value isn't longer than the video
                # FIXME if video shorter than menu length adjust MENU_LEN
                [[ $( bc_math "$MENU_AUDIOLENGTH > ${VID_LEN[vid]}") -eq 1 ]] \
                                            && MENU_AUDIOLENGTH=${VID_LEN[vid]}
                # MENU_LEN can't be longer than the audio length
                # don't use a fade unless the video is long enough to support it
                [[ $(bc_math "${VID_LEN[vid]} < (($FADE * 2) + 2)") -eq 1 ]] \
                                                && AUDIO_FADE=false
            else
                # same seek value as video unless user passes -bgaudio-seek
                ! $USER_BG_AUDIO_SEEK && BG_AUDIO_SEEK=${SEEK_VAL[vid]}
                # the menu audio will be the same length as the switched video
            fi
            yecho "Using audio from "${FILES[vid]}" for the audio background,"
            ! $STATIC && yecho "using the same seek value for the audio as the video"
            yecho "If you wish to use silence for the switched menu,"
            yecho "use '-bgaudio none'"
        else
            if [[ $BG_AUDIO = "none" ]]; then # no audio if -bgaudio none
                BG_AUDIO=""
                MENU_AUDIOLENGTH=2
                AUDIO_FADE=false
            else # BG_AUDIO="$BG_AUDIO" if -bgaudio supplied and not 'none'
                [[ -z $MENU_AUDIOLENGTH ]] && MENU_AUDIOLENGTH=${MENU_LEN[MENU_NUM-1]}
                yecho "Using "$BG_AUDIO" as audio background for "${FILES[vid]}""
            fi
        fi
    fi 
    yecho
fi
for ((i=0; i<${#VID_LEN[@]}; i++)); do
    NEW_LENGTH=( ${NEW_LENGTH[@]}   ${VID_LEN[i]%.*} )
done
# find out longest video and shortest video
for ((i=0; i<${#NEW_LENGTH[@]}; i++)); do
    val=${NEW_LENGTH[i]}
    [ -z "$MAX_VAL" ] || ((val > MAX_VAL)) && MAX_VAL=$val && max_key=$i
    if $ANI_SUB_MENU; then
        [ -z "$MIN_VAL" ]  || ((val < MIN_VAL)) && MIN_VAL=$val && min_key=$i
    fi
done
# if animated submenu check if videos are long enough for the # of chapters
if $ANI_SUB_MENU; then
    for ((i=0; i<=NUM_FILES; i++)); do
        S=$(bc_math "${SEEK_VAL[i]} * $FRAME_RATE" int)
        F=$(bc_math  "${CHAPTERS[i]} * 340" int )
        V=$(bc_math "${VID_LEN[i]} * $FRAME_RATE" int)
        if [ $((V - S)) -le $F ] ; then
            echo "Sorry, you can not use ${CHAPTERS[i]} chapters for ${IN_FILES[i]}"
            echo "The maximum number for this video (using a -seek of ${SEEK_VAL[i]}):"
            echo "$(bc_math "($V - $S) / 340" int) chapters"
            exit 1
        fi
        unset V F
    done
fi
# allow animated menus of length of longest video
MAX_MENU_LEN=$(bc_math "$FRAME_RATE * ${MENU_LEN[MENU_NUM-1]}" int)
MAX_VAL_FRAMES="$((MAX_VAL * 30))"
# if submenu selected, translate seconds of submenu length into # of frames
if $ANI_SUB_MENU; then
    ANI_SUBMENU_FRAMES=$(bc_math "$FRAME_RATE * $ANI_SUBMENU_LEN" int)
fi

MENU_FRAMES=$MAX_MENU_LEN
if $STATIC; then
    FRAMES=1
else
    FRAMES=$MENU_FRAMES
fi
###############################################################################
#                           End of info block                                 #
###############################################################################

###############################################################################
#                       work on the clip title images                         #
###############################################################################
# extract images from the provided background video
if ! $TEXTMENU && $DO_MENU; then
    echo
    echo "Creating $FRAMES images from each video for the main menu"
    for ((i=0; i<=NUM_FILES; i++)) ; do
        if [ "$SC_FRAMESTYLE" = "glass" ]; then
            # some vars for get_framed_pics()
            D=2
            VOUT="png:z=7"
            FRAME_SIZE=$THUMB_SIZE
            echo "Using mplayer to get framed images from "${IN_FILES[i]}""
            OUT=$WORK_DIR/pics/$i
            echo "Working on "${IN_FILES[i]}""
            MPLAYER_SEEK_VAL=${SEEK_VAL[i]}
            get_framed_pics "${IN_FILES[i]}"   >> "$LOG_FILE" 2>&1
            echo
            for ((p=1; p<=$FRAMES; p++)); do
                mv  "$WORK_DIR"/$(printf "%08d%s" $p .png) \
                  $WORK_DIR/pics/$i/$(printf "%06d%s" $p .png) 2>/dev/null
            done
        elif [[ ${file_is_image[i]} = "yes" ]]; then
            spin "Convert ${IN_FILES[i]/.todisc_enc.mpg} to proper size/format"
            convert "${IN_FILES[i]/.todisc_enc.mpg}" -depth 8 \
              -resize ${THUMB_SIZE}! \
              "$WORK_DIR/pics/$i/$(printf "%06d%s"  0 .${IMG_FMT})"
        else
            echo "Working on ${IN_FILES[i]}"
            if [ -s  "${IN_FILES[i]}.nav_log" ]; then
                NAV_SEEK[i]="--nav_seek"
                NAVSEEK[i]=${IN_FILES[i]}.nav_log
            fi

            TRANSCODE_CMD2=(nice transcode --print_status 10 \
            --write_pid $WORK_DIR/tcode$i.pid -q 1 -i "${IN_FILES[i]}" \
            -c ${SEEK_FRAMES[i]}-$((${SEEK_FRAMES[i]} + $FRAMES)) ${NAV_SEEK[i]} "${NAVSEEK[i]}" \
            -o "$WORK_DIR/pics/$i/" -f $FRAME_RATE  -Z $THUMB_SIZE $EXPORT)
            yecho "Running ${TRANSCODE_CMD2[@]}" | fold -bs
        
            run_transcode()
            {
                "${TRANSCODE_CMD2[@]}" >> "$LOG_FILE"  2>&1
                sleep 1
            }
            run_transcode &
            sleep 1 # short sleep to allow 1st jpg to appear
            TRANSCODE_PID=$(<$WORK_DIR/tcode$i.pid)
            check_stall $TRANSCODE_PID &
            if [[ -n "$TRANSCODE_PID" ]]; then
                while ps -p $TRANSCODE_PID >/dev/null; do
                    sleep 2 # spinner interval
                spin "Seeking in video and creating images: $(find $WORK_DIR/pics/$i \
            -maxdepth 1 -name \*.$IMG_FMT|sort|awk -F / '{ field = $NF }; END{ print field }')"
                done
                echo
                echo "Created $(find $WORK_DIR/pics/$i -maxdepth 1 -name \*.$IMG_FMT|wc -l) images of $FRAMES"
            else
                runtime_error "Problem creating images from the video."
            fi
            unset TRANSCODE_CMD2 run_transcode
        fi
    done
fi
# create the pics for background image
if $DO_MENU; then
    if [ -z "$BG_PIC" ]; then
        echo
        echo "Creating a black background"
        BG_PIC="$WORK_DIR/pics/template.jpg"
        if $QUICK_MENU; then
            convert  -size $VIDSIZE xc:none "$BG_PIC"
        else
            convert  -size $VIDSIZE xc:'#'$BG_COLOUR "$BG_PIC"
        fi
        convert  -size $VIDSIZE xc:'#'$SUBMENU_BG_COLOUR \
          "$WORK_DIR/submenu_template.jpg"
    else
        convert -resize $VIDSIZE! "$BG_PIC" "$WORK_DIR/pics/template.jpg"
        convert -size $VIDSIZE xc:'#'$SUBMENU_BG_COLOUR \
          "$WORK_DIR/submenu_template.jpg"
    fi
    echo
fi
# chapters and submenu xml stuff
# this block does not run if user passing HH:MM:SS chapters
if [[ -n ${CHAPT_ARRAY[@]} ]]; then
    :
else
    for ((s=0; s<=NUM_FILES; s++)); do
        # make chapter points for videos, divide by $CHAPTERS to get 
        # chapter lengths, then get running totals
        CHAPT_INTERVALS[s]=$(bc_math "${VID_LEN[s]} / ${CHAPTERS[s]}")
        # <TODO if GROUPING:  for group chapter thumbs feed group 
        # chapter points to transcode in a loop as normal, but output 
        # to different subdirs. Then rename according to frame number
        # moving all to the same subdir. Then follow usual procedure,
        # moving  into chapter subdirs for final montages  /TODO>

        # and format in HH:MM:SS
        L=( ${L[@]} $(for ((i=1; i<=${CHAPTERS[s]}; i++)) ; \
        do echo "${CHAPT_INTERVALS[s]}";done) )
        chapt_intervals=$(running_total <<< ${L[@]})
        chapters="$(for c in $chapt_intervals; \
        do echo $(format_seconds $c); done)"
        # replace commas for comma delimited locales
        chapters="00:00:00.000 $chapters"
        if [ ${CHAPTERS[s]} = 1 ]; then chapters="00:00:00.000"; fi
        CHAPTS=$(for i in $chapters; do echo -n $i,;done)
        CHAPT_ARRAY[s]="${CHAPTS%?}" # %? to remove trailing ','
        unset L cmd
    done
fi
if $SUB_MENU; then
    for ((s=0; s<=NUM_FILES; s++)); do
        echo
        echo "Creating highlight and select PNGs for submenu $((s + 1))"
        C=$((${CHAPTERS[s]} - 1))
        MENU_BUTTON_SIZE=${GEO_ARRAY[C]}
        get_button_geo
(
cat  <<EOF
rectangle 2,2 $GEO
EOF
)  > $WORK_DIR/draw_file${s}

        convert -size "${GEO_ARRAY[C]}+5+5" xc:none -fill none \
        +antialias -stroke "$SELECT_CLR" -strokewidth 4 -draw @draw_file${s} \
        -colors 3 "$WORK_DIR/Submenu${s}_Selectx1.png"
        convert -size "${GEO_ARRAY[C]}+5+5" xc:none -fill none \
        +antialias -stroke "$HLIGHT_CLR" -strokewidth 4 -draw @draw_file${s} \
        -colors 3 "$WORK_DIR/Submenu${s}_Highlightx1.png"
        for button in Select Highlight; do
            montage -background none \
            $(for ((i=0; i<=C; i++)); do
            echo $WORK_DIR/Submenu${s}_${button}x1.png;done) \
            -tile ${TILE_ARRAY[C]} \
            -geometry ${GEO_ARRAY[C]}+5+5 \
            -bordercolor none -mattecolor transparent miff:- |

            convert  -colors 3 -size $VIDSIZE xc:none  - \
            -gravity north -geometry +0+45  \
            -composite  $WORK_DIR/Submenu${s}_${button}.png
        done
        # make submenu spumux.xml
(
    cat <<EOF
<subpictures>
   <stream>
     <spu force="yes" start="00:00:00.0"
          highlight="$WORK_DIR/Submenu${s}_Highlight.png"
          select="$WORK_DIR/Submenu${s}_Select.png"
          autooutline="infer"
          autoorder="rows"/>
   </stream>
 </subpictures>
EOF
) > "$WORK_DIR/submenu$((s + 1))_spumux.xml"
    done
fi

# debug chapters
if ! $VMGM_ONLY &&  [[ $MENU_NUM -eq 1 ]] && ! $GROUPING && $DO_STATS; then
    echo
    for ((i=0; i<=NUM_FILES; i++)); do
        echo -e "Chapters for "${IN_FILES[i]}" are: \n"${CHAPT_ARRAY[i]}"\n"
    done
fi
# get button coordinates if text-rect buttons (showcase menu only)
if [[ $BUTTON_STYLE = "text-rect" ]]; then
    for ((i=0; i<=NUM_FILES; i++)); do
        xdim=${TT_DIM[i]%%x*}
        ydim=${TT_DIM[i]##*x}
        X0=${SHOWCASE_TITLES_X_ARRAY[i]}
        X1=$((X0 + xdim))
        Y0=${SHOWCASE_TITLES_Y_ARRAY[i]}
        Y1=$((Y0 + ydim))
        ((X0%2 && X0--)); ((Y0%2 && Y0--))
        ((X1%2 && X1++)); ((Y1%2 && Y1++))
        btn_geos[i]="x0=\"$X0\" y0=\"$Y0\" x1=\"$X1\" y1=\"$Y1\""
    done
fi 
if [[ "$BUTTON_STYLE" = "text" && -z "$OUTLINEWIDTH" ]]; then
    OUTLINEWIDTH="\"14\""
else
    [[ -z "$OUTLINEWIDTH" ]] && OUTLINEWIDTH="\"6\""
fi
# the spumux here doc starts loops at 1, so NUM_BUTTONS has an extra index
if $PLAYALL ||  ($TITLESET_MODE && $VMGM_MENU) || ($TSET_MODE && $VMGM_MENU); then
    NUM_BUTTONS=$(( ${#FILES[@]} + 1 ))
else
    NUM_BUTTONS=${#FILES[@]}
fi
# no FILES for VMGM menu (titleset arrangements): use ${#TITLES[@]}
$VMGM_ONLY && NUM_BUTTONS=${#TITLES[@]}
$SWITCHED && SPUMUX_XML="$BASEDIR/spumux.xml"
if $SWITCHED; then
    down="down=\"ActionDown\"" && up="up=\"ActionUp\"" 
    right="right=\"ActionDown\"" && left="left=\"ActionUp\""
    updown="down=\"ActionDown\" up=\"ActionUp\""
fi
(
    cat <<EOF
$($SHOWCASE || { $SLIDESHOW && [[ -z ${grouping[@]} ]] ; } && closebracket='>'
echo -e "<subpictures>"
echo -e  "  <stream>"
echo -e    "    <spu force=\"yes\" start=\"$START\"$END"
echo -e "         highlight=\"$WORK_DIR/Highlight.png\""
echo -e "         select=\"$WORK_DIR/Select.png\"$closebracket"
if ! $SHOWCASE && ! { $SLIDESHOW && [[ -z ${grouping[@]} ]] ; }; then
    echo -e "         autooutline=\"infer\""
    echo -e "         outlinewidth="$OUTLINEWIDTH""
    echo -e "         autoorder=\"$AUTOORDER\">"
fi)
$(if $QUICK_NAV && $SLIDESHOW && [[ -z ${grouping[@]} ]]; then
    echo -n "       <button name=\"1\" ${btn_geos[0]} "
    echo -e "       left=\"ActionLeft\" right=\"ActionRight\"/>"
    echo -e "        <action name=\"ActionLeft\"/>"
    echo -e "        <action name=\"ActionRight\"/>"
    if { $TITLESET_MODE || $TSET_MODE ; } && $VMGM_MENU; then
        echo -e "        <button name=\"2\"  ${btn_geos[1]} up=\"1\"/>"
    fi
elif $QUICK_NAV; then
    for ((i=1; i<=NUM_BUTTONS; i++)); do
        ! $SWITCHED_MENUS && right="right=\"$((i+1))\"" && left="left=\"$((i-1))\""
        if [[ $i -eq 1 ]]; then
            echo -n \
             "       <button name=\"$i\" ${btn_geos[i-1]} $down $up"
        elif [[ $i -eq ${#FILES[@]} ]]; then
            if  $PLAYALL || $VMGM_MENU; then
                echo -n \
                 "       <button name=\"$i\" ${btn_geos[i-1]} $up down=\"$((i+1))\""
            else
                echo -n "       <button name=\"$i\" ${btn_geos[i-1]} $down $up"
            fi
        else
            [[ $i -ne $(( ${#FILES[@]} + 1)) ]] && \
            echo -e \
             "       <button name=\"$i\" ${btn_geos[i-1]} $left $right $down $up/>"
        fi
        [[ $i -eq 1 ]] && echo -e " left=\"ActionLeft\" $right/>"
        if [[ $i -eq ${#FILES[@]} ]]; then
            echo -e " right=\"ActionRight\" $left/>"
            echo -e "       <action name=\"ActionLeft\"/>"
            echo -e "       <action name=\"ActionRight\"/>"
            if $SWITCHED_MENUS; then
                echo -e "       <action name=\"ActionDown\"/>"
                echo -e "       <action name=\"ActionUp\"/>"
            fi
        fi
        if [[ $i -eq $(( ${#FILES[@]} + 1 )) ]]; then
            if $VMGM_MENU && $PLAYALL; then
                echo -n "       <button name=\"$i\" ${btn_geos[i-1]} "
                echo -e "up=\"$((i-1))\" down=\"$((i+1))\"/>"
                echo -e "       <button name=\"$((i+1))\" ${btn_geos[i]} $down/>"
            else
                echo -e "       <button name=\"$i\" ${btn_geos[i-1]} $down/>"
            fi
        fi
    done
fi)   
$(if $SWITCHED && ! $QUICK_NAV; then
    for ((i=1; i<=NUM_BUTTONS; i++)); do
        if [[ $i -eq $(( ${#FILES[@]} + 1 )) ]]; then
            if $TITLESET_MODE && $VMGM_MENU && $PLAYALL; then
                echo -n "       <button name=\"$i\" ${btn_geos[i-1]} "
                echo -e "up=\"$((i-1))\"/>"
                echo -e "       <button name=\"$((i+1))\" ${btn_geos[i]} $down/>"
            else
                echo -n "       <button name=\"$i\" ${btn_geos[i-1]} "
                echo -e "up=\"$((i-1))\" $down/>"
            fi
        elif [[ $i -eq ${#FILES[@]} ]]; then
            if { $TITLESET_MODE && $VMGM_MENU ; } || $PLAYALL; then
                echo -n "       <button name=\"$i\"  ${btn_geos[i-1]} "
                echo -e "$up down=\"$((i+1))\"/>"
            else
                echo -e "       <button name=\"$i\" ${btn_geos[i-1]} $updown/>"
            fi
        else
            echo -e "       <button name=\"$i\"  ${btn_geos[i-1]} $updown/>"
        fi
    done
    echo -e "       <action name=\"ActionDown\"/>"
    echo -e "       <action name=\"ActionUp\"/>"
fi)
$(if ! $SWITCHED && ! $QUICK_NAV; then
    if $SLIDESHOW && [[ -z ${grouping[@]} ]]; then
        echo -e "      <button name=\"1\" ${btn_geos[0]}/>"
        if $TITLESET_MODE && $VMGM_MENU; then
            echo -e "      <button name=\"2\" ${btn_geos[1]}/>"
        fi
    else
        for ((i=1; i<=NUM_BUTTONS; i++)); do
            echo -e "      <button name=\"$i\" ${btn_geos[i-1]}/>"
        done
        if $PLAYALL && { $TITLESET_MODE && $VMGM_MENU ; }; then
            echo -e "      <button name=\"$i\" ${btn_geos[NUM_FILES+2]}/>"
        fi
    fi
fi)
    </spu>
  </stream>
</subpictures>
EOF
) |sed '/^ *$/d'  > "$SPUMUX_XML"

if $SUB_MENU; then
    JUMP=menu
    POST="        <post> jump cell 1; </post>"
    if $ANI_SUB_MENU; then
        PAUSE=" pause=\"$PAUSE_TIME\""
    else
        PAUSE=" pause=\"inf\""
        unset POST
    fi
else
    JUMP=title
fi
if [ "$TARGET" = "dvd" ]; then
# make dvdauthor.xml
# g1 register: switched menus, g2: vmgm intro
# g3: -quick-nav, g4: playall, g5: button highlight, g6: VMGM button highlight
# Note: for switched menus g1 is used for 'button highlight', not g5
# TSET_NUM is the titleset number being worked on
# ALLTITLES is an array of the number of titles in each titleset
# NUM_MENUS is the # of menus being made
# menu_num is the current menu being worked on 
# the above 2 values always equal 1 unless doing switched menus

# TSET_NUM supplied by the calling todisc script and is the current titleset #
MENU_FILE="$BASEDIR/animenu${TSET_NUM}-${MENU_NUM}.mpg"
VMGM_PREJUMP="jump titleset 1 menu;"
$VMGM_ONLY && MENU_FILE="$BASEDIR/VMGM.mpg"
$SWITCHED_MODE && ! $VMGM_ONLY && MENU_FILE="$BASEDIR/animenu${TSET_NUM}-${MENU_NUM}.mpg"
VMGM_PRE="if ( g5 eq 0 ) g5 = 1;"
$SWITCHED_MENUS && VMGM_PRE="$VMGM_PRE if (g1 eq 0) g1=1;$VMGM_PREJUMP" || VMGM_PRE="$VMGM_PRE $VMGM_PREJUMP"
VMGM_PRE="<pre>$VMGM_PRE</pre>"
$SWITCHED_MENUS && NUM_MENUS=${#FILES[@]} || NUM_MENUS=1
! $AUTHOR && DVDAUTHOR_XML="$BASEDIR/dvdauthor.xml"
(
    cat <<EOF
$(if $AUTHOR ; then
    echo "<?xml version=\"1.0\" encoding=\"utf-8\"?>"
    echo -e "<dvdauthor dest=\"$OUT_DIR\" jumppad=\"0\">"
    echo -e "  <vmgm>\n    <menus>"
    echo -e "      <pgc entry=\"title\" pause=\"0\">"
    echo -e "        $INTRO"
    echo -e "        <vob file=\"$WORK_DIR/dummy.mpg\"/>"
    echo -e "        $VMGM_PRE"
    echo -e "      </pgc>\n    </menus>\n  </vmgm>"
fi)
  <titleset>
    <menus>
$(for ((menu_num=1; menu_num<=NUM_MENUS; menu_num++)); do
    echo -e "      <pgc>"
    for ((i=1; i<=$V_TOTAL; i++)); do
        if $SUB_MENU; then
            JUMP_INC=$((i + NUM_MENUS))
        else
            JUMP_INC=$i
        fi
        if $SLIDESHOW && [[ -z ${grouping[@]} ]] ; then
            :
        else
            if $MENUBUTTONS_ARE_CHAPTS && [[ -z ${grouping[@]} ]]; then
                echo -e \
                "        <button name=\"$i\">g5=$i; jump title 1 chapter $i;</button>"
            else
                echo -e \
                 "        <button name=\"$i\">g5=$i; jump $JUMP $JUMP_INC;</button>"
            fi
        fi
    done
    if $QUICK_NAV; then
        if [[ $TSET_NUM -eq 1 ]]; then PREV=$TSET_TOT; else PREV=$(( TSET_NUM - 1 )); fi
        if [[ $TSET_NUM -eq $TSET_TOT ]]; then NEXT=1; else NEXT=$(( TSET_NUM + 1)); fi
        if [[ $TSET_NUM -eq 1 ]]; then Ind=$((TSET_TOT-1)); else Ind=$(( TSET_NUM - 2 )); fi
    fi
    if $SLIDESHOW && [[ -z ${grouping[@]} ]]; then
        echo -e "        <button name=\"1\">jump title 1;</button>"
    fi
    if $QUICK_NAV; then
        echo -e "        <button name=\"ActionLeft\">"
        echo -e "        g1=${ALLTITLES[Ind]}; g5=${ALLTITLES[Ind]}; g3=$PREV; button=1024;"
        echo -e "        jump vmgm menu entry title;</button>"
        echo -e "        <button name=\"ActionRight\">"
        echo -e "        g1=1; g5=1; g3=$NEXT; button=1024;"
        echo -e "        jump vmgm menu entry title;</button>"
    fi
    if $SLIDESHOW && [[ -z ${grouping[@]} ]]; then
        if  $TITLESET_MODE && $VMGM_MENU; then
            echo -n "        <button name=\"2\">g2=1; g3=1000; g6=$TSET_NUM; jump vmgm menu;"
            echo -e "</button>"
        fi
    fi
    if $SWITCHED_MENUS; then
        if [[ $menu_num -eq $NUM_MENUS ]]; then
            inc=1
        else
            inc=$((menu_num+1))
        fi
        [[ $menu_num -eq 1 ]] && dec=$NUM_MENUS || dec=$((menu_num - 1))
        echo -e "        <button name=\"ActionUp\">g1 = $dec; jump menu $dec;</button>"
        echo -e "        <button name=\"ActionDown\">g1 = $inc; jump menu $inc;</button>"
    fi
    NAV_BTN_NUM=$V_TOTAL
    if $PLAYALL ; then
        ((NAV_BTN_NUM++))
        echo -e "        <button name=\"$NAV_BTN_NUM\">g4=1; jump title 1 chapter 1;</button>"
    fi
    if  $TITLESET_MODE && $VMGM_MENU && \
     ! { $SLIDESHOW && [[ -z ${grouping[@]} ]] ; }; then
        ((NAV_BTN_NUM++))
        echo -e "        <button name=\"$NAV_BTN_NUM\">g2=1; g3=1000; g6=$TSET_NUM; jump vmgm menu;</button>"
    fi
    echo -e "        <vob file=\"$BASEDIR/animenu${TSET_NUM}-${menu_num}.mpg\" pause=\"$VMGM_PAUSE_TIME\"/>"
    if $SWITCHED_MENUS; then
        if [[ $menu_num -ne $NUM_MENUS ]]; then
            echo -e "        <pre>"
            echo -e "        button = g1 * 1024;"
            echo -e "        if (g1 ne $menu_num) jump menu $((menu_num+1));"
            echo -e "        </pre>"
        else
            echo -e "        <pre>button = g1 * 1024;</pre>"
        fi
    else
        if $SLIDESHOW && [[ -z ${grouping[@]} ]]; then
            echo -e "        <pre>if (g5 gt 1) g5=1; button = g5 * 1024;</pre>"
        else
            echo -e "        <pre>button = g5 * 1024; </pre>"
        fi
    fi
    echo -e "$MAIN_PRE"
    echo -e "$MAIN_POST"
    echo -e "      </pgc>"
done)
$(if $SUB_MENU; then
    echo -ne "      <pgc>\n"
        for ((Y=1; Y<=$V_TOTAL; Y++)); do
            for ((g=1; g<=${CHAPTERS[Y-1]}; g++)); do
                echo -e "        <button name=\"$g\">jump title $Y chapter $g;</button>"
            done
            echo -e "        <vob file=\"$BASEDIR/${TSET_NUM}-Menu$Y.mpg\"$PAUSE/>"
echo "$POST"
            echo "      </pgc>"
            echo "      <pgc>"
        done | sed '$d'
fi)
    </menus>
    <titles>
      $TITLES_VID_TAG
$(if $SUBTITLES; then
    for ((s=0; s<${#SUBS_ARRAY[@]}; s++)); do
        echo -e "      <subpicture lang=\"${SUBS_ARRAY[s]}\"/>"
    done
fi)
$(if ($SLIDESHOW || $MENUBUTTONS_ARE_CHAPTS) && [[ -z ${grouping[@]} ]]; then
    echo -e "      <pgc>"
fi)
$(for ((i=0; i<${#IN_FILES[@]}; i++)); do
    vid_pause=""; grp_vid_pause=""
    [[ -n ${VPAUSE[i]} ]] && vid_pause="pause=\"${VPAUSE[i]}\""
    [[ -n ${GRP_VPAUSE[i]} ]] && grp_vid_pause="pause=\"${GRP_VPAUSE[i]}\""
    unset j
    if ($SLIDESHOW || $MENUBUTTONS_ARE_CHAPTS) && [[ -z ${grouping[@]} ]]; then
        :
    else
        echo -e "      <pgc>"
    fi
    if $AUDIOLANG; then
        echo "${VOB_PRE[i]}"
    fi
    if [[ -n ${GROUP[i]} ]]; then
       [[ $MENU_NUM -eq 1 && ${CHAPTERS[i]} -ne 0 ]] && get_group_chapters $i format
        if ((${CHAPTERS[i]} == 0)); then
            echo -e "        <vob file=\"$BASEDIR/${TSET_NUM}-$((i+1)).mpg\" $vid_pause/>"
            for mpg in $BASEDIR/${TSET_NUM}-group-$((i+1))-*.mpg; do
                echo -e "        <vob file=\"$mpg\" $grp_vid_pause/>"
            done
        else
            echo -e "        <vob file=\"$BASEDIR/${TSET_NUM}-$((i+1)).mpg\" $chpts0 $vid_pause/>"
            for mpg in $BASEDIR/${TSET_NUM}-group-$((i+1))-*.mpg; do
                echo -e "        <vob file=\"$mpg\" ${chpts[++j]} $grp_vid_pause/>"
            done
        fi
    else
        echo -ne "        <vob file=\"$BASEDIR/${TSET_NUM}-$((i+1)).mpg\""
        echo -e  " chapters=\""${CHAPT_ARRAY[i]}"\" $vid_pause/>"
    fi
    if $CHAIN_VIDEOS; then
        if [ "${POST_PLAY[i]}" = "chain" ]; then
            (( i < NUM_FILES )) && CHAIN_PP="jump title $((i + 2)) chapter 1"
            (( i == NUM_FILES )) && CHAIN_PP="jump title 1 chapter 1"
        else
            CHAIN_PP="call menu"
        fi
        if $PLAYALL; then
            if [ $i -lt $NUM_FILES ]; then
                echo -e "        <post>if (g4==1) jump title $((i+2)) chapter 1; $CHAIN_PP;</post>"
            else
                echo -e "        <post>call menu;</post>"
            fi
        else
            echo -e "        <post>$CHAIN_PP;</post>"
        fi
    else
        if $PLAYALL; then
            if [ $i -lt $NUM_FILES ]; then
                echo -e "        <post>if (g4==1) jump title $((i+2)) chapter 1; call menu;</post>"
            else
                echo -e "        <post>call menu;</post>"
            fi
        else
            if ($SLIDESHOW || $MENUBUTTONS_ARE_CHAPTS) && \
             [[ -z ${grouping[@]} ]]; then
                [[ $i = $NUM_FILES ]] && \
                 echo -e "        <post>call menu;</post>"
            else
                echo -e "        <post>call menu;</post>"
            fi
        fi
    fi
    if ($SLIDESHOW || $MENUBUTTONS_ARE_CHAPTS) && [[ -z ${grouping[@]} ]]; then
        :
    else
        echo -e "      </pgc>"
    fi
done)
$(($SLIDESHOW || $MENUBUTTONS_ARE_CHAPTS) && [[ -z ${grouping[@]} ]] && \
 echo -e "      </pgc>")
    </titles>
  </titleset>
$(if $AUTHOR; then
echo -e "</dvdauthor>"
fi)
EOF
) |sed '/^ *$/d' >> "$DVDAUTHOR_XML"
fi

##############################################################################
#                            Animenu stuff                                   #
##############################################################################

# make dummy VMGM mpeg
if ! $TITLESET_MODE && ! $DO_TITLESETS && [[ $TARGET = "dvd" ]]; then
    make_dummy
fi

# do submenu 1st for debug purposes
if $SUB_MENU; then
    yecho
    yecho "Building submenus"
    yecho
    yecho "Creating images for each chapter"
    if [ -z "$SM_TITLES" ]; then
        if $MULTILINE_TITLE; then
            for i in ${!TITLES[@]}; do
                SM_TITLES[i]="${TITLES[i]//\\n/ }"
            done
        else
            SM_TITLES=("${TITLES[@]}")
        fi
    fi
    for ((i=0; i<${#IN_FILES[@]}; i++)); do
        C=$((${CHAPTERS[i]} - 1))
        yecho "Creating a transparent title PNG"
        convert -size 620x300 xc:none -font "$MENU_FONT" \
        -pointsize $MENU_FONTSIZE \
        -fill "$SM_TITLE_COLOUR" -draw "gravity center text 2,2 \"${SM_TITLES[i]}\"" \
        -stroke "$SUBMENU_STROKE" -strokewidth 1 \
        -fill "$SM_TITLE_COLOUR" -stroke "$SUBMENU_STROKE" \
        -draw "gravity center text 1,1 \"${SM_TITLES[i]}\"" miff:- | \
        convert -trim +repage - -blur 0x0.4 $WORK_DIR/title${i}_txt.png 2>/dev/null

        # which is harmless as they get removed, but needs to be tweaked
        if $ANI_SUB_MENU; then
            JPEG2YUV_OPTS=(-n $ANI_SUBMENU_FRAMES)
            PICS_IN=($WORK_DIR/animenu/%0d.$SM_IMG_FMT)
            PICS_OUT=($WORK_DIR/animenu/)
            CUT_TIME=340
            JPEG_DIR="$WORK_DIR/animenu"
            SLEEP=1
            TOTAL_JPEGS=$((340 * ${CHAPTERS[i]}))

        else  # not animated submenu
            if [[ -n "$SUBMENU_AUDIOLENGTH" ]]; then
                SM_LOOPS=$( bc <<< "$SUBMENU_AUDIOLENGTH * $FRAME_RATE" 2>/dev/null)
                SM_LOOPS=${SM_LOOPS%.*}
            else
                SM_LOOPS=60
            fi
            JPEG2YUV_OPTS=(-n 1 -l $SM_LOOPS)
            PICS_IN=($WORK_DIR/${i}-submenu.$SM_IMG_FMT)
            PICS_OUT=($WORK_DIR/submenu/)
            CUT_TIME=1
            JPEG_DIR="$WORK_DIR/submenu"
            SLEEP=.5
            TOTAL_JPEGS=${CHAPTERS[i]}
            PREFIX=${i}-
        fi
        # CHAPT_INTERVALS is in seconds: bc -l <<< "${VID_LEN[i]} / ${CHAPTERS[i]}"
        counts=$(bc_math "${CHAPT_INTERVALS[i]} * $FRAME_RATE" int)
        CUT=( 30 $(running_total <<<  $(for ((a=0; a<${CHAPTERS[i]} ; a++)); \
        do echo -n "$counts ";done)) )
        if $USER_CHAPTERS; then
            unset x CUT c_array
            # CHAPT_ARRAY is left in HH:MM:SS,HH:MM:SS, format, so unformat now
            c_array="${CHAPT_ARRAY[i]//,/ }"
            for v in $c_array; do
                f=$(unformat_time $v)
                CUT[x++]=$( bc_math "$f * $FRAME_RATE" int)
            done 
            # add a final chapter on, it will get removed below
            CUT[${#CUT[@]}]=$( bc_math "((${VID_LEN[i]} * $FRAME_RATE )  - 340)" int )
        fi
        for ((c=0; c<${#CUT[@]}; c++)); do
            cmd[c]=${CUT[c]}-$(bc_math "${CUT[c]} + $CUT_TIME" int)
        done
        key=$((${#cmd[@]} - 1))
        unset cmd[key]
        if [ -s  "${IN_FILES[i]}".nav_log ]; then
            NAV_SEEK[i]="--nav_seek"
            NAVSEEK[i]="${IN_FILES[i]}.nav_log"
        fi
        yecho
        yecho "Creating $TOTAL_JPEGS chapter images for "${IN_FILES[i]}""
        yecho
        for t in "${cmd[@]}"; do
            TCODE_CMD=(nice transcode --print_status 10 --write_pid $WORK_DIR/tcode$i.pid \
            -q 1 -i "${IN_FILES[i]}"  ${NAV_SEEK[i]} "${NAVSEEK[i]}" \
            -o "${PICS_OUT[@]}" -f $FRAME_RATE -Z ${GEO_ARRAY[C]},fast -c $t -y $SM_IMG_FMT,null)
            echo "Running ${TCODE_CMD[@]}" |
            sed 's/    */ /g'|sed -e "s/^ *//"|fold -bs|tee -a "$LOG_FILE"
            echo
            function run_transcode()
            {
                "${TCODE_CMD[@]}" >> "$LOG_FILE"  2>&1
                sleep 1
            }
            run_transcode &
            sleep 2 # short sleep to allow 1st jpg to appear
            TCODE_PID=$(<$WORK_DIR/tcode$i.pid)
            check_stall $TCODE_PID &
            if [[ -n "$TCODE_PID" ]]; then
                while ps -p $TCODE_PID >/dev/null; do
                    sleep $SLEEP # spinner interval
                spin "Seeking in video and creating images: $(find "$JPEG_DIR" \
            -maxdepth 1 -name \*.jpg|sort|awk -F / '{ field = $NF }; END{ print field }')"
                done
                echo

                echo "Created $(find "$JPEG_DIR" -maxdepth 1 -name \*.jpg|wc -l) JPEGS of $TOTAL_JPEGS"
            else
                runtime_error "Problem creating images from the video."
            fi
            unset TCODE_CMD cmd run_transcode
            if ! $ANI_SUB_MENU ; then
                echo
                mv $WORK_DIR/submenu/000000.$SM_IMG_FMT \
                $WORK_DIR/submenu/$(printf "%08d%s\n" ${t%-*} .$SM_IMG_FMT)
            elif $ANI_SUB_MENU; then
                echo "renaming images by frame number"
                echo
                u=${t/*-}; v=${t/-*}
                for ((n=0; n<340; n++)); do
                    
                    if [ $v -eq ${CUT[0]} ]; then
                        mv  $WORK_DIR/animenu/$(printf "%06d%s\n" $n .jpg) \
                        $WORK_DIR/animenu/$(printf "%08d%s\n" $((n + ${CUT[0]} )) .jpg)
                    else
                        mv  $WORK_DIR/animenu/$(printf "%06d%s\n" $n .jpg) \
                        $WORK_DIR/animenu/$(printf "%08d%s\n" $((n+v)) .jpg)
                    fi
                done
            fi
        done
            if $ANI_SUB_MENU ; then
                # move 340 images to each subdir:  $WORK_DIR/animenu/{0,1,2,3,etc}
                echo "moving images into subdirectories"
                for ((a=0; a<${CHAPTERS[i]}; a++)); do
                    # 2>/dev/null to work around perplexing spawned xterm bug
                    pics=( $(find $WORK_DIR/animenu/ -maxdepth 1 -name 00\*.$SM_IMG_FMT | sort 2>/dev/null|head -n 340 2>/dev/null) )
                    echo "${pics[@]}" >> "$WORK_DIR/pics.log"
                    for f in ${pics[@]}; do
                        mv "$f" $WORK_DIR/animenu/$a
                    done
                    unset pics
                done
                for ((a=0; a<${CHAPTERS[i]}; a++)); do
                    find $WORK_DIR/animenu/$a/ -name 00\*.$SM_IMG_FMT |
                    sort| head -n 20|xargs rm -f
                    find $WORK_DIR/animenu/$a/ -name 00\*.$SM_IMG_FMT |
                    sort|tail -n 20|xargs rm -f
                done
                # clean up left over pics in animenu/ dir
#                rm -f $WORK_DIR/animenu/*.$SM_IMG_FMT
            fi

        if $ANI_SUB_MENU; then
            echo
            echo "Making 300 montage images for "${IN_FILES[i]}""

            for ((a=1; a<300; a++)); do
                spin "\rProcessing "$a.$SM_IMG_FMT"  "
                for ((b=0; b<${CHAPTERS[i]}; b++)); do
                    IMGS=( "${IMGS[@]}" $(find $WORK_DIR/animenu/$b \
                    -name \*.$SM_IMG_FMT| sort 2>/dev/null | head -n $a | sed -n -e "$a p") )
                done
                IM_CMD=(montage ${IMGS[@]} -tile ${TILE_ARRAY[C]} \
                -geometry ${GEO_ARRAY[C]}+5+5 -bordercolor '#161514' \
                -mattecolor '#161514' -background '#161514' miff:-)
                IM_CMD2=(convert $WORK_DIR/submenu_template.jpg \
                $WORK_DIR/title${i}_txt.png  -gravity south \
                -geometry +0+55 -composite -  -gravity north -geometry +0+45 \
                -composite $WORK_DIR/animenu/$a.$SM_IMG_FMT)
                "${IM_CMD[@]}" | "${IM_CMD2[@]}"
                unset IMGS
            done

            unset IM_CMD IM_CMD2 d f PIC

        else # not $ANI_SUB_MENU

            yecho
            yecho "Making montage images for "${IN_FILES[i]}""
            # just use $CHAPTERS number of images
            imgs=( $(find $WORK_DIR/submenu -name \*.$SM_IMG_FMT |
            sort| head -n ${CHAPTERS[i]}) )
            # create frames for the chapter thumbs
            for PIC in "${imgs[@]}"; do
            spin "\rProcessing $(awk -F / '{ print $NF }' <<< "$PIC")  "
                convert -background '#141614' -frame 3x3 \
                -bordercolor none -mattecolor "#444744" "$PIC" miff:- |
                convert -resize "${GEO_ARRAY[C]}"! - "$PIC"
            done

            IM_CMD=(montage "${imgs[@]}" -tile ${TILE_ARRAY[C]} -geometry \
            ${GEO_ARRAY[C]}+5+5 -background '#141614' miff:-)
            IM_CMD2=(convert $WORK_DIR/submenu_template.jpg \
            $WORK_DIR/title${i}_txt.png  -gravity south -geometry +0+55 \
            -composite - -gravity north -geometry +0+45 -composite \
            $WORK_DIR/${i}-submenu.$SM_IMG_FMT)
            "${IM_CMD[@]}" | "${IM_CMD2[@]}"
        fi

        yecho
        yecho "Converting chapter montages of "${IN_FILES[i]}" to m2v video format"
        IMG_STREAM_CMD1=(jpeg2yuv -v 0 -f $FRAME_RATE -I p \
        "${JPEG2YUV_OPTS[@]}" -L 1 -b 1  -j "${PICS_IN[@]}")
        ENC_CMD1=(ffmpeg   -f yuv4mpegpipe -i - -r $FRAME_RATE -s $VIDSIZE \
        -tvstd $TV_STANDARD $FFMPEG_OPTS -y "$WORK_DIR/menu$i.m2v")
        echo "Running "${IMG_STREAM_CMD1[@]}" | "${ENC_CMD1[@]}""|format_output | tee -a "$LOG_FILE" 2>&1
        if ! "${IMG_STREAM_CMD1[@]}" | "${ENC_CMD1[@]}" 2>&1|strings >> "$LOG_FILE"; then
            runtime_error
        fi

        # check if m2v was created ok before proceeding
        if mencoder -quiet -oac pcm -ovc copy -frames 0 \
        "$WORK_DIR/menu$i.m2v" -o /dev/null &>/dev/null; then
            :
        else
            echo
            runtime_error  \
            "The submenu video (m2v) does not appear to have been created"
        fi
        # clean out submenu dirs of images
        echo "Cleaning up leftover pics in $REAL_WORK_DIR/animenu"
        rm -f $WORK_DIR/submenu/*
        find $WORK_DIR/animenu/ -maxdepth 1 -type f -exec rm -f {} \;
        if $ANI_SUB_MENU; then
            find $WORK_DIR/animenu/[0-9]/ -type f -exec rm -f {} \;
        fi
    done
    unset IMG_STREAM_CMD1 ENC_CMD1 JPEG2YUV_OPTS
    for ((s=0; s<=NUM_FILES; s++)); do
        # create audio background for either animated or plain submenus
        yecho
        yecho "Creating an audio background"
        yecho "Working on submenu audio for "${IN_FILES[s]}""
        if $SUBMENU_AUDIO; then # user supplied audio file for ths video
            if ! $ANI_SUB_MENU ; then  # if static, see if length option given
                [[ -n "$SUBMENU_AUDIOLENGTH" ]] && TIME=$SUBMENU_AUDIOLENGTH
                if [[ -n "$SM_AUDIO_FILE" ]]; then # one audio file for all menus
                    TIME_TMP=$(audio_length "$SM_AUDIO_FILE")
                else # audio will be different for each menu
                    TIME_TMP=$(audio_length "${SM_AUDIO[s]}")
                fi
            else # if animated, get time from video instead of the audio file
                TIME_TMP=$(vid_length "$WORK_DIR/menu$s.m2v")
            fi
            # if length option is supplied, we use that, else use $TIME_TMP
            TIME=${TIME:-$TIME_TMP}
            # silence only need be the length of the static menu
            if [ "${SM_AUDIO[s]}" = "none" ]; then # user asked for silence
                TIME=$(vid_length "$WORK_DIR/menu$s.m2v")
                BGAUDIO_CMD=(ffmpeg -f s16le -i /dev/zero -t $TIME \
                $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT)
            elif [[ -n "$SM_AUDIO_FILE" ]]; then # user supplied "1" audio file
                COPY_AC3=(cp -v $WORK_DIR/submenu.$AUDIO_EXT \
                $WORK_DIR/menu$s.$AUDIO_EXT)
                BGAUDIO_CMD=(ffmpeg -i "$SM_AUDIO_FILE" -t $TIME -ar 48000 \
                -ac 2 -acodec pcm_s16le -y $WORK_DIR/submenu.wav)
            else # SM_AUDIO[s] is an audio file we will process it
                # make separate wavs for each supplied audio bg for each submenu
                BGAUDIO_CMD=(ffmpeg -i "${SM_AUDIO[s]}" -t $TIME -ar 48000 \
                -ac 2 -acodec pcm_s16le -y $WORK_DIR/menu$s.wav)
                BGAUDIO_CMD2=(ffmpeg -i $WORK_DIR/menu$s.wav \
                $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT)
            fi
        else # no supplied audio for submenu so create silence
            TIME=$(vid_length "$WORK_DIR/menu$s.m2v")
            BGAUDIO_CMD=(ffmpeg -f s16le -i /dev/zero -t $TIME \
            $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT)
        fi
        if [ ! -s $WORK_DIR/submenu.wav ]; then # only run if no wav
            yecho "Running "${BGAUDIO_CMD[@]}"" |fold -bs >> "$LOG_FILE"
            # run command, error out if problem
            ! "${BGAUDIO_CMD[@]}" 2>&1 |strings >> "$LOG_FILE" 2>&1 && runtime_error
        fi
        # convert to DVD/SVCD format as long as not "none" or single audio file
        if $SUBMENU_AUDIO && [[ ! "${SM_AUDIO[s]}" = "none" && -z "$SM_AUDIO_FILE" ]]; then
            if $SM_AUDIO_FADE; then
                TIME=$(audio_length "$WORK_DIR/menu$s.wav")
                echo -e "Running:
                sox $WORK_DIR/menu$s.wav \
                $WORK_DIR/menu$s-processed.wav fade t $SM_FADE $TIME $SM_FADE" |
                sed 's/    */ /g'|sed -e "s/^ *//"
                sox -q $WORK_DIR/menu$s.wav \
                $WORK_DIR/menu$s-processed.wav fade t $SM_FADE $TIME $SM_FADE
                rm $WORK_DIR/menu$s.wav
                mv $WORK_DIR/menu$s-processed.wav $WORK_DIR/menu$s.wav
            fi
            echo "Running "${BGAUDIO_CMD2[@]}"" | fold -bs >> "$LOG_FILE"
            ! "${BGAUDIO_CMD2[@]}" 2>&1 |strings >> "$LOG_FILE" && runtime_error
            unset TIME
        fi
        # if "1" audio file, then convert it if it has not been done yet
        if [[ -n "$SM_AUDIO_FILE" && ! -s $WORK_DIR/submenu-processed.wav ]]; then
            if $SM_AUDIO_FADE; then
                TIME=$(audio_length "$WORK_DIR/submenu.wav")
                echo -e "Running:
                sox $WORK_DIR/submenu.wav \
                $WORK_DIR/submenu-processed.wav fade t $SM_FADE $TIME $SM_FADE" |sed 's/    */ /g'

                sox -q $WORK_DIR/submenu.wav \
                $WORK_DIR/submenu-processed.wav fade t $SM_FADE $TIME $SM_FADE
                rm -f $WORK_DIR/submenu.wav
                cp  $WORK_DIR/submenu-processed.wav $WORK_DIR/submenu.wav
            fi
            BGAUDIO_CMD3=(ffmpeg -i $WORK_DIR/submenu.wav \
            $AUDIO_OPTS -y $WORK_DIR/submenu.$AUDIO_EXT)
            if [ -s $WORK_DIR/submenu.$AUDIO_EXT ]; then # if file exists do nothing
                :
            else
                echo "Running "${BGAUDIO_CMD3[@]}"" >> "$LOG_FILE.tmp" 2>&1
                ! "${BGAUDIO_CMD3[@]}" 2>&1 |strings >> "$LOG_FILE" && runtime_error
            fi
        fi
        # copy the final file for each submenu if only 1 supplied
        "${COPY_AC3[@]}"
        yecho
        yecho "Multiplexing video and audio together"
        S=$((s + 1))
        MPLEX_CMD=(mplex -V -f $MPLEX_FORMAT -o $WORK_DIR/menu$S.mpg \
        $WORK_DIR/menu$s.$AUDIO_EXT $WORK_DIR/menu$s.m2v)
        echo "Running: "${MPLEX_CMD[@]}"" | fold -bs >> "$LOG_FILE"
        ! "${MPLEX_CMD[@]}" 2>&1 |strings >> "$LOG_FILE"  && runtime_error
        # remove wav to save space
        rm -fv $WORK_DIR/menu$s.wav
    done
    rm -fv $WORK_DIR/submenu.{wav,$AUDIO_EXT}
    rm -fr $WORK_DIR/animenu/*
fi

##############################################################################
#                      Work on main menu                                     #
##############################################################################
if $DO_MENU; then
    yecho
    yecho "Building main menu"
fi
if [[ -n "$BG_VIDEO" ]] && ! $QUICK_MENU; then
    yecho "Getting background video from $BG_VIDEO"
    FFMPEG_CMD="ffmpeg -i \"$BG_VIDEO\" -ss $BG_SEEK -vframes $FRAMES \
    -s $VIDSIZE -sameq \"$WORK_DIR/bg/%d.jpg\""
    yecho "Extracting/resizing background images with the following command:"
    yecho "$FFMPEG_CMD"
    # Filter ffmpeg output
    LOG_FILTER="sed s/\\r/\\r\\n/g"
    # Run command and check for failure
    if ! cmd_exec "$FFMPEG_CMD"; then
        runtime_error "Problem creating images from the background video"
    fi
    # make sure there are enough pics to make a bg video
    IMAGES=( "${IMAGES[@]}" \
    $(find $WORK_DIR/bg -maxdepth 1 -name \*[1-9]\*.jpg|sort) )
    last_pic=${#IMAGES[@]}
    next_pic=$(($last_pic + 1))
    if [ $last_pic -lt $MAX_MENU_LEN ]; then
        for ((l=next_pic; l<=MAX_MENU_LEN; l++)); do
            cp $WORK_DIR/bg/${last_pic}.jpg $WORK_DIR/bg/$l.jpg
        done
    fi
    unset IMAGES PICS last_pic next_pic
fi
#if [ -n "$SHOWCASE_VIDEO" ] && $SC_THUMB; then
if [[ -n "$SHOWCASE_VIDEO" ]] && $SC_THUMB; then
    echo "Getting showcase video images from $SHOWCASE_VIDEO"
    if [ "$SC_FRAMESTYLE" = "glass" ]; then
        FIND_FRAMES=$((FRAMES + 1)) # unfortunately mplayer starts at 1 not 0
        # some vars for get_framed_pics()
        D=2
        FRAME_SIZE=$SHOWCASE_SIZE
        VOUT="png:z=7"
        MPLAYER_SEEK_VAL=$SHOWCASE_SEEK_VAL
        $SWITCHED_MODE && MPLAYER_SEEK_VAL=${SEEK_VAL[MENU_NUM-1]}
        get_framed_pics "$SHOWCASE_VIDEO"  >> "$LOG_FILE" 2>&1
        for ((i=1; i<=$FIND_FRAMES; i++)); do
            mv  "$WORK_DIR"/$(printf "%08d%s"  $i .png) \
            "$WORK_DIR"/showcase/$(printf "%06d%s"  $i .png) 2>/dev/null
        done
    elif [ "$SC_FRAMESTYLE" = "none" ]; then
        if $SWITCHED_MODE; then
            FFMPEG_SEEK_VAL=${SEEK_VAL[MENU_NUM-1]}
        else
            FFMPEG_SEEK_VAL=$SHOWCASE_SEEK_VAL
        fi

        FIND_FRAMES=$FRAMES # ffmpeg starts at 0
        FFMPEG_CMD=(ffmpeg -i "$SHOWCASE_VIDEO" -ss $FFMPEG_SEEK_VAL \
        -s $SHOWCASE_SIZE -vframes $FRAMES -an -y "$WORK_DIR/showcase/%06d.png")
        echo -e "\nRunning: "${FFMPEG_CMD[@]}"\n" | fold -bs >> "$LOG_FILE"
        SED_VAR="frame="
        if ! "${FFMPEG_CMD[@]}" 2>&1 |strings >> "$LOG_FILE";then
            runtime_error "Problem creating images from the video."
        fi
    fi

    for ((i=0; i<$FRAMES; i++)); do
        SC_PICS=( ${SC_PICS[@]} $(find $WORK_DIR/showcase -maxdepth 1  -name $(printf "%06d%s"  $i .png) ) )
    done
    if [[ "$SC_FRAMESTYLE" = "glass" ]] &&  [[ -z "$ROTATE" && -z "$WAVE" ]]; then
        :
    else
        for pic in "${SC_PICS[@]}"; do
            spin "\rProcessing $(awk -F / '{ print $NF }' <<< "$pic") of $FRAMES  "
            SC_CMD=(convert -resize $SHOWCASE_SIZE! "$pic" -mattecolor gray $SC_FRAME)
            SC_CMD1=(convert "$pic" -background none $ROTATE $WAVE)
            SC_CMD2=(convert -background none $ROTATE $WAVE -)
            SC_CMD3=(convert - -resize $SHOWCASE_SIZE! "$pic")
            # if glass and either wave or rotate
            if [ "$SC_FRAMESTYLE" = "glass" ] && [[ -n "$WAVE" || -n "$ROTATE" ]]; then
                "${SC_CMD1[@]}" miff:- | "${SC_CMD3[@]}"
            # if glass and neither wave or rotate
            elif [ "$SC_FRAMESTYLE" = "glass" ] && [[ -z "$WAVE" && -z "$ROTATE" ]]; then
                :
            else # not glass
                "${SC_CMD[@]}" miff:- | "${SC_CMD2[@]}" miff:- | "${SC_CMD3[@]}"
            fi
        done
    fi
    # make sure showcase video finishes at the time time as other menu items
    IMAGES=( $(find $WORK_DIR/showcase -maxdepth 1 -name 00\*.png|sort) )
    last_pic=$(( ${#IMAGES[@]} - 1 ))
    next_pic=$(($last_pic + 1))
    if [ $last_pic -lt $MAX_MENU_LEN ] && ! $STATIC; then
        for ((l=next_pic; l<=MAX_MENU_LEN; l++)); do
            cp $WORK_DIR/showcase/$( printf %06d $last_pic).png \
            $WORK_DIR/showcase/$(printf %06d $l).png
        done
    fi

fi
unset IMAGES last_pic next_pic FFMPEG_CMD pic

yecho
if [[ ! "$SC_FRAMESTYLE" = "glass" && ! $TEXTMENU ]]; then
    if $SHOWCASE; then
        yecho "Processing video images"
    else
        yecho "Adding title to video images and resizing"
    fi
fi
if ! $TEXTMENU && $DO_MENU && $DO_FRAME; then
    for ((i=0; i<=NUM_FILES; i++)); do
        if $FEATHER && $THUMBS_3D && [ "$THUMB_SHAPE" != "normal" ]; then
            unset CURVE_ARRAY CURVE_VALUES CURVE_VARS
            CURVE_VARS="5 3 5 1 1"
            . todisc-fade-routine "3 5 5 1 1"
        fi
        PICS=( "${PICS[@]}" \
        $(find $WORK_DIR/pics/$i -maxdepth 1 -name \*[0-9]\*.$IMG_FMT|sort) )
        echo
        yecho "Working on ${#PICS[@]} images from ${IN_FILES[i]}"
        for ((p=0; p<${#PICS[@]}; p++)); do
            unset IM_CMD6
            [[ -n ${ROTATE_ARRAY[@]} ]] && THUMB_ROTATE="-background none -rotate ${ROTATE_ARRAY[i]}"
            IM_CMD=(composite -compose CopyOpacity $THUMB_MASK +matte "${PICS[p]}")
            IM_CMD0=(montage -  -geometry +4+4 -compose Copy -background none \
            -fill "$THUMB_TEXT_COLOUR" -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE -title "${TITLES[i]}")
            IM_CMD01=(convert -background '#161514' -frame 3x3 \
            -bordercolor none -mattecolor "#444744" "${PICS[p]}")
            IM_CMD02=(convert "${PICS[p]}" $RAISE)
            IM_CMD03=(composite -compose CopyOpacity $THUMB_MASK +matte -)
            IM_CMD04=(montage - -geometry +4+4 -background '#444744' \
            -mattecolor "#444744" -fill "$THUMB_TEXT_COLOUR" -font "$THUMB_FONT" \
            -pointsize $THUMB_FONTSIZE -title "${TITLES[i]}")
            IM_CMD1=(convert -resize ${THUMB_SIZE}! -)
            IM_CMD2=(composite -gravity center -compose DstOver $WORK_DIR/feather_mask2.png -)
            IM_CMD3=(montage -geometry +4+4 -background '#444744' \
            -fill "$THUMB_TEXT_COLOUR" -font "$THUMB_FONT" \
            -pointsize $THUMB_FONTSIZE -title "${TITLES[i]}" "${PICS[p]}")
            IM_CMD4=(convert -background none -frame 3x3 \
            -bordercolor "#444744" -)
            IM_CMD4b=(convert -background none -frame 3x3 \
            -bordercolor none -)
            IM_CMD5=(convert - $THUMB_ROTATE -resize ${THUMB_SIZE}! "${PICS[p]}")
            IM_CMD6=(convert - -write mpr:img${p} -fx A  +matte \
            -blur 0x$( LC_ALL="C" bash -c "printf "%.2f" $(bc_math "7 + .${CURVE_ARRAY[p]/.}")" )  \
            -shade $(bc_math "115 + ${CURVE_ARRAY[p]}")x30 -normalize mpr:img${p} \
            -compose Overlay -composite mpr:img${p} -matte -compose Dst_In -composite)
            IM_CMD7=(convert -trim +repage - )
            if $FEATHER &&  [ "$THUMB_SHAPE" != "normal" ] && $THUMBS_3D; then
                CURVE_UPDATE="with -blur 0x$( LC_ALL="C" bash -c "printf  "%.2f" $(bc_math "7 + .${CURVE_ARRAY[p]/.}")" ) \
                -shade $( LC_ALL="C" bash -c "printf "%.2f" $(bc_math "115 + ${CURVE_ARRAY[p]}")" )x30"
            fi
            if $FEATHER; then
                spin "\rProcessing $(awk -F / '{ print $NF }' <<< "${PICS[p]}") \
                $(echo $CURVE_UPDATE | format_output) "
                if $SHOWCASE; then
                    if $THUMBS_3D; then
                        if [ "$THUMB_SHAPE" != "normal" ]; then # normal has $RAISE
                            "${IM_CMD[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
                            "${IM_CMD6[@]}" miff:- |  "${IM_CMD7[@]}" miff:- |
                            "${IM_CMD5[@]}"
                        else # normal thumbshape, with feather and 3D
                            "${IM_CMD02[@]}" miff:- | "${IM_CMD03[@]}" miff:- |
                            "${IM_CMD2[@]}" miff:- |"${IM_CMD7[@]}" miff:- |
                            "${IM_CMD5[@]}"

                        fi
                    else
                        "${IM_CMD[@]}" miff:- | "${IM_CMD2[@]}" miff:- |"${IM_CMD5[@]}"
                    fi
                else # not SHOWCASE
                    if $THUMBS_3D; then
                        if [ "$THUMB_SHAPE" != "normal" ]; then
                            "${IM_CMD[@]}" miff:- | "${IM_CMD6[@]}" miff:- |
                            "${IM_CMD1[@]}" miff:- |"${IM_CMD0[@]}" miff:- |
                            "${IM_CMD1[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
                            "${IM_CMD5[@]}"
                        else
                            "${IM_CMD02[@]}" miff:- | "${IM_CMD0[@]}" miff:- |
                            "${IM_CMD1[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
                            "${IM_CMD5[@]}"
                        fi
                    else # not 3D
                        "${IM_CMD[@]}" miff:- | "${IM_CMD0[@]}" miff:- |
                        "${IM_CMD1[@]}" miff:- |"${IM_CMD2[@]}" miff:- |
                        "${IM_CMD5[@]}"
                    fi
                fi
            else # not FEATHER
                if $SHOWCASE; then # showcase but not feather
                    if [[ "$SC_FRAMESTYLE" = "glass" && -z ${ROTATE_ARRAY[@]} ]]; then
                        :
                    else
                        spin "\rProcessing $(awk -F / '{ print $NF }' <<< "${PICS[p]}")  "
                        if $THUMBS_3D; then
                            "${IM_CMD02[@]}" miff:- | "${IM_CMD5[@]}"
                        else
                            "${IM_CMD01[@]}" miff:- | "${IM_CMD5[@]}"
                        fi
                    fi
                else # not showcase or feather
                    spin "\rProcessing $(awk -F / '{ print $NF }' <<< "${PICS[p]}")  "
                    if $THUMBS_3D; then
                        "${IM_CMD02[@]}" miff:- |"${IM_CMD04[@]}" miff:- |
                        "${IM_CMD4b[@]}" miff:- | "${IM_CMD5[@]}"
                    else
                        "${IM_CMD3[@]}" miff:- | "${IM_CMD4[@]}" miff:- |
                        "${IM_CMD5[@]}"
                    fi
                fi
            fi
            if $STATIC; then unset PICS; fi
            unset IM_CMD0 IM_CMD1 IM_CMD2 IM_CMD3 IM_CMD4 IM_CMD5 IM_CMD6
        done
        # make sure all animated thumbs finish at the same time
        if ! $STATIC; then
            IMAGES=( "${IMAGES[@]}" \
            $(find $WORK_DIR/pics/$i -maxdepth 1 -name 00\*.$IMG_FMT|sort) )
            last_pic=$(( ${#IMAGES[@]} - 1 ))
            next_pic=$(($last_pic + 1))
            if [ $last_pic -lt $MAX_MENU_LEN ]; then
                for ((l=next_pic; l<=MAX_MENU_LEN; l++)); do
                    cp $WORK_DIR/pics/$i/$( printf %06d $last_pic).$IMG_FMT \
                    $WORK_DIR/pics/$i/$(printf %06d $l).$IMG_FMT
                done
            fi
            unset IMAGES last_pic next_pic
        fi
        unset PICS
    done
fi
if ! $MENU_FADE && ! $QUICK_MENU && $DO_MENU; then
    yecho
    yecho "Making $FRAMES final montages and compositing onto background with title"
    yecho
fi
if $MENU_FADE && ! $STATIC && ! $QUICK_MENU; then
    . todisc-fade-routine
    yecho
    yecho "Creating background fade"
    yecho
    if [ -z "$BG_VIDEO" ]; then
        for ((frame=0; frame<=ANI_MENU_END_FRAME; frame++)); do
            # copy template for fade out beginning and end frames
            cp $WORK_DIR/pics/template.jpg $WORK_DIR/bg/$(($frame + 1)).jpg
        done
    fi
    for ((frame=0; frame<=BACKGROUND_FADE_IN_END_FRAME; frame++)); do
        D=`get_bg_opacity`
        composite -dissolve $D $WORK_DIR/bg/$(($frame + 1)).jpg $WORK_DIR/black.jpg \
        $WORK_DIR/bg/$(($frame + 1)).jpg
    done
    yecho
    yecho "Making $FRAMES final montages and compositing onto background with title"
    yecho
    for ((frame=BACKGROUND_FADE_OUT_START_FRAME; frame<BACKGROUND_FADE_OUT_END_FRAME; frame++)); do
        D=`get_bg_opacity`
        composite -dissolve $D $WORK_DIR/bg/$(($frame + 1)).jpg $WORK_DIR/black.jpg \
        $WORK_DIR/bg/$(($frame + 1)).jpg
    done
    for ((frame=0; frame<ANI_MENU_END_FRAME; frame++)); do
        # set dissolve vars from todisc-fade-routine functions
        BC=$(get_title_opacity)
        B=$(awk -F ':' '{print $1'}<<<$BC)
        C=$(awk -F ':' '{print $2'}<<<$BC)
        S=$(get_thumb_opacity)

        spin  "\rProcessing "$(($frame + 1)).jpg"  "

        for ((cnt=0; cnt<=NUM_FILES; cnt++)); do
            ANI_PICS=( "${ANI_PICS[@]}" $(find $WORK_DIR/pics/$cnt  -name $(printf "%06d%s"  $((frame + 1)) .$IMG_FMT) ) )
        done
        if $SHOWCASE; then
            if ! $TEXTMENU; then
                for ((i=0; i<${#ANI_PICS[@]}; i++)); do
                    sc_cmd=( ${sc_cmd[@]} ${SHOWCASE_THUMB_PAGES[i]} "${ANI_PICS[i]}")
                done
            fi
            if $SC_THUMB; then
                SC_VIDEO_CMD="$SC_IMG_PAGE \
                "$WORK_DIR"/showcase/$(printf "%06d%s"  $(($frame + 1)) .png)"
            else
                unset SC_VIDEO_CMD
            fi
        fi
        $TEXTMENU && unset sc_cmd
        ! $TEXTMENU && MOSAIC="-mosaic"
        BG_PIC=$(find $WORK_DIR/bg -name $(($frame + 1)).jpg)
        # create the montage from the images in each video dir
        MONTAGE_CMD=(convert  -size $VIDSIZE -background none \
        ${sc_cmd[@]} $SC_IMG_CMD $MOSAIC)
        MONTAGE_CMD0=(convert  -size $VIDSIZE "$WORK_DIR/pics/template.png" \
        ${sc_cmd[@]} $SC_VIDEO_CMD $MOSAIC $WORK_DIR/animenu/$(($frame + 1)).jpg)
        MONTAGE_CMD01=(convert  -size $VIDSIZE xc:none -background none \
        ${sc_cmd[@]} $SC_VIDEO_CMD $MOSAIC)
        MONTAGE_CMD02=(convert -size $VIDSIZE -background none \
        - ${sc_thumb_title_cmd[@]} -mosaic)
        MONTAGE_CMD03=(convert -size $VIDSIZE -background none \
        ${sc_thumb_title_cmd[@]} -mosaic)
        MONTAGE_CMD1=(montage "${ANI_PICS[@]}" -tile ${TILE_ARRAY[NUM_FILES]} \
        -geometry ${THUMB_SIZE}${MTG_GEO} -background none)
        #  dissolve the finished montages onto the background
        MONTAGE_CMD2=(composite -dissolve $S -gravity $BUTTON_GRAVITY \
        -geometry +${XGEO}+${YGEO} - $WORK_DIR/bg/$(($frame + 1)).jpg -background none)
        MONTAGE_CMD2b=(composite -size $VIDSIZE -background none \
        -gravity NorthWest  -dissolve $S - $WORK_DIR/bg/$(($frame + 1)).jpg \
        -background none  $WORK_DIR/animenu/$(($frame + 1)).jpg)
        MONTAGE_CMD2c=(composite -size $VIDSIZE -background none \
        -gravity NorthWest  -dissolve $S - $WORK_DIR/bg/$(($frame + 1)).jpg \
        -background none)
        # if MIST is called for, this dissolves the mist onto the background
        MONTAGE_CMD3=(composite -dissolve $B -gravity $TITLE_GRAVITY \
        -geometry ${mist_xoffset}${mist_yoffset} $WORK_DIR/white.png -)
        # finally, we dissolve the title onto the MIST (or plain background)
        MONTAGE_CMD4=(composite -dissolve $C -gravity $TITLE_GRAVITY -geometry \
        ${title_xoffset}${title_yoffset} $WORK_DIR/title_txt.png - \
        -background none $WORK_DIR/animenu/$(($frame + 1)).jpg)
        if $PLAYALL ; then
            MONTAGE_CMD5=(composite -dissolve $S -gravity SouthEast \
            -geometry $PLAYALL_BTN_OFFSETS "$WORK_DIR/Playall.png" - -background none)
        else
            MONTAGE_CMD5=(convert -)
        fi
        if $TITLESET_MODE && ! $VMGM_ONLY && $VMGM_MENU; then
            MONTAGE_CMD6=(composite -dissolve $S -gravity SouthEast \
            -geometry $RTN_BTN_GRAVITY $RTN_BTN_OFFSETS \
            "$WORK_DIR/Main.png" - -background none)
        else
            MONTAGE_CMD6=(convert -)
        fi
 
        $TEXTMENU && unset MONTAGE_CMD
        $TEXTMENU && MONTAGE_CMD=( "${MONTAGE_CMD03[@]}" )
        # pipe all of above commands if using MIST
        if $MIST; then
            if $SHOWCASE; then
                if [[ -n "$SHOWCASE_VIDEO" ]]; then
                    "${MONTAGE_CMD01[@]}" miff:- | "${MONTAGE_CMD02[@]}" miff:- |
                    "${MONTAGE_CMD2c[@]}" miff:- | "${MONTAGE_CMD3[@]}" miff:- |
                    "${MONTAGE_CMD5[@]}" miff:- | "${MONTAGE_CMD6[@]}" miff:- |
                    "${MONTAGE_CMD4[@]}"
                else # not SHOWCASE_VIDEO (SHOWCASE_IMG)
                    "${MONTAGE_CMD[@]}" miff:- | "${MONTAGE_CMD02[@]}" miff:- |
                    "${MONTAGE_CMD2c[@]}" miff:- |  "${MONTAGE_CMD5[@]}" miff:- |
                    "${MONTAGE_CMD6[@]}" miff:- | "${MONTAGE_CMD3[@]}" miff:- |
                    "${MONTAGE_CMD4[@]}"
                fi
            else # not SHOWCASE
                "${MONTAGE_CMD1[@]}" miff:- | "${MONTAGE_CMD2[@]}" miff:- |
                "${MONTAGE_CMD3[@]}" miff:- | "${MONTAGE_CMD5[@]}" miff:- |
                "${MONTAGE_CMD6[@]}" miff:- | "${MONTAGE_CMD4[@]}"
            fi
        else  # no mist: pipe all commands but the mist command
            if $SHOWCASE; then
                if [[ -n "$SHOWCASE_VIDEO" ]]; then
                    "${MONTAGE_CMD01[@]}" miff:- | "${MONTAGE_CMD02[@]}" miff:- |
                    "${MONTAGE_CMD2c[@]}" miff:- | "${MONTAGE_CMD5[@]}" miff:- |
                    "${MONTAGE_CMD6[@]}" miff:- | "${MONTAGE_CMD4[@]}"
                else
                    "${MONTAGE_CMD[@]}" miff:- | "${MONTAGE_CMD02[@]}" miff:- |
                    "${MONTAGE_CMD2c[@]}" miff:- |  "${MONTAGE_CMD5[@]}" miff:- |
                    "${MONTAGE_CMD6[@]}" miff:- | "${MONTAGE_CMD4[@]}"
                fi
            else
                "${MONTAGE_CMD1[@]}" miff:- | "${MONTAGE_CMD2[@]}" miff:- |
                "${MONTAGE_CMD5[@]}" miff:- | "${MONTAGE_CMD6[@]}" miff:- |
                "${MONTAGE_CMD4[@]}"
            fi
        fi
        unset ANI_PICS sc_cmd
    done
    # copy a few black frames to make sure end frame is really "black"
    for ((i=FRAMES; i<FRAMES+18; i++)); do
        cp $WORK_DIR/black.jpg $WORK_DIR/animenu/$i.jpg
    done
elif ! $MENU_FADE && ! $QUICK_MENU && $DO_MENU; then # Do not do menu fade
    if $TRANSPARENT; then # non transparent -showcase-* uses this block too
        for (( count=1; count<=$FRAMES; count++)); do
            spin "\rProcessing "$count.jpg"  "
            for ((cnt=0; cnt<=NUM_FILES; cnt++)); do
                ANI_PICS=( "${ANI_PICS[@]}" $(find $WORK_DIR/pics/$cnt  \
                -name $(printf "%06d%s"  $((count - 1)) .$IMG_FMT) ) )
            done
            for ((f=0; f<${#ANI_PICS[@]}; f++)); do
                sc_cmd=( ${sc_cmd[@]} ${SHOWCASE_THUMB_PAGES[f]} "${ANI_PICS[f]}")
            done
            SC_VIDEO_CMD="$SC_IMG_PAGE \
            "$WORK_DIR"/showcase/$(printf "%06d%s"  $count .png)"
            $STATIC && SC_VIDEO_CMD="$SC_IMG_PAGE \
            "$WORK_DIR"/showcase_img.png"
            $TEXTMENU && unset sc_cmd

            IM_CMD0=(convert  -size $VIDSIZE "$WORK_DIR/pics/template.png" \
            ${sc_cmd[@]} $SC_IMG_CMD -mosaic)
            IM_CMD01=(convert  -size $VIDSIZE xc:none -background none \
            ${sc_cmd[@]} $SC_VIDEO_CMD -mosaic)
            # dissolve piped images onto bgimage
            IM_CMD02=(composite \
            -gravity NorthWest  -dissolve $OPACITY - $WORK_DIR/pics/template.png)
            # dissolve piped images onto bgvideo
            IM_CMD03=(composite -size $VIDSIZE -background none \
            -gravity NorthWest  -dissolve $OPACITY - $WORK_DIR/bg/$count.jpg \
            -background none)
            # dissolve titles onto bgvideo
            IM_CMD04=(convert -size $VIDSIZE -background none \
            - ${sc_thumb_title_cmd[@]} -mosaic)
            IM_CMD05=(convert  -size $VIDSIZE xc:none -background none \
            ${sc_cmd[@]} $SC_IMG_PAGE -mosaic)
            IM_CMD1=(montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[NUM_FILES]} \
            -geometry ${THUMB_SIZE}${MTG_GEO} -background none miff:-)
            IM_CMD2=(composite -dissolve $OPACITY \
            -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} - \
            $WORK_DIR/pics/template.jpg -background none miff:-)
            IM_CMD2b=(composite -dissolve $OPACITY \
            -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} - \
            $WORK_DIR/bg/$count.jpg -background none miff:-)
            IM_CMD3=(composite -dissolve 30 -gravity $TITLE_GRAVITY \
            -geometry ${mist_xoffset}${mist_yoffset} $WORK_DIR/white.png - miff:-)
            IM_CMD4=(convert - $WORK_DIR/title_txt.png -gravity $TITLE_GRAVITY \
            -geometry ${title_xoffset}${title_yoffset} -composite "${ADD_RTN_BTN[@]}" \
            "${ADD_PLAYALL_BTN[@]}" $WORK_DIR/animenu/$count.jpg )
            if $MIST; then
                if $SHOWCASE && [[ -n "$SHOWCASE_VIDEO" ]]; then # showcase, mist, showcase-video
                    if test -n "$BG_VIDEO"; then # showcase, mist, showcase-video, bgvideo
                        "${IM_CMD01[@]}" miff:- | "${IM_CMD04[@]}" miff:- |
                       "${IM_CMD03[@]}" miff:- |  "${IM_CMD3[@]}" |  "${IM_CMD4[@]}"
                    else # showcase, mist showcase-video, not bgvideo
                        "${IM_CMD01[@]}" miff:- | "${IM_CMD02[@]}" "$WORK_DIR/animenu/$count.jpg"
                    fi
                elif $SHOWCASE && [[ -n "$SHOWCASE_IMG" ]]; then # showcase, mist, showcase-image
                    if test -n "$BG_VIDEO"; then # showcase, mist, showcase-image with bgvideo
                        "${IM_CMD05[@]}" miff:- | "${IM_CMD04[@]}" miff:- |
                        "${IM_CMD03[@]}" miff:- |"${IM_CMD3[@]}" |  "${IM_CMD4[@]}"
                    else # showcase, mist, showcase-image, not bgvideo
                        "${IM_CMD0[@]}" $WORK_DIR/animenu/$count.jpg
                    fi
                elif ! $SHOWCASE; then
                    if test -n "$BG_VIDEO"; then
                        "${IM_CMD1[@]}" | "${IM_CMD2b[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
                    else
                    "${IM_CMD1[@]}" | "${IM_CMD2[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
                    fi
                fi
            else # not mist
                if $SHOWCASE && [[ -n "$SHOWCASE_VIDEO" ]]; then # showcase, no mist, showcase-video
                    if test -n "$BG_VIDEO"; then # showcase, no mist, showcase-video, bgvideo
                        "${IM_CMD01[@]}" miff:- | "${IM_CMD04[@]}" miff:- |
                        "${IM_CMD03[@]}" miff:- | "${IM_CMD4[@]}"
                    else # showcase, no mist, showcase-video, not bgvideo
                        "${IM_CMD01[@]}" miff:- | "${IM_CMD04[@]}" miff:- |
                        "${IM_CMD02[@]}" miff:- | "${IM_CMD4[@]}"
                    fi
                elif $SHOWCASE && [[ -n "$SHOWCASE_IMG" ]]; then # showcase, no mist, showcase-image
                    if test -n "$BG_VIDEO"; then # showcase, no mist, showcase-image with bgvideo
                        "${IM_CMD05[@]}" miff:- | "${IM_CMD04[@]}" miff:- |
                        "${IM_CMD03[@]}" miff:- | "${IM_CMD4[@]}"
                    else # showcase, no mist, showcase-image, no bgvideo
                        "${IM_CMD0[@]}" $WORK_DIR/animenu/$count.jpg
                    fi
                elif ! $SHOWCASE; then
                    if test -n "$BG_VIDEO"; then
                        "${IM_CMD1[@]}" | "${IM_CMD2b[@]}" | "${IM_CMD4[@]}"
                    else
                        "${IM_CMD1[@]}" | "${IM_CMD2[@]}" | "${IM_CMD4[@]}"
                    fi
                fi
            fi
            rm -f ${ANI_PICS[@]}
            unset ANI_PICS sc_cmd
        done
    else # Not transparent (non transparent showcase uses transparent block ^^)
         C=$((${CHAPTERS[s]} - 1))
        for (( count=1; count <=FRAMES; count++)); do
            spin -ne "\rProcessing "$count.jpg"  "
            for ((cnt=0; cnt<=NUM_FILES; cnt++)); do
                ANI_PICS=( "${ANI_PICS[@]}" \
                $(find $WORK_DIR/pics/$cnt  -name $(printf "%06d%s"  $((count - 1))  .$IMG_FMT) ) )
            done
            # make final montages and composite onto grey background with title
            IM_CMD0=(montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[NUM_FILES]} \
            -geometry ${THUMB_SIZE}${MTG_GEO} -background none miff:-)
            IM_CMD1=(convert $WORK_DIR/pics/template.jpg \
            -  -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} -composite miff:-)
            IM_CMD2=(convert $WORK_DIR/bg/$count.jpg \
            -  -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} -composite miff:-)
            IM_CMD3=(composite -dissolve 30 -gravity $TITLE_GRAVITY \
            -geometry ${mist_xoffset}${mist_yoffset} $WORK_DIR/white.png - miff:-)
            IM_CMD4=(convert - $WORK_DIR/title_txt.png  \
            -gravity $TITLE_GRAVITY -geometry ${title_xoffset}${title_yoffset} \
            -composite "${ADD_RTN_BTN[@]}" "${ADD_PLAYALL_BTN[@]}" $WORK_DIR/animenu/$count.jpg )

            if $STATIC; then
                if $MIST; then
                    "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
                else  # static and no MIST
                    echo
                    echo "running "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD4[@]}""
                    "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD4[@]}" >> "$LOG_FILE"
                fi
            else # animated
                if test -n "$BG_VIDEO"; then
                    if $MIST; then
                        "${IM_CMD0[@]}" | "${IM_CMD2[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
                    else # no mist
                        "${IM_CMD0[@]}" | "${IM_CMD2[@]}" | "${IM_CMD4[@]}"
                    fi
                else # no bg video
                    if $MIST; then
                        "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
                    else # no mist
                        "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD4[@]}"
                    fi
                fi
            fi
            unset ANI_PICS
        done
    fi
fi
echo
! $QUICK_MENU && $DO_MENU && \
  echo "Converting images to video and encoding to $TARGET-compliant format"
# convert images to video stream and encode to dvd compliant m2v
if $STATIC; then
    # we have a value for MENU_AUDIOLENGTH AND BG_AUDIO
    if [[ -n "$BG_AUDIO" && "$BG_AUDIO" != "none" ]]; then
        LOOPS=$( bc <<< "$MENU_AUDIOLENGTH * $FRAME_RATE" 2>/dev/null)
        LOOPS=${LOOPS%.*}
    else
        LOOPS=60
    fi
    JPEG2YUV_OPTS=(-n 1 -l $LOOPS)
    PICS_IN="$WORK_DIR/animenu/1.jpg"
else  # animated menu
    if $MENU_FADE; then
        JPEG2YUV_OPTS="-n $((ANI_MENU_END_FRAME + 18))"
    else
        JPEG2YUV_OPTS="-n $MENU_FRAMES"
    fi
    PICS_IN="$WORK_DIR/animenu/%d.jpg"
fi
ENC_CMD1=(jpeg2yuv -v 0 -f $FRAME_RATE -I p "${JPEG2YUV_OPTS[@]}" -L 1 -b1 \
-j "$PICS_IN")
ENC_CMD2=(ffmpeg   -f yuv4mpegpipe -i - -an -r $FRAME_RATE -s $VIDSIZE \
-tvstd $TV_STANDARD $FFMPEG_OPTS -y $WORK_DIR/intro.m2v)
yecho
if ! $QUICK_MENU && $DO_MENU; then
    echo "Running "${ENC_CMD1[@]}" | "${ENC_CMD2[@]}"" |format_output
    ! "${ENC_CMD1[@]}" | "${ENC_CMD2[@]}" 2>&1 | strings >> "$LOG_FILE" && runtime_error
    echo
    echo "Cleaning up montage images"
    rm -f $WORK_DIR/animenu/*.jpg
    rm -f $WORK_DIR/animenu/*.png
fi
# check if m2v was created ok before proceeding
if $DO_MENU; then
    if ! mencoder -quiet -oac pcm -ovc copy -frames 0 \
      "$WORK_DIR/intro.m2v" -o /dev/null &> /dev/null; then
        echo
        runtime_error  "The menu video file does not appear to have been created"
    fi
fi
if $DO_MENU; then
    MENU_ATIME=$(vid_length "$WORK_DIR/intro.m2v")
    $SWITCHED && MENU_ATIME=${MENU_LEN[MENU_NUM-1]}
fi

# use mplayer to dump audio if mplayer used for video
# but first check if audio same file as video and its not a static menu
if [[ $SC_FRAMESTYLE = "glass" && $BG_AUDIO = $SHOWCASE_VIDEO ]]; then
    ! $STATIC && USE_MPLAYER_4AUDIO=:
fi
BG_AUDIO_LENGTH="-t $MENU_ATIME"
# create audio background for the main menu
if $DO_MENU; then
    if [[ -z "$BG_AUDIO" || "$BG_AUDIO" = "none" ]]; then # use silence
        ! $SWITCHED && AUDIO_FADE=false # do not fade silence
        cat /dev/zero 2>/dev/null | nice -n 0 sox -t raw -c 2 -r 48000 -w \
        -s - $WORK_DIR/intro.wav  trim 0 $MENU_ATIME
    # Make sure file exists
    elif test ! -s "$BG_AUDIO"; then
        runtime_error "Cannot find background audio file: $BG_AUDIO"
    else # audio supplied: convert to wav then later to dvd/svcd format
        # TODO if ! $BG_AUDIOVIDEO_FILE; then  # check if same file and if so
        # decode the audio and jpegs in one step above, and skip this block
        if $USE_MPLAYER_4AUDIO; then
            BGAUDIO_CMD=(mplayer  -quiet -vc null -vo null -ss $MPLAYER_SEEK_VAL \
            -ao pcm:waveheader:file="$WORK_DIR/intro.wav" -endpos $MENU_ATIME  "$BG_AUDIO")
        else
            BGAUDIO_CMD=(ffmpeg -y  -async 1 -ss $BG_AUDIO_SEEK $BG_AUDIO_LENGTH \
            -i "$BG_AUDIO" -r 29.970 -ar 48000 -ac 2 -acodec pcm_s16le \
            $WORK_DIR/intro.wav)
        fi
        yecho
        echo "Running "${BGAUDIO_CMD[@]}"" |strings|tee -a "$LOG_FILE" 2>&1
        ! "${BGAUDIO_CMD[@]}" 2>&1 |strings >> "$LOG_FILE" && runtime_error

        if $AUDIO_FADE; then  # bgaudio supplied and audio fade selected
            WAV_TIME=$(audio_length "$WORK_DIR/intro.wav")
            echo "Running: "
            echo "sox $WORK_DIR/intro.wav $WORK_DIR/intro-processed.wav fade t \
            $FADE $WAV_TIME $FADE"
            sox $WORK_DIR/intro.wav \
            $WORK_DIR/intro-processed.wav fade t $FADE $WAV_TIME $FADE
            rm $WORK_DIR/intro.wav
            mv $WORK_DIR/intro-processed.wav $WORK_DIR/intro.wav
        fi
    fi
fi
unset BGAUDIO_CMD TIME

# convert to proper audio format
# temporarily have to use mp2enc for svcd as ffmpeg broken FIXME
# see r2162 todisc or older for how to fix this block when ffmpeg is fixed
if [[ $TARGET = "dvd" ]]; then
    BGAUDIO_CMD=(ffmpeg -i $WORK_DIR/intro.wav \
    $AUDIO_OPTS -y $WORK_DIR/intro.$AUDIO_EXT)
    yecho "Running "${BGAUDIO_CMD[@]}"" | fold -bs >> "$LOG_FILE"
    "${BGAUDIO_CMD[@]}" 2>&1 |strings >> "$LOG_FILE"
elif [[ $TARGET = "svcd" ]] && $DO_MENU; then
    BGAUDIO_CMD=(mp2enc -r 44100 -o $WORK_DIR/intro.$AUDIO_EXT)
    "${BGAUDIO_CMD[@]}" < "$WORK_DIR/intro.wav" 2>&1 |fold -bs >> "$LOG_FILE"
fi
if $DO_MENU; then
     ! [[ -s $WORK_DIR/intro.$AUDIO_EXT ]] && runtime_error
    unset BGAUDIO_CMD
    rm -fv "$WORK_DIR/intro.wav"
    echo
    echo "Multiplexing main menu audio and video together"
    # mplex main menu audio and video together
    INTRO_MPLEX_CMD="mplex -V -f $MPLEX_FORMAT -o $WORK_DIR/intro.mpg \
      $WORK_DIR/intro.$AUDIO_EXT $WORK_DIR/intro.m2v"
    echo -e "\nRunning: $INTRO_MPLEX_CMD\n" |fold -bs >> "$LOG_FILE"
    yecho
    ! ${INTRO_MPLEX_CMD[@]} 2>&1 |strings >> "$LOG_FILE" && runtime_error

    yecho
    if $SWITCHED_MODE || $SWITCHED_MENUS; then
        yecho "Copying the menu mpeg"
        if [[ $MENU_NUM -ne 1 ]]; then
            cp -v "$REAL_WORK_DIR/intro.mpg" \
              "$BASEDIR/${TSET_NUM}-${MENU_NUM}intro.mpg"
        else
            cp -v  "$REAL_WORK_DIR/intro.mpg"  \
              "$REAL_WORK_DIR/${TSET_NUM}-${MENU_NUM}intro.mpg"
        fi
        sleep 2
        if $SWITCHED_MODE; then
            $KEEP_FILES && mv -v "$REAL_WORK_DIR" \
              "$BASEDIR"/TITLESET${TSET_NUM}-MENU${MENU_NUM}
            ( KEEP_FILES=false && cleanup )
            exit
        fi
    fi
    if $SWITCHED_MENUS && [[ $TARGET != svcd ]]; then
        for ((i=1; i<=${#FILES[@]}; i++)); do
            MENU_FILE="$BASEDIR/animenu${TSET_NUM}-${i}.mpg"
            yecho "Running spumux "$SPUMUX_XML" \
              < "$REAL_WORK_DIR/${TSET_NUM}-${i}intro.mpg" > "$MENU_FILE""
            spumux "$SPUMUX_XML" < "$WORK_DIR/${TSET_NUM}-${i}intro.mpg" \
              > "$MENU_FILE" 2>> "$LOG_FILE"
            check_menufile
        done
    fi
fi
if [[ $TARGET != svcd ]] && ! $SWITCHED_MENUS && ! $SWITCHED_MODE; then
    yecho "Running spumux "$SPUMUX_XML" < $WORK_DIR/intro.mpg > "$MENU_FILE""
    spumux "$SPUMUX_XML" < $WORK_DIR/intro.mpg > "$MENU_FILE" 2>> "$LOG_FILE"
    check_menufile
fi
if $SUB_MENU; then
    echo "Creating submenus"
    for ((x=1; x<=V_TOTAL; x++)); do
        yecho "Running spumux "$WORK_DIR/submenu${x}_spumux.xml" < \
        $WORK_DIR/menu${x}.mpg > \
        $(sed 's/\(.*\)menu/\1Menu/' <<< $WORK_DIR/menu${x}.mpg)"|fold -bs
        spumux "$WORK_DIR/submenu${x}_spumux.xml" < \
        $WORK_DIR/menu${x}.mpg > \
        $(sed 's/\(.*\)menu/\1Menu/' <<< $BASEDIR/${TSET_NUM}-menu${x}.mpg) 2>> "$LOG_FILE"
    done
fi
if $TITLESET_MODE; then
    $KEEP_FILES && mv -v "$REAL_WORK_DIR" "$BASEDIR"/TITLESET${TSET_NUM}
fi

if [ "$TARGET" = "dvd" ] && $AUTHOR && ! $VMGM_ONLY && ! $DO_TITLESETS && ! $SWITCHED_MODE; then
    echo "Running dvdauthor to create the DVD filesystem"
    dvdauthor -x "$DVDAUTHOR_XML" 2>&1  | tee -a  "$LOG_FILE.tmp"
    if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
        dvdauthor_error
    fi
    strings "$LOG_FILE.tmp" >> "$LOG_FILE" && rm -f "$LOG_FILE.tmp"
elif [ "$TARGET" = "svcd" ]; then
    $MONTAGE_MENU && SLIDE_MENU=(-menu "$WORK_DIR/intro.mpg")
    MKXML_CMD=(makexml -svcd -quiet "${SLIDE_MENU[@]}" \
      $SVCD_PAUSE "${IN_FILES[@]}" -out "$OUT_FILE")
    echo "Running ${MKXML_CMD[@]}" | fold -bs | tee -a "$LOG_FILE"
    "${MKXML_CMD[@]}" |tee -a "$LOG_FILE"
    MAKEVCD_CMD=(makevcd "${OUT_FILE}.xml"); yecho "Running ${MAKEVCD_CMD[@]}"
    "${MAKEVCD_CMD[@]}" 2>&1 >> "$LOG_FILE" 2>&1
    awk '/makevcd/,EOF' "$LOG_FILE" | awk '!/WARN/'
fi
echo "Cleaning up unwanted files in $REAL_WORK_DIR"
find "$WORK_DIR"/ -name '*.png' ! -name Highlight.png ! -name Select.png -exec rm -f {} \; > /dev/null 2>&1
find "$WORK_DIR"/ -name '*.jpg' ! -name preview.jpg -exec rm -f {} \; > /dev/null 2>&1
rm -fr "$WORK_DIR/animenu" "$WORK_DIR/pics" "$WORK_DIR/submenu"
$VMGM_ONLY && $KEEP_FILES && mv -v "$REAL_WORK_DIR" "$BASEDIR"/VMGM
#echo "Removing the link in /tmp"
#rm -fv "$WORK_DIR"
if ! $VMGM_ONLY && ! $SWITCHED_MODE && ! $TITLESET_MODE && ! $DO_TITLESETS; then
    # remove temporary files from slideshow if they exist ( *.todisc_enc.* )
    linked_files=($WORK_DIR/*.mpg)
    for i in ${!linked_files[@]}; do
        f=$(readlink -f "${linked_files[i]}")
        if [[ $f = *todisc_enc* && -e $f ]] && ! $KEEP_FILES; then
            [[ $i = 0 ]] && echo "Removing temp files outside of working dir"
            [[ -e ${f%.*}.png ]] && rm -f "${f%.*}.png"
            # only remove if smaller than 5M
            fsize=$(du -s "$f" | cut -f 1)
            if [[ $(bc_math "$fsize < 5000") -eq 1 ]]; then
                rm -f "$f"
                [[ -e ${f}.nav_log ]] && rm -f "${f}.nav_log"
            fi
                
        fi
        rm -f "${f%.*}.m2v"
    done
    thanks_goodbye
    $BURN && burn_disc
fi
! $DO_TITLESETS && cleanup
exit 0
