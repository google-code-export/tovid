#!/usr/bin/env bash
ME="[todisc]:"
. tovid-init
# todisc
# Part of the tovid suite
# =======================
# A bash script for generating a DVD with animated thumbnail menus
# from a collection of MPEG video files.
#
# Project homepage: http://www.tovid.org
#
#
# Copyright (C) 2005 tovid.org <http://www.tovid.org>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. Or see:
#
#           http://www.gnu.org/licenses/gpl.txt


# Mostly written by Robert Sohn:
#     <grepper@gmail.com>
#     grepper on irc.freenode.net

SCRIPT_NAME=`cat << EOF
--------------------------------
todisc
Generate a DVD filesystem with animated thumbnail menus
Part of the tovid suite, version $TOVID_VERSION
$TOVID_HOME_PAGE
--------------------------------
EOF`

USAGE=`cat << EOF
Usage:
    todisc [OPTIONS] \\\\
      -files File1.mpg File2.mpg ... \\\\
      -titles "Title 1" "Title 2" ... \\\\
      -out OUT_PREFIX
Input files must be MPEG, and the number of -files and -titles must be equal.
See the todisc manual page ('man todisc') for additional documentation.

EOF`
# check if symlink in /tmp exists and use time stamped link if so
WORK_DIR="/tmp/todisc-work"
for link in $(find /tmp -maxdepth 1 -name todisc-work\* -type l 2>/dev/null ); do
    [ -h "$link" ] && { WORK_DIR=/tmp/todisc-work$((NUM++)); continue; }
done
CUR_DIR="$(abspath "$(pwd)")"
# make unique REAL_WORK_DIR
REAL_WORK_DIR="$CUR_DIR/todisc-work"
for dir in "$REAL_WORK_DIR"*; do
    [ -d "$dir" ] && { REAL_WORK_DIR="$(pwd)"/todisc-work$((NUM++))
    continue; }
done
LOG_FILE="$(abspath "todisc.log")"
OUT_PREFIX=""
TV_STANDARD=ntsc
ANI_MENU_LENGTH=20
ANI_SUBMENU_LENGTH=10
MAX_ANI_LENGTH=""
TARGET=dvd
FRAME_RATE=29.970  # when -ntsc and -pal options added put in body in if block
VIDSIZE=720x480
MENU_TITLE="My Video Collection"
SPUMUX_XML="$WORK_DIR/spumux.xml"
DVDAUTHOR_XML="$WORK_DIR/dvdauthor.xml"
STATIC=false
SUB_MENU=false
ANI_SUB_MENU=false
TITLE_COLOUR="#CDC0B0"
SM_TITLE_COLOUR="#CDC0B0"
THUMB_BG_COLOUR=white
THUMB_TEXT_COLOUR=""
BUTTON_STYLE="rect"
MIST_COLOUR=white
MIST_OPACITY=60
STROKE=""
SUBMENU_STROKE="none"
BG_AUDIO=""
BG_PIC=""
BG_VIDEO=""
SHOWCASE=false
SUBMENU_AUDIO=false
SM_AUDIO_FADE=:
SM_FADE=1
AUDIO_FADE=:
OPACITY=100
MENU_FADE=false
TRANSPARENT=false
PREVIEW=:
PAUSE_TIME=10
STATIC_LOOP=false
MIST=false
FEATHER=false
BLUR=4
SUB_MENU_FEATHER=false
IMG_FMT=jpg
SM_IMG_FMT=jpg  # submenu image format
KEEP_FILES=false
THUMB_SHAPE=""
SEEK_VAL=2
FADE=1
CHAPTERS=( 6 )
TOVID_OPTS=""
CHAIN_VIDEOS=false
NOASK=false
SC_FRAMESTYLE=none
THUMB_FRAME="-frame 3x3"
SC_FRAME="-frame 3x3"
SHOWCASE_VIDEO=""
THREExONE=false
PLAYALL=false
USE_MAKEMENU=false
THUMBS_3D=false
RAISE=""
CURVE_UPDATE=""
SUBTITLES=false
AUDIOLANG=false
USER_BSTYLE=false
SHOWCASE_SEEK_VAL=2
BG_SEEK=2
BG_AUDIO_SEEK=2
NO_SC_THUMB=false
TEXTMENU=false
SC_TITLE_ALIGN=center
THUMB_TITLE_ALIGN=center
ALIGN_OVERRIDE=false
MULTILINE_TITLE=false
SAFE_AREA=50 # undocumented: you can set this from CLI with -showcase-safe-area
SAFE_OFFSET=36
PREVIEW_SIZE=720x540
ASPECT_RATIO=4:3
ASPECT_ARG=all
WIDE_SCREEN=false
WIDESCREEN="nopanscan"
GROUPING=false
TEXT_YSTART=$SAFE_AREA
BUTTON_GRAVITY=north
XGEO=0
YGEO=45
USER_GRAVITY=false
USER_GEO=false
USER_SPLIT=false
TITLE_GRAVITY=south
SPACER=15
SELECT_COLOUR="#DE7F7C"
HIGHLIGHT_COLOUR="#266CAE"
USER_SC_GEO=false
USER_SAFE_AREA=false
USER_TITLE_GEO=false
SPACER=""
SE_YCORNER=0
BG_ASYNC=""
NO_WARN=false
ROTATE_THUMBS=false
DO_TITLESETS=false
AUTHOR=true
ts_start=0
args=( "$@" )
VMGM_ONLY=false
TITLESET_MODE=false
TSET_NUM=1
MENU_NUM=1
INTRO=""
QUICK_NAV=false
SKIP_VMGM_MENU=false
NO_VMGM_MENU=false
SWITCHED_MENUS=false
SWITCHED_MODE=false
TSET_MODE=false
TSET_TOT=1
NONAME=false
DO_INTRO=false
SCRIPT_START_TIME=`date +%s`

##############################################################################
#                                 Functions                                  #
##############################################################################

# Y-echo: echo to two places at once (stdout and logfile)
# Output is preceded by the script name that produced it
# Args: $@ == any text string
# If no args are given, echo a separator bar
# Use yecho if you want output to go to the logfile
function yecho()
{
    if test $# -eq 0; then
        printf "\n%s\n\n" "$SEPARATOR"
        # If logfile exists, copy output to it (with pretty formatting)
        test -e "$LOG_FILE" && \
            printf "%s\n%s %s\n%s\n" "$ME" "$ME" "$SEPARATOR" "$ME" >> "$LOG_FILE"
    else
        echo "$@" | sed "s/    */ /g;s/^ *//"|fold -bs
        test -e "$LOG_FILE" && \
            printf "%s %s\n" "$ME" "$@" | sed "s/    */ /g;s/^ *//"|fold -bs >> "$LOG_FILE"
    fi
}

# ******************************************************************************
# Execute the given command-line string, with appropriate stream redirection
# Args: $@ == text string containing complete command-line
# Returns: Exit status of the subprocess
# To filter/prettify the subprocess output before writing it to the log file,
# set the LOG_FILTER variable before calling this function, to e.g.
#    LOG_FILTER="sed 's/\r/\r\n/g'"    # Replace LF with CR/LF
# ******************************************************************************
function cmd_exec()
{
    eval "$@" 2>&1 | ${LOG_FILTER:=cat} # >> "$LOG_FILE"
    # Return exit status
    return $?
}

# Print script name, usage notes, and optional error message, then exit.
# Args: $@ == text string(s) containing error message and help
function usage_error ()
{
    MESSAGE=( "$@" )
    printf "%s\n%s\n%s\n\n" "$USAGE" "$SEPARATOR" "***"
    for ((i=0; i<$#; i++)) ; do printf "%s" "${MESSAGE[i]}"; done |fold -bs
    printf "\n\n%s\n" "***"
    rm -rf "$REAL_WORK_DIR" "$WORK_DIR"
    exit 1
}
function titlesafe_error()
{
    echo "********* WARNING *********"
    yecho "thumb title is $1 pixels from screen edge"
    yecho "Part of the title may not be visible on your tv screen"
    yecho "Consider using a smaller -thumb-fontsize, or shortening \"${TITLES[i]}\""
    echo "****************************"
    ! $NO_WARN && sleep 3
}
# process $LOG_FILE.tmp variously - eg. output of ffmpeg is ugly without this
function cleanlog()
{
    SED_VAR=${SED_VAR:-"frame="}
    FOLD="fold -bs"
    NO_CR="tr -d '\r'"
    RELINE="{s/$SED_VAR/\n$SED_VAR/g}"
    TMP_LOG="$LOG_FILE.tmp"
    NOSPACE="tr -s ' '"

    case "$1" in
        1 )
            $FOLD "$TMP_LOG" >> "$LOG_FILE"
            echo >> "$LOG_FILE"
            ;;
        2 )
            $NO_CR < "$TMP_LOG" | $FOLD >> "$LOG_FILE"
            echo >> "$LOG_FILE"
            ;;
        3 )
            $NO_CR < "$TMP_LOG" | sed $RELINE | $FOLD >> "$LOG_FILE"
            echo >> "$LOG_FILE"
            ;;
        4 )
            $NOSPACE < "$TMP_LOG" | $FOLD >> "$LOG_FILE"
            ;;
    esac
    rm -f "$LOG_FILE.tmp"
}
function format_output()
{
    sed "s/    */ /g;s/^ *//"|fold -bs
}

function get_font()
{
    # If there is a filename extension, find the absolute path
    if echo "$1" | grep -q '\...*$'; then
        echo $(abspath "$1")
    # Otherwise, use the literal name
    else
        echo "$1"
    fi
    # TODO: Check for font availability?
}

# ******************************************************************************
# Print out a runtime error specified as an argument, and exit
# ******************************************************************************
function runtime_error()
{
    # Uncomment if needed later
    #killsubprocs
    echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    yecho "todisc encountered an error:"
    yecho "    $@"
    echo "Check the contents of $LOG_FILE to see what went wrong."
    echo "See the tovid website ($TOVID_HOME_PAGE) for what to do next."
    echo "Sorry for the inconvenience!"
    echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    exit 1
}

function vid_length()
{
    yecho "Running mencoder "$1" -quiet -ovc copy -oac pcm -o /dev/null | awk '/Video stream/ {print $10}'" >> "$LOG_FILE"
    mencoder "$1" -quiet -ovc copy -oac pcm -o /dev/null 2>>"$LOG_FILE" | awk '/Video stream/ {print $10}'
}

function cleanup()
{
    echo
    yecho "Cleaning up..."
    if test -e "$WORK_DIR/tc_pids"; then
        TCPIDS=$(awk -F"=" '/pid=/ {print $2}' "$WORK_DIR/tc_pids" | cut -f1 -d')'|sort|uniq)
        for i in $TCPIDS; do
            if  kill -0 $i 2> /dev/null; then kill -9 $i 2> /dev/null;fi
        done
    fi
    if test -e "$WORK_DIR/tcode*.pid"; then
        for pidfile in "$WORK_DIR/tcode*.pid"; do
            if kill -0 $(<$pidfile); then kill -9 $(<$pidfile) 2> /dev/null; fi
        done
    fi
    if kill -0 $TCODE_PID 2> /dev/null; then kill -9  $TCODE_PID  2> /dev/null; fi
    if kill -0 $TRANSCODE_PID 2> /dev/null; then kill -9  $TRANSCODE_PID 2> /dev/null; fi
    if kill -0 $NS_PID 2> /dev/null; then kill -9 $NS_PID 2> /dev/null; fi
    if $KEEP_FILES; then
        yecho "Keeping temporary files in $REAL_WORK_DIR"
        [[ -n $SUPPORT_VIDEOS ]] && yecho "Keeping ${SUPPORT_VIDEOS[@]}" && \
            yecho "This sliced video will not work if todisc is run with different seeks so should be deleted manually"
    else
        if [[ -d $REAL_WORK_DIR ]]; then
            yecho "Removing $REAL_WORK_DIR"
            [[ -n $SUPPORT_VIDEOS ]] && yecho "Removing "${SUPPORT_VIDEOS[@]}"" && rm -f "${SUPPORT_VIDEOS[@]}"
            rm -rf "$REAL_WORK_DIR"
        fi
    fi
    echo "Removing the symlink in /tmp . . . "
    rm -fv "$WORK_DIR"
}

function running_total ()
{
    awk -v offset=$offset '{
    for (i=1; i<=NF; i++) if (s=s+$i) printf("%s ",s);printf ("\n")}'
}

function awk_total()
{
    awk '{for (i=1; i<=NF; i++) s=s+$i}; END{print s}'
}

function format_seconds()
{
    awk '{
    hr=($1/3600); hd=(sprintf("%02d", hr))
    mr=((hr-hd)*60); md=(sprintf("%02d", mr))
    s=((mr-md)*60); sd=(sprintf("%02d", s))
    t=(sprintf("%02d:%02d:%06.3f" ,hd,md,s)); print t}' <<< $1
}

function awk_math()
{
    if [ $2 = times ]; then
        OP=*
    elif [ $2 = by ]; then
        OP=/
    elif [ $2 = less ]; then
        OP=-
    elif [ $2 = plus ]; then
        OP=+
    fi
if [[ -n "$4" && "$4" = "float" ]]; then
    awk 'BEGIN { printf("'"$1"'" '$OP' "'"$3"'")"\n" ; exit  }'
else
    awk -v A=$1 -v B=$3 'BEGIN { printf("%d\n", (A '$OP' B)); }'
fi
}

function confirm_preview()
{
    yecho
    echo "If you are happy with the preview, type 'yes' to continue: "
    read input
    echo
    if [ ! -z "$input" -a "$input" = "yes" ]; then
        yecho "Preview OK, continuing."
        yecho
    else
        yecho "Preview not OK, exiting."
        echo -n "Deleting symlink in /tmp . . . "
        rm -fv "$WORK_DIR"
        if ! $KEEP_FILES; then
            echo -n "Deleting "$REAL_WORK_DIR" . . . "
            rm -fr "$REAL_WORK_DIR"
        fi
        yecho
        echo
        echo "Some configuration options to try, if things look bad:"
        echo "Color:"
        echo "    -title-color"
        echo "    -thumb-text-color"
        echo "Fonts:"
        echo "    -menu-font and -menu-fontsize"
        echo "    -thumb-font and -thumb-fontsize"
        echo "(or reduce thumb title lengths)"
        echo "If you get black frames, then look at the -seek option"
        echo "For other fine-tuning options, see 'man todisc'."
        exit 0
    fi
#    yecho
}

# Display (echo) a spinner with a message
SP=0
function spin()
{
    SPIN_CHARS=".oOo"
    SPINNER="${SPIN_CHARS:SP++%${#SPIN_CHARS}:1}"
    # Print spaces to overwrite previous line
    echo -ne "\r                                                            "
    echo -ne "\r$@ "
}

#EXPAND="expand=-6:-6,"
function get_framed_pics()
{
mplayer -ss $MPLAYER_SEEK_VAL -vo $VOUT -noconsolecontrols \
-vf ${EXPAND}rectangle=${FRAME_SIZE/x*}:${FRAME_SIZE/*x},rectangle=$(( ${FRAME_SIZE/x*} - D )):$(( ${FRAME_SIZE/*x} - D)),rectangle=$(( ${FRAME_SIZE/x*} - $((D * 2)) )):$(( ${FRAME_SIZE/*x} - $((D * 2)) )),rectangle=$(( ${FRAME_SIZE/x*} - $((D * 3)) )):$(( ${FRAME_SIZE/*x} - $((D * 3)) )) \
-ao null -zoom -x ${FRAME_SIZE/x*} -y ${FRAME_SIZE/*x}  -frames $FRAMES "$1"
}

# Create a text-only menu, using makemenu/makexml
function call_makemenu()
{
    # Assemble and run makemenu command
    MENU_OUT="${OUT_PREFIX}_menu"
    MAKEMENU="makemenu"
    for ((i=0; i<${#TITLES[@]}; i++)); do
        MAKEMENU="$MAKEMENU \"${TITLES[i]}\""
    done
    MAKEMENU="$MAKEMENU -textcolor \"$TITLE_COLOUR\""
    test -n "$BG_PIC" && MAKEMENU="$MAKEMENU -background \"$BG_PIC\""
    test -n "$MENU_FONT" && MAKEMENU="$MAKEMENU -font \"$MENU_FONT\""
    test -n "$MENU_FONTSIZE" && MAKEMENU="$MAKEMENU -fontsize \"$MENU_FONTSIZE\""
    MAKEMENU="$MAKEMENU -out $MENU_OUT"

    echo "Running the following makemenu command:"
    echo $MAKEMENU
    cmd_exec "$MAKEMENU"

    # Assemble and run makexml command
    MAKEXML="makexml -menu $MENU_OUT.mpg -out $OUT_PREFIX"
    for ((i=0; i<${#FILES[@]}; i++)); do
        MAKEXML="$MAKEXML \"${FILES[i]}\""
    done
    MAKEXML="$MAKEXML -out $OUT_PREFIX"
    echo "Running the following makexml command:"
    echo $MAKEXML
    cmd_exec "$MAKEXML"

    # Assemble and run makedvd command
    MAKEDVD="makedvd -author ${OUT_PREFIX}.xml"
    echo "Running the following makedvd command:"
    echo $MAKEDVD
    cmd_exec "$MAKEDVD"
}

function confirm_dep()
{
    if ! $(which $1 > /dev/null 2>&1); then
        yecho "The program $1 is not installed, please install it to use todisc"
        yecho "The $1 homepage is $2"
        exit 1
    fi
}

function stat_logfile()
{
     awk '/Modify/ {print $3}' <<< "$(stat "$LOG_FILE")"
}

function get_line_count()
{
awk 'END{print NR}' "$LOG_FILE"
}

function check_stall()
{
    PIDOF_TRANSCODE=$(<$WORK_DIR/tcode$i.pid)
    newlines=$(stat_logfile)
    while ps -p $PIDOF_TRANSCODE >/dev/null; do
        # Check for transcode output every 10 seconds
        sleep 10
        age=$newage
        newage=$(stat_logfile)
        # If no new output, sleep 20s and check again
        [[ $newage = $age ]] && sleep 20 && newage=$(stat_logfile)
        # If still no new lines, send a HUP signal to transcode
        if [[ $newage == $age ]] && kill -0 $PIDOF_TRANSCODE > /dev/null 2>&1; then
            echo
            echo "*** transcode appears to be stalled ***"
            echo "*** We are going to send transcode a HUP and hope for the best ***"
            sleep 5
            $(kill -0 $PIDOF_TRANSCODE > /dev/null 2>&1) && kill -HUP $PIDOF_TRANSCODE
            echo
        fi
    done
}
function check_filetype()
{
    if [[ $(file -L "$1") = *image* ]]; then
        TYPE=image
    elif mencoder -endpos 2 -oac pcm -ovc copy  "$1" -o /dev/null  >/dev/null 2>&1; then
        TYPE=video
    else TYPE=unknown
    fi
}

function get_stats()
{
unset IN_STATS FILES_IN
this_set=$1
if [[ $this_set = group ]]; then
    unset TOT IN_STATS FILES_IN
    TOT=${#grouping[@]} # || TOT=${#IN_FILES[@]}
    IN_STATS=( "${group_mencoder_stats[@]}" )
    FILES_IN=( "${grouping[@]}" )
    NAV=group_nav
    LENGTH=length
else
    TOT=${#IN_FILES[@]}
    IN_STATS=( "${mencoder_stats[@]}" )
    FILES_IN=( "${IN_FILES[@]}" )
    NAV=nav
fi

for ((i=0; i<TOT; i++)); do
    [[ $this_set = group ]] &&  LENGTH=${group_length[i]} || LENGTH=${length[i]}
    VCODEC="$(awk '/VIDEO:/ {gsub(/\[|\]/, ""); print $2}' \
    <<< "${IN_STATS[i]}")"
    V_BR="$(awk '/Video stream:/{print $3}'<<< "${IN_STATS[i]}")"
    ACODEC="$(awk  '/Selected audio codec/ {gsub(/\[|\]/, ""); print $4}' \
    <<< "${IN_STATS[i]}")"
    A_BR="$(awk  '/AUDIO:/ {print $7}' <<< "${IN_STATS[i]}")"
    if [ -z "$A_BR" ]; then
        A_BR="No audio found"
    fi
    if [ -e "${IN_FILES[i]}".nav_log ]; then
        V_LENGTH=$(awk_math $LENGTH by $FRAME_RATE float)
    else
        V_LENGTH=$(awk '/Video stream:/{print $10}'<<< "${IN_STATS[i]}")
    fi
    if [[ $this_set != group ]]; then
        if [[ ${V_LENGTH%.*} -lt ${SEEK_VAL[i]%.*} ]]; then
            usage_error "A seek of ${SEEK_VAL[i]} seconds is too large for ${IN_FILES[i]}. The file is only $V_LENGTH seconds long"
        fi
    fi
    FPS="$(awk ' /VIDEO/ { if ($_=="fps"); sub(/fps.*$/, ""); print $NF}' <<<"${IN_STATS[i]}")"
    yecho
    if [[ $this_set = group ]] && ((i == 0)); then
        echo; echo ". . . Grouped file stats . . ."; echo
    yecho
    fi
    [[ $this_set = group ]] && echo -e "Stats for" $(readlink "${FILES_IN[i]}") "\n" || \
    echo -e "Stats for" "${FILES_IN[i]}" "\n"
    echo -e  \
    " video codec:   " \
    "$VCODEC" "\n" \
    "video bitrate: " "$V_BR" "kbps" "\n" \
    "framerate:     " "$FPS" "fps" "\n" \
    "audio codec:   " \
    "$ACODEC" "\n" \
    "audio bitrate: " \
    "$A_BR" " kbps" "\n" \
    "video length:  " \
    "$V_LENGTH" " seconds" |tee -a "$LOG_FILE"
done
}

function check_compliance()
{
    unset FILES_TO_ENCODE ENC_IN_FILES CHECK_IN_FILES
    group_set=false
    if [[ $1 = group ]]; then
        group_set=:
        unset x a
        CHECK_IN_FILES=( "${grouping[@]}" )
    else
        CHECK_IN_FILES=( "${IN_FILES[@]}" )
    fi
    for ((i=0; i<${#CHECK_IN_FILES[@]}; i++)); do
        IN_FILE="${CHECK_IN_FILES[i]}"
        $group_set && yecho "Checking "$(readlink $IN_FILE)" for compliance..."
        ! $group_set && yecho "Checking $IN_FILE for compliance..."
        # test files with idvid script
        if test "$(idvid -isformat $TARGET "$IN_FILE")" = "true" && \
           test "$(idvid -istvsys $TV_STANDARD "$IN_FILE")" = "true"; then
            ENC_IN_FILES=("${ENC_IN_FILES[@]}" "$IN_FILE")
        # Video needs to be re-encoded; use a .enc filename in ENC_IN_FILES
        else
            FILES_TO_ENCODE[i]="$IN_FILE"
            ENC_IN_FILES=("${ENC_IN_FILES[@]}" "$IN_FILE.enc.mpg")
        fi
    done
    if test "${#FILES_TO_ENCODE[@]}" -gt 0; then
        TGT_CAPS=$(echo $TARGET | tr a-z A-Z)
        TV_STND_CAPS=$(echo $TV_STANDARD | tr a-z A-Z)
        yecho
        yecho "Encode input files"
        yecho
        yecho "Some of the -files you provided are not $TV_STND_CAPS $TGT_CAPS-compliant:"
        yecho " "
        for i in "${FILES_TO_ENCODE[@]}"; do
            $group_set && this_file=$(readlink "$i") || this_file="$i"
            test -n "$this_file" && yecho " $this_file"
        done
        yecho " "
        if $NOASK; then
            echo "Converting files to $TV_STND_CAPS $TGT_CAPS-compliant format."
            echo "(This may take a long time)"
            ENCODE="yes"
        else
            yecho "I can encode them for you, but it may take a long time."
            yecho "Encoding will ensure that your disc is fully compliant;"
            yecho "you may skip this, but your disc may not be playable."
            yecho "Please type 'yes' if you want the files to be encoded:"
            read ENCODE
        fi
        if test -n "$ENCODE" && test "$ENCODE" = 'yes'; then
            yecho
            yecho "Converting files to $TGT_CAPS format with 'tovid'"
            for i in "${FILES_TO_ENCODE[@]}"; do
                $group_set && yecho "Converting $(readlink $i)" || yecho "Converting: $i"
                countdown
                $group_set && IN="$(readlink "$i")" || IN="$i"
                tovid $NO_ASK -$TV_STANDARD -$TARGET -in "$IN" -out "$IN.enc" $TOVID_OPTS
                wait
                # See if output file exists
                if ! test -f "$IN.enc.mpg"; then
                    runtime_error "Could not encode file: $i"
                fi
                yecho
            done
            # Replace IN_FILES with ENC_IN_FILES (with .enc extension)
            if $group_set; then
                for title in "${FILES_TO_ENCODE[@]}"; do
                    ln -sfv "$(readlink "${title}").enc.mpg" "$title"
                done
            else
                 IN_FILES=("${ENC_IN_FILES[@]}")
            fi
        else
            yecho
            yecho "Not re-encoding. I will proceed with menu generation, but"
            yecho "your authored disc will not be fully $TGT_CAPS-compliant."
            yecho
        fi
    fi
}

function mk_workdir()
{
    if [[ -d "$REAL_WORK_DIR" && -z ${GROUP[@]} ]]; then
        echo "Removing existing files in \"$REAL_WORK_DIR\""
        rm -rf "$REAL_WORK_DIR"
    fi
    mkdir -pv "$REAL_WORK_DIR"
    if [[ -h "$WORK_DIR" && -z ${GROUP[@]} ]]; then
        echo -n "Removing existing symlink in /tmp . . . "
        ! $DO_TITLESETS && rm -fv "$WORK_DIR"
    fi

    # link WORK_DIR to /tmp for easy solution to spaces, illegal chars bugs
    [[ -z ${GROUP[@]} ]] && ln -sfv "$REAL_WORK_DIR" "$WORK_DIR"
}

function get_group_chapters()
{
    FORMAT=false
    index=$1
    [[ -n $2 ]] && FORMAT=:
    unset chapt_len_array x len remainder t
    remainder=0
    chapter_length=$( bc <<< "scale=3; ${GROUP_TOT_LEN[index]} / ${CHAPTERS[index]}")
    GROUP_VIDEO_LENGTHS=( ${GROUP_VID_LENGTHS[index]} )

    for len in ${GROUP_VIDEO_LENGTHS[@]}; do
        adjusted_length=$( bc <<< "scale=3; $len + $remainder" )
        num_chapters=$( bc <<< "$adjusted_length / $chapter_length" )
        if (( num_chapters > 0)); then
            chapt_len_array=( $( for ((t=0; t<num_chapters; t++)); do
            echo $chapter_length; done) )
            chapt_len_array=($(bc <<< "scale=3; $chapter_length - $remainder" ) ${chapt_len_array[@]})
            unset chapt_len_array[${#chapt_len_array[@]}-1]
            chapter_points=$( running_total <<< ${chapt_len_array[@]} )
            remainder=$( bc <<< "$adjusted_length % $chapter_length")
            group_chapters[x++]=$chapter_points
        else
            group_chapters[x++]=""
            remainder=$adjusted_length
        fi
        unset chapt_len_array t
    done
    unset remainder
    if $FORMAT; then
        for d in ${!group_chapters[@]}; do
            for number in ${group_chapters[d]}; do
                new_element="$new_element $(format_seconds $number),"
            done
            array[d]="$new_element"
            unset new_element
        done

        for e in ${!array[@]}; do
            points=$(for f in ${array[e]// /}; do echo -n $f;done)
            [[ -z ${array[e]} ]] && unset chpts[e] || chpts[e]="chapters=\"${points%,}\""
            [[ -n ${array[e]} ]] && chpts[e]=${chpts[e]#,}
            if ((e == 0)); then
                [[ -z "$points" ]] && chpts0="chapters=\"00:00:00\"" || chpts0="chapters=\"00:00:00,${points%,}\""
            fi
            chpts=${chpts[@]#,}
        done
    fi
}

function get_image_dim()
{
    identify -verbose "$1" | awk '/Geometry:/ {print $2}'
}
function switched_menu_mode()
#call todisc recursively to make multiple menus for -switched-menus option
{
    $TSET_MODE && IS_TITLESET="-is_titleset"
    ! $GROUPING && mk_workdir
    for ((i=1; i<${#FILES[@]}; i++)); do
        yecho
        yecho "Working on switched menu $((i+1))"
        yecho
        yecho "Running todisc "$@" -switched-mode $IS_TITLESET -basedir "$BASEDIR"  -menu_num $((i+1)) -showcase "${FILES[i]}""
        todisc "$@" -switched-mode $IS_TITLESET -basedir "$WORK_DIR" -menu_num $((i+1)) -showcase "${FILES[i]}"
    done
        yecho
        yecho "Working on switched menu 1"
        yecho
#    exit
}
function titleset_mode()
# call todisc recursively in order to allow titlesets
{
    ! $GROUPING && mk_workdir
    # FIXME make a function or move the other copy of the next if block
    # some vars for vmgm menu, depending on presence of -static or -quick-nav
    GEN_OPTS=$(sed   's/-vmgm.*-end-vmgm//;s/-titleset.*-end-titleset//g' <<< "$@")
    egrep -q -- -static <<< "${VMGM_OPTS[@]}" && STATIC=:
    $QUICK_NAV && QUICKNAV="-quick-nav"
    # how many titlesets do we have ?
    for i in "$@"; do [[ $i == -end-titleset ]] && ((count++)); done
    if $STATIC; then
        if ! $STATIC_LOOP; then
            VMGM_PAUSE_TIME="inf"
        else
            VMGM_PAUSE_TIME=$PAUSE_TIME
        fi
    else
        VMGM_PAUSE_TIME=$PAUSE_TIME
    fi
    DVDAUTHOR_XML="$BASEDIR/dvdauthor.xml"
    $DO_INTRO && VMGM_PRE="if (g2==1) jump cell 2;"
    grep -q -- -switched-menus <<< "${args[@]}" && VMGM_PRE="        $VMGM_PRE g1=1;"
    $SKIP_VMGM_MENU && VMGM_PRE="        $VMGM_PRE if ( g3 eq 0 )  { g3 = 1 ; }"
#    $SWITCHED_MODE && VMGM_PRE="$VMGM_PRE g1=1;"
    # make dvdauthor.xml
(
    cat <<EOF
<?xml version="1.0" encoding="utf-8"?>
<dvdauthor dest="$OUT_DIR" jumppad="0">
  <vmgm>
    <menus>
      <pgc entry="title">
        <pre>
$VMGM_PRE
$(if $QUICK_NAV || $SKIP_VMGM_MENU; then
        for ((i=1; i<=${#TITLESET_OPTS[@]}; i++)); do
            echo -e "          if ( g3 eq $i ) jump titleset $i menu;"
        done
fi)
        </pre>
        <post>
$([[ $INTRO ]] && echo -e "        g2=1; jump vmgm menu entry title;")
        jump cell 1;
        </post>
$(for ((i=1; i<=${#TITLESET_OPTS[@]}; i++)); do echo "        <button name=\"$i\">jump titleset $i menu;</button>"; done)
        $INTRO
        <vob file="$BASEDIR/VMGM.mpg" pause="$VMGM_PAUSE_TIME"/>
      </pgc>
    </menus>
  </vmgm>
EOF
) |sed '/^ *$/d' >> "$DVDAUTHOR_XML"
    if [[ -z ${VMGM_OPTS[@]} ]]; then
        yecho
        yecho "You have not supplied -vmgm OPTIONS -end-vmgm"
        yecho "At a minumum you should have '-vmgm -titles "Title one" "Title two" -end-vmgm'"
        yecho "One title for each titleset you are making"
        yecho "Any other options for the vmgm menu can be specified too"
        yecho "Making a generic vmgm menu for you - you may wish to cancell out and change this"
        yecho
        ! $NO_VMGM_MENU && sleep 15
        VMGM_OPTS[0]="-titles"
        for ((menu=1; menu<=count; menu++)); do VMGM_OPTS[menu]="Titleset $menu"; done
    fi
    yecho
    yecho "Making a VMGM menu with the following command:"
    vmgm_menu_cmd=(todisc -out $OUT_PREFIX $QUICKNAV $NO_ASK -basedir "$WORK_DIR" \
    -menu-only -textmenu "${VMGM_OPTS[@]}")
#    vmgm_menu_cmd=(makemenu "${MENU_TITLE[@]}" -out VMGM -button play  -align middle $NO_ASK $VMGM_MENU_OPTS)
    yecho "Running: ${vmgm_menu_cmd[@]}"
    INITIALDIR="$BASEDIR"
    "${vmgm_menu_cmd[@]}"
   # TODO move to function so its not duplicated here and in main parser, generalize for -vmgm too 
    while test $# -gt 0; do
        DO_SHIFT=:
        case "$1" in
            "-titleset" )
                let tset=tset+1
                shift
                unset x ARGS_ARRAY TITLESET_OPTS
                # Hackish list-parsing
                while test $# -gt 0 && test "$1" != "-end-titleset"; do
                    ARGS_ARRAY[x++]="$1"
                    shift
                done
                # Do not skip past the next argument
                if test $# -gt 0 && test x"${1:0:1}" = x"-";then
                    DO_SHIFT=false
                fi
                TITLESET_OPTS=( "${ARGS_ARRAY[@]}" )
                titleset_cmd=( todisc -titleset-mode -basedir "$WORK_DIR" \
                -tset_num ${count}-${tset} $NO_ASK $KEEPFILES -out $OUT_PREFIX $NO_VMGM $QUICKNAV "${TITLESET_OPTS[@]}" )
                yecho
                yecho "Working on the menu for titleset number $tset"
                yecho
                yecho "Running: ${titleset_cmd[@]}"
                "${titleset_cmd[@]}"
                yecho
                ;;
        esac
        $DO_SHIFT && shift
    done
    echo -e "</dvdauthor>" >> "$DVDAUTHOR_XML"
    yecho "Running dvdauthor to create final DVD structure"
    dvdauthor -x "$DVDAUTHOR_XML" 2>&1 | tee -a "$LOG_FILE"
    if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
        runtime_error "There was a problem creating the DVD structure"
    fi
    yecho "Your new DVD should be in $OUT_DIR"
    cleanup

}

function parse_rotateargs()
{
    unset x ARGS_ARRAY
    # Hackish list-parsing
    while test $# -gt 0 && egrep -q '^[-+]?[[:digit:]]{1,2}+$' <<< "$1"; do
        ARGS_ARRAY[x++]="$1"
        shift
    done
    # Do not skip past the next argument
    if test $# -gt 0 && test x"${1:0:1}" = x"-";then
        DO_SHIFT=false
    fi
}

function make_upbutton()
{
upbutton="
begin-base64 644 "$TODISC_WORK/upbutton.png"
iVBORw0KGgoAAAANSUhEUgAAACQAAAA0EAYAAACyRkZAAAAABmJLR0T/////
//8JWPfcAAAACXBIWXMAAABIAAAASABGyWs+AAAAwklEQVRo3u3YwQ2EUAwD
UaD/nncvTAc4sb88BVjRO+a6WmuttdZaawb93rbv+KpHNXwKlAyI0qHkQJQK
NQZEaVDjQJQCtQZE7lDrQOQKZQNEblB2QOQCZQtE21D2QLQFFQNE01BxQDQF
FQtEaqh4IFJBHQOk6hig++3r3XggFQzFAqlhKA5oCoZigKZhyB5oC4ZsgbZh
yA7IBYZsgNxgaB3IFYbWgNxhaBwoBYbGgNJgSA6UCiNr+8neWmuttdZac+gP
ZbeIJQzWl6wAAAAASUVORK5CYII=
====
"
 
    uudecode <<< "$upbutton"
    convert -rotate -90 "$TODISC_WORK/upbutton.png" "$TODISC_WORK/upbutton.png"
}

##############################################################################
#                          	End of functions                                 #
##############################################################################

trap 'cleanup; exit 13' TERM INT

###############################################################################
#       Process arguments to the script, set up VARS and WORK_DIR             #
###############################################################################

# ***********************************
# EXECUTION BEGINS HERE
# ***********************************
egrep -q 'titleset-mode|switched-mode|menu-only' <<< "$@" && NONAME=:
! $NONAME && yecho $"$SCRIPT_NAME"

while test $# -gt 0; do
    DO_SHIFT=:
    case "$1" in
        "-files" )
            shift
            get_listargs "$@"
            for f in  ${!ARGS_ARRAY[@]}; do
                FILES[f]="$(abspath "${ARGS_ARRAY[f]}")"
            done
            ;;
        "-titleset" )
            shift
            unset x ARGS_ARRAY
            while test $# -gt 0 && test "$1" != "-end-titleset"; do shift ; done
            if test $# -gt 0 && test x"${1:0:1}" = x"-";then DO_SHIFT=false; fi
            TITLESET_OPTS[y++]="${ARGS_ARRAY[@]}"
            DO_TITLESETS=:
            ;;
       "-vmgm" )
            shift
            unset x ARGS_ARRAY
            # Hackish list-parsing
            while test $# -gt 0 && test "$1" != "-end-vmgm"; do
                ARGS_ARRAY[x++]="$1"
                shift
            done
            # Do not skip past the next argument
            if test $# -gt 0 && test x"${1:0:1}" = x"-";then
                DO_SHIFT=false
            fi
            VMGM_OPTS=( "${ARGS_ARRAY[@]}" )
            ;;
        "-group" )
            shift
            mk_workdir
            get_listargs "$@"
            unset group groupkey grp x
            for ((i=1; i<${#ARGS_ARRAY[@]}; i++)); do
                grp[x++]="$(abspath "${ARGS_ARRAY[i]}")"
            done
            GROUP_IN_FILES=( "${GROUP_IN_FILES[@]}" "${grp[@]}" )
            group="$(for ((b=0; b<${#grp[@]}; b++)); do echo -e "${grp[b]}"; done)"
            groupkey=$(( ${ARGS_ARRAY[0]} - 1))
            GROUP[groupkey]="$group"
            # create symlinks to ease substitution later
            for c in ${!grp[@]}; do
                ln -sv "${grp[c]}" $WORK_DIR/${TSET_NUM}-group-$((groupkey+1))-$((c+1)).mpg
            done
            GROUPING=:
            ;;
        "-titles" )
            shift
            get_listargs "$@"
            OIFS=$IFS
            IFS=""
            TITLES=( "${TITLES[@]}" "${ARGS_ARRAY[@]}" )
            IFS=$OIFS
            ;;
        "-submenu-titles" )
            shift
            get_listargs "$@"
            OIFS=$IFS;IFS=""
            SM_TITLES=( "${ARGS_ARRAY[@]}" )
            IFS=$OIFS
            ;;
        "-use-makemenu" )
            USE_MAKEMENU=:
            ;;
        "-out" )
            shift
            OUT_PREFIX="$1"
            ;;
        "-no-ask" | "-noask" )
            NOASK=:
            ;;
        "-no-warn" | "-nowarn" )
            NO_WARN=:
            ;;
        "-keep-files" | "-keepfiles" )
            KEEP_FILES=:
            KEEPFILES="-keep-files"
            ;;
        "-dvd" )
            TARGET=dvd
            ;;
        "-svcd" )
            TARGET=svcd
            ;;
        "-ntsc" )
            TV_STANDARD=ntsc
            ;;
        "-pal" )
            TV_STANDARD=pal
            ;;
        "-aspect" )
            unset ASPECT ASPECT_ARG
            shift
            ASPECT_ARG=$1
            if [[ ${#ASPECT_ARG[@]} -gt 0 ]]; then
            ASPECT=$ASPECT_ARG
            ASPECT_RATIO=$ASPECT
            V_ASPECT="aspect=\"$ASPECT\""
            fi
            ;;
        "-widescreen" )
            shift
            get_listargs "$@"
            wsarg=${ARGS_ARRAY[0]}
            [[ -n $wsarg ]] &&  WIDESCREEN=$wsarg || WIDESCREEN=nopanscan
            WIDE_SCREEN=:
            ;;
        "-showcase-safe-area" )
            ADV_OPT=( "${ADV_OPT[@]}" "$1" )
            shift
            SAFE_AREA="$1"
            let SAFE_OFFSET=86-SAFE_AREA
            USER_SAFE_AREA=:
            ;;
        "-align" )
            ADV_OPT=( "${ADV_OPT[@]}" "$1" )
            shift
            BUTTON_GRAVITY=$1
            [[ $BUTTON_GRAVITY = centre ]] && BUTTON_GRAVITY=center
            USER_GRAVITY=:
            ;;
        # Menu control options
        "-menu-length" )
            shift
            ANI_MENU_LENGTH="$1"
            ;;
        # submenu-length disabled for now
        "-submenu-length" )
            shift
            ANI_SUBMENU_LENGTH="$1"
            ;;
        "-static" )
            STATIC=:
            ;;
        "-bgimage" )
            usage_error "-bgimage This option has been removed. See: -background"
            ;;
        "-menu-fade" )
            MENU_FADE=:
            AUDIO_FADE=:
            ;;
        "-tile3x1" | "-tile-3x1" )
            THREExONE=:
            ;;
        "-loop" )
            shift
            PAUSE_TIME="$1"
            STATIC_LOOP=:
            ;;
        "-chain-videos" )
            shift
            get_listargs "$@"
            chains_in="${ARGS_ARRAY[@]}"
            post_play=${chains_in//,/ }
            CHAIN_VIDEOS=:
            ;;
        "-playall" )
            PLAYALL=:
            ;;
        "-bgvideo" )
            usage_error "-bgvideo This option has been removed. See: -background"
            ;;
        "-background" )
            shift
            BACKGROUND="$(abspath "$1")"
            ! [[ -e "$BACKGROUND" ]] && usage_error "$BACKGROUND does not exist"
            ;;
        "-showcase-video" )
            usage_error "-showcase-video This option has been removed. See: -showcase"
            ;;
        "-showcase-image" )
            usage_error "-showcase-image This option has been removed. See: -showcase"
            ;;
        "-showcase-no-thumb" )
            usage_error "-showcase-no-thumb This option has been removed. See: -showcase"
            ;;
        "-intro" )
            shift
            DO_INTRO=:
            INTRO_CLIP="$(abspath "$1")"
            ! [[ -e "$INTRO_CLIP" ]] && usage_error "$INTRO_CLIP does not exist"
            ;;
        "-showcase" )
            shift
            get_listargs "$@"
            unset f
            for f in  ${!ARGS_ARRAY[@]}; do
                SHOWCASE_FILE[f]="$(abspath "${ARGS_ARRAY[f]}")"
            done
            SHOWCASE=:
            IMG_FMT=png
            ;;
        "-textmenu" )
            shift
            get_listargs "$@"
            arg=${ARGS_ARRAY[0]}
            [[ -n $arg ]] && SPLIT=$arg && USER_SPLIT=:
            TEXTMENU=:
            SHOWCASE=:
            IMG_FMT=png
            SC_TITLE_ALIGN=west
            ;;
        "-text-start" )
            ADV_OPT=( "${ADV_OPT[@]}" "$1" )
            shift
            TEXT_YSTART=$1
            ;;
        "-showcase-titles-align" )
            shift
            SC_TITLE_ALIGN="$1"
            [[ SC_TITLE_ALIGN = centre ]] && SC_TITLE_ALIGN=center
            ;;
        "-title-gap" )
            ADV_OPT=( "${ADV_OPT[@]}" "$1" )
            shift
            SPACER=$1
            ;;
        "-rotate" )
            shift
            ROTATE_DEGREES="$1"
            ROTATE="-rotate $ROTATE_DEGREES"
            IMG_FMT=png
            ;;
        "-wave" )
            shift
            WAVE=$1
            if [ "$WAVE" = default ]; then
                WAVE="-wave -20x556"
            else
                WAVE="-wave $1"
            fi
            ;;
        "-showcase-framestyle" )
            shift
            SC_FRAMESTYLE="$1"
            ;;
        "-thumb-shape" )
            shift
            THUMB_SHAPE="$1"
            FEATHER=:
            IMG_FMT=png
            ;;
        "-button-style" )
            shift
            BUTTON_STYLE="$1"
            USER_BSTYLE=:
            ;;
        "-3dthumbs" )
            THUMBS_3D=:
            RAISE="-raise 8x8"
            THUMB_FRAME=""
            ;;
        "-blur" )
            shift
            BLUR="$1"
            ;;
        "-title-colour" | "-title-color" )
            shift
            TITLE_COLOUR="$1"
            ;;
        "-submenu-title-colour" | "-submenu-title-color" )
            shift
            SM_TITLE_COLOUR="$1"
            ;;
        "-stroke-colour" | "-stroke-color" )
            shift
            STROKE="$1"
            ;;
        "-submenu-stroke-colour" | "-submenu-stroke-color" )
            shift
            SUBMENU_STROKE="$1"
            ;;
        "-thumb-text-colour" | "-thumb-text-color" )
            shift
            THUMB_TEXT_COLOUR="$1"
            ;;
        "-highlight-colour" | "-highlight-color" )
            shift
            HIGHLIGHT_COLOUR="$1"
            ;;
        "-select-colour" | "-select-color" )
            shift
            SELECT_COLOUR="$1"
            ;;
        "-selectcolour" | "-selectcolor" | "-highlightcolour" | "-highlightcolor" | "-submenu-audiolength" | "-menu-audiolength")
            usage_error "$1 is depricated, option names are now split with logical hyphens where appropriate"
            ;;
        "-text-mist" )
            MIST=:
            ;;
        "-text-mist-opacity" )
            shift
            MIST_OPACITY="$1"
            ;;
        "-text-mist-colour" |"-text-mist-color" )
            shift
            MIST_COLOUR="$1"
            ;;
        "-thumb-mist-colour" |"-thumb-mist-color" )
            shift
            THUMB_BG_COLOUR="$1"
            ;;
        "-opacity" )
            shift
            TRANSPARENT=:
            OPACITY="$1"
            ;;
        "-chapters" )
            unset CHAPTERS
            shift
            get_listargs "$@"
            CHAPTERS="${ARGS_ARRAY[@]}"
            CHAPTERS=( ${CHAPTERS//,/ } )
            ;;
        "-subtitles" )
            shift
            SUBTITLES=:
            get_listargs "$@"
            SUBS="${ARGS_ARRAY[@]}"
            SUBS_ARRAY=( ${SUBS//,/ } )
            ;;
        "-audio-lang" )
            shift
            get_listargs "$@"
            AUDIO_LANG="${ARGS_ARRAY[@]}"
            AUDIO_LANG=( ${AUDIO_LANG//,/ } )
            AUDIOLANG=:
            ;;
        "-bgaudio" )
            shift
            BG_AUDIO="$(abspath "$1")"
            ! [[ -e "$BG_AUDIO" ]] && usage_error "$BG_AUDIO does not exist"
            ;;
        "-menu-audio-fade" )
            shift
            FADE="$1"
            AUDIO_FADE=:
            ;;
        "-menu-audio-length" )
            shift
            MENU_AUDIOLENGTH="$1"
            ;;
        "-submenu-audio" )
            shift
            get_listargs "$@"
            for i in ${!ARGS_ARRAY[@]}; do
                if [[ ${ARGS_ARRAY[i]} = "none" ]]; then
                    SM_AUDIO=( "${SM_AUDIO[@]}" "${ARGS_ARRAY[i]}" )
                else
                    SM_AUDIO=( "${SM_AUDIO[@]}" "$(abspath "${ARGS_ARRAY[i]}")" )
                fi
            done
            SUBMENU_AUDIO=:
            ;;
        "-submenu-audio-length" )
            shift
            SUBMENU_AUDIOLENGTH="$1"
            ;;
        "-submenu-audio-fade" )
            shift
            SM_FADE="$1"
            SM_AUDIO_FADE=:
            ;;
        "-submenus" )
            SUB_MENU=:
            ;;
        "-ani-submenus" )
            ANI_SUB_MENU=:
            SUB_MENU=:
            ;;
        "-menu-title" )
            shift
            MENU_TITLE="$1"
            ;;
        "-menu-font" )
            shift
            MENU_FONT="$(get_font "$1")"
            ;;
        "-menu-fontsize" )
            shift
            MENU_FONTSIZE="$1"
            ;;
        "-thumb-font" )
            shift
            THUMB_FONT="$(get_font "$1")"
            ;;
        "-thumb-fontsize" )
            shift
            THUMB_FONTSIZE="$1"
            ;;
        "-seek" )
            shift
            unset SEEK_VAL
            get_listargs "$@"
            SEEK_VAL="${ARGS_ARRAY[@]}"
            SEEK_VAL=( ${SEEK_VAL//,/ } )
            ;;
        "-showcase-seek" )
            shift
            SHOWCASE_SEEK_VAL="$1"
            ;;
        "-bgvideo-seek" )
            shift
            BG_SEEK="$1"
            ;;
        "-bgaudio-seek" )
            shift
            BG_AUDIO_SEEK="$1"
            ;;
        "-showcase-geo" )
            ADV_OPT=( "${ADV_OPT[@]}" "$1" )
            shift
            USER_SC_GEO=:
            SHOWCASE_GEO=$1
            ;;
        "-menu-title-geo" )
            ADV_OPT=( "${ADV_OPT[@]}" "$1" )
            USER_TITLE_GEO=:
            shift
            TITLE_GRAVITY=$1
            TITLE_GRAVITY=${TITLE_GRAVITY/re/er}
            ;;
        "-menu-title-offset" )
            ADV_OPT=( "${ADV_OPT[@]}" "$1" )
            USER_TITLE_GEO=:
            shift
            [[ $1 =~ \([-+][0-9]+\)\([-+][0-9]+\) ]];
            [[ -n ${BASH_REMATCH[1]} ]] && title_xoffset=${BASH_REMATCH[1]}
            [[ -n ${BASH_REMATCH[2]} ]] && title_yoffset=${BASH_REMATCH[2]}
            ;;
        "-outlinewidth" )
            ADV_OPT=( "${ADV_OPT[@]}" "$1" )
            shift
            OUTLINEWIDTH=\"$1\"
            ;;
        "-rotate-thumbs" )
            shift
            parse_rotateargs "$@"
            ROTATE_ARRAY=( "${ARGS_ARRAY[@]}" )
            IMG_FMT=png
            ROTATE_THUMBS=:
            ;;
        "-tovidopts" )
            shift
            TOVID_OPTS="$1"
            ;;
        "-titleset-mode" )
            # used internally by todisc, do NOT pass as a user option !
            AUTHOR=false
            TITLESET_MODE=:
            ;;
        "-switched-mode" )
            # used internally by todisc, do NOT pass as a user option !
            SWITCHED_MODE=:
            BUTTON_STYLE=text-rect
            TEXTMENU=:
            SC_TITLE_ALIGN=west
            SHOWCASE=:
            ;;
        "-menu-only" ) # internal use only
            VMGM_ONLY=:
            ;;
        "-basedir" ) # internal use only
            shift
            BASEDIR="$1"
            ;;
        "-tset_num" ) # internal use only
            shift
            TSET_NUMS="$1"
            TSET_NUM=${TSET_NUMS/*-}
            TSET_TOT=${TSET_NUMS/-*}
            ;;
        "-menu_num" ) # internal use only
            shift
            MENU_NUM="$1"
            ;;
        "-quick-nav" )
            QUICK_NAV=:
            ;;
        "-switched-menus" )
            SWITCHED_MENUS=:
            BUTTON_STYLE=text-rect
            TEXTMENU=:
            SHOWCASE=:
            SC_TITLE_ALIGN=west
            ;;
        "-skip-vmgm" )
            SKIP_VMGM_MENU=:
            ;;
        "-no-vmgm-menu" | "-no-vmgm" )
            NO_VMGM_MENU=:
            ;;
        "-is_titleset" ) #FIXME - this is useless
            TSET_MODE=:
            ;;
    esac
    $DO_SHIFT && shift
done

##############################################################################
#                      Sanity checks and preliminaries                       #
##############################################################################
# Make sure equal, nonzero number of titles and files were provided
if ! $VMGM_ONLY && ! $DO_TITLESETS; then
    if test ${#FILES[@]} -eq 0 || test ${#TITLES[@]} -eq 0; then
        usage_error "Please provide at least one file and one title."
    elif test ${#FILES[@]} -ne ${#TITLES[@]}; then
        usage_error "Please give the same number of files as titles.
        You gave ${#FILES[@]} files and ${#TITLES[@]} titles"
    fi
fi
if [[ -n "$SM_TITLES" ]]; then
    if test ${#SM_TITLES[@]} -ne ${#TITLES[@]}; then
    usage_error "Please give the same number of submenu titles as titles.
    You gave ${#SM_TITLES[@]} submenu titles and ${#TITLES[@]} titles"
    fi
fi
# titlesets use BASEDIR which is the WORK_DIR of the calling todisc
# BASEDIR is supplied by the calling todisc with -basedir
: ${BASEDIR:="$WORK_DIR"}
# Make sure -out was provided
if test -n "$OUT_PREFIX"; then
    OUT_DIR="$(abspath "$OUT_PREFIX")"
    [[ $TARGET = svcd ]] && OUT_FILE="$OUT_DIR"
     if egrep -q '<|>|&' <<< "$OUT_DIR"; then
        usage_error "Sorry, dvdauthor will not let you use a -out name with '>', '<' or '&' in it.  Please choose another directory or name for -out  You used: "$OUT_DIR""
    fi
else
    usage_error "Please provide an output name with -out"
fi
# for dvdauthor.xml, if -intro was used
$DO_INTRO && INTRO="<vob file=\"$INTRO_CLIP\"/>"
# don't make submenus on each recursive call in switched mode
if $SWITCHED_MODE; then
    ANI_SUB_MENU=false && SUB_MENU=false
fi
# need a way to get back to the VMGM menu, so -no-vmgm-menu requires -quicknav ? FIXME
# -no-vmgm requires -skip-vmgm for now; pass -no-vmgm-menu to subshells via NO_VMGM
if $NO_VMGM_MENU; then
    SKIP_VMGM_MENU=:
    NO_VMGM="-no-vmgm-menu"
fi
# honour -noask for functions and called scripts that use them
$NOASK && NO_ASK="-noask"
# Warn if thumb labels have more than 16 characters
if ! $SHOWCASE; then
    for ((i=0; i<${#TITLES[@]}; i++)); do
        val=${#TITLES[i]}
        [ -z "$MAX_CHARS" ] || ((val > MAX_CHARS)) && MAX_CHARS=$val && key=$i
    done
    if [[ ${#TITLES[@]} -gt 6 && $MAX_CHARS -gt 16 ]]; then
        yecho
        yecho "WARNING! Some titles are longer than 16 characters; they may be chopped off."
        yecho
        #echo "\"${TITLES[key]}\" is too long; please use a shorter title."
        #exit 1
    fi
fi
# disallow spaces in thumb titles for text button style
if [ "$BUTTON_STYLE" = "text" ]; then
    for ((i=0; i<${#TITLES[@]}; i++)); do
        if grep "  " <<< "${TITLES[i]}" >/dev/null; then
            echo "Sorry, a maximum of one consecutive space is allowed in titles for text buttons"
            echo "\"${TITLES[i]}\" has more than one consecutive space in it"
            exit 1
        fi
    done
    if $SHOWCASE; then
        BUTTON_STYLE="line"
        yecho
        yecho "You can not use text button style with showcase or textmenu"
        yecho "Changing button style to 'line' style instead"
        yecho "If you would rather use 'text-rect', or 'rect' for showcase,"
        yecho "please ctrl-c now to exit and rethink things"
        yecho
        ! $NO_WARN && sleep 15
    fi
fi
if [[ $BUTTON_STYLE = "line" ]] && ! $SHOWCASE; then
    yecho
    yecho "Sorry, button style 'line' is only for showcase and textmenu styles"
    yecho "Using button style 'rect' instead"
    yecho
    BUTTON_STYLE="rect"
    ! $NO_WARN && sleep 10
fi
# allow multiline titles in submenu
if [[ -n "$SM_TITLES" ]]; then
    for i in ${!SM_TITLES[@]}; do
        if [[ $(echo -e "${SM_TITLES[i]}" |wc -l) -gt 1 ]]; then
            SM_TITLES[i]="$(echo -e  "${SM_TITLES[i]}")"
        fi
    done
fi

# set a maximum # of videos
if $SHOWCASE; then
    $TEXTMENU && file_max=30 || file_max=10
    test  ${#FILES[@]} -gt $file_max && \
    usage_error "Sorry, a maximum of $file_max titles is allowed for this style
    You gave ${#FILES[@]} videos as input"
else
    if test ${#FILES[@]} -gt 30; then
        usage_error "Sorry, a maximum of 30 videos (thumbs) is supported
        You gave ${#FILES[@]} videos as input"
    fi
fi

# -rotate-thumbs broken for 3dthumbs and shaped thumbs
if ($FEATHER || $THUMBS_3D) && $ROTATE_THUMBS; then
    if ! $SHOWCASE; then
        yecho
        yecho "Sorry, rotated thumbs does not work currently"
        yecho "if you use shaped or 3d thumbs unless using showcase style"
        yecho "Disabling this option for you"
        yecho "Please ctrl-c now to exit if you wish to examine the situation"
        yecho
        ! $NO_WARN && sleep 15
        unset ROTATE_ARRAY; ROTATE=false
    fi
fi

# If output directory already exists, print a message and exit
if test -e "$OUT_DIR"; then
    echo "Cleaning up created dirs"
    yecho
    echo "A file or directory named\"$OUT_DIR\" already exists."
    echo "Please use a different -out name, or (re)move the existing file or directory."
    rm -rf "$REAL_WORK_DIR"
    rm -f "$WORK_DIR"
    exit 1
fi
# see if advanced options were used and give warning if so
if [[ -n "${ADV_OPT[@]}" ]]; then
    yecho
    yecho "**** WARNING ****"
    yecho "You have used the following advanced options:"
    yecho \'"${ADV_OPT[@]}"\' | format_output
    yecho "With these options it is possible to create a menu where things overlap or"
    yecho "are offscreen, or that has other problems, so please check it with the preview."
    yecho "These are things that todisc tries to avoid normally, so if you have problems, please leave them out."
    yecho
    ! $NO_WARN && sleep 15
fi

# Do text-only menu if requested
if $USE_MAKEMENU; then
    call_makemenu
    exit
fi
# copy symlinks for -group hack
if $GROUPING && $TITLESET_MODE; then
    find "$WORK_DIR"/  -type l -name \*group\*.mpg -exec cp -Pv {} "$BASEDIR" \;
fi
$SWITCHED_MODE && SWITCHED_MENUS=false
#$SWITCHED_MODE && KEEP_FILES=false
if $SWITCHED_MENUS; then
    # call todisc recursively, collect intro.mpg, exit
    switched_menu_mode "${args[@]}"
fi
if $DO_TITLESETS; then
    # call todisc recursively, collect parts and author.  Then exit
    titleset_mode "${args[@]}"
    yecho Goodbye
    exit
fi
# set some vars for the last run of switched menus (non-recursive )
$SWITCHED_MENUS && SHOWCASE_FILE="${FILES[0]}"

# double check sox is installed, as the consequence of not having it is ugly
confirm_dep sox "http://sox.sourceforge.net/"

yecho
yecho "Creating work directories"
yecho

# create an array of grouped files. Hopefully LC_ALL=C takes care of sort issues
if $GROUPING; then
    LC_ALL=C grouping=( $WORK_DIR/${TSET_NUM}-group* )
fi

# Clean out any existing WORK_DIR
# link WORK_DIR to /tmp for easy solution to spaces, illegal chars bugs
! $GROUPING && ! $SWITCHED_MENUS && mk_workdir

# Remove any existing log file
if ! $SWITCHED_MODE && ! $TITLESET_MODE && ! $DO_TITLESETS; then
    test -f "$LOG_FILE" && rm -fv "$LOG_FILE"
fi
# check file type of background file and assign to BG_VIDEO or BG_IMAGE
if [[ -n $BACKGROUND ]]; then
    check_filetype "$BACKGROUND"
    if [[ $TYPE = image ]]; then
        BG_PIC="$BACKGROUND"
    elif [[ $TYPE = video ]]; then
        BG_VIDEO="$BACKGROUND"
    else
        usage_error "Sorry, can not identify "$BACKGROUND""
    fi
fi
# if $SHOWCASE, find out if using SHOWCASE_VIDEO or SHOWCASE_IMG or NO_SC_THUMB
if $SHOWCASE; then
    if [[ -n ${SHOWCASE_FILE[@]} ]]; then
        check_filetype "${SHOWCASE_FILE[@]}"
        if [[ $TYPE = image ]]; then
            SHOWCASE_IMG="${SHOWCASE_FILE[@]}"
        elif [[ $TYPE = video ]]; then
            SHOWCASE_VIDEO="${SHOWCASE_FILE[@]}"
        else
            usage_error "Sorry, can not identify showcase file: "${SHOWCASE_FILE[@]}""
        fi
    else
        NO_SC_THUMB=:
        SHOWCASE_IMG="dummy"
    fi
fi
if [[ $SC_FRAMESTYLE = glass ]] && [[ -z $SHOWCASE_IMG && -z $SHOWCASE_VIDEO ]]; then
    yecho
    yecho "You must use a -showcase option for '-showcase-framestyle'"
    yecho "Either -showcase IMAGE, -showcase VIDEO or just '-showcase'"
    yecho "Disabling this option for you - please ctrl-c now to exit"
    yecho "if you wish to reexamine the situation"
    yecho
    SC_FRAMESTYLE="none"
fi

# disable submenus for svcd
if $SUB_MENU && [ "$TARGET" = svcd ]; then
    usage_error "Sorry, submenu disabled for svcd for now, please remove -submenu option"
fi
[[ $TARGET = svcd ]] && $SHOWCASE && ! $TEXTMENU && usage_error "Sorry, showcase disabled for svcd target"
$SUB_MENU && $GROUPING && usage_error "Sorry, no submenus when using -group"
# allow user to only specify one audio file for all submenus
if [ ${#SM_AUDIO[@]} -eq 1 ]; then
    SM_AUDIO_FILE=${SM_AUDIO[0]}
fi
# if more than one audio file for submenu make sure they equal video #
if [[ ${SM_AUDIO[@]} &&  ${#FILES[@]} -ne ${#SM_AUDIO[@]} &&  ${#SM_AUDIO[@]} -ne 1 ]]; then
    usage_error "Please give the same number of submenu audios as videos.
    You gave ${#FILES[@]} video files and ${#SM_AUDIO[@]} audio files"
fi
# Get absolute pathnames of all files
if ! $VMGM_ONLY; then
    for i in "${FILES[@]}"; do
        IN_FILES=("${IN_FILES[@]}" "$(abspath "$i")")
        echo "Adding: $i"
    done
fi
$VMGM_ONLY && V_TOTAL=$(( ${#TITLES[@]} - 1 )) || V_TOTAL=${#IN_FILES[@]}
$VMGM_ONLY && NUM_FILES=$(( ${#TITLES[@]} - 1 )) || NUM_FILES=$((V_TOTAL - 1))

# switch title position when appropriate so it doesn't get covered up
! $USER_TITLE_GEO && [[ $BUTTON_GRAVITY = *south* ]] && TITLE_GRAVITY=north
if [[ $BUTTON_GRAVITY = *east* || $BUTTON_GRAVITY = *west* ]]; then
    ! $USER_GEO &&  XGEO=45 && YGEO=45
    ! $SHOWCASE && ! $USER_TITLE_GEO && TITLE_GRAVITY=north
fi
! $SHOWCASE && [[ $BUTTON_GRAVITY = center ]] && ! $USER_TITLE_GEO && TITLE_GRAVITY=north
# dvdauthor stuff
# make an array of possible vars for dvdauthor post calls
if $CHAIN_VIDEOS; then
    if [ -z "$post_play" ]; then
        for ((i=0; i<NUM_FILES; i++)); do
                POST_PLAY[i]=chain
            done
    else
        for j in $post_play; do
            if [[ $j = *-* ]]; then
                for ((i=${j/-*}; i<=${j/*-}; i++)); do
                    POST_PLAY[i-1]=chain
                done
            elif [[ $j != *[^0-9]* ]]; then
                POST_PLAY[j-1]=chain
            fi
        done
    fi
    echo
    for ((n=0; n<=NUM_FILES; n++)); do
        if [ "${POST_PLAY[n]}" = "chain" ]; then
            if [ $n -lt $NUM_FILES ]; then
                echo "video $((n+1)) will be chained with video $((n+2))"
            else
                echo "video $((n+1)) will be chained with video 1"
            fi
        fi
    done
    echo
fi
# allow user to specify one # of chapters for all videos
if [ ${#CHAPTERS[@]} -eq 1 ]; then
    for ((i=0; i<=NUM_FILES; i++)); do
        CHAPTERS[i]=${CHAPTERS[0]}
    done
fi

# if more than one value for CHAPTERS, make sure they equal video #
if $SUB_MENU &&  [[ ${#FILES[@]} -ne ${#CHAPTERS[@]} &&  ${#CHAPTERS[@]} -ne 1 ]]; then
    usage_error "Please give the same number of chapters as videos.
    You gave ${#FILES[@]} video files and ${#CHAPTERS[@]} chapter values"
fi
# find out longest chapter value (number of chapters)
if $SUB_MENU; then
    for ((i=0; i<${#CHAPTERS[@]}; i++)); do
        chapt_val=${CHAPTERS[i]}
        [ -z "$MAX_CHAPTERS" ] || ((chapt_val > MAX_CHAPTERS)) && MAX_CHAPTERS=$chapt_val && max_chapt_key=$i
        [ -z "$MIN_CHAPTERS" ]  || ((chapt_val < MIN_VAL)) && MIN_CHAPTERS=$chapt_val && min_chapt_key=$i
    done
fi
# do not let user use -chapters 0 (-chapters 5 0 6)
if $SUB_MENU; then
    chapter_error=false
    for ((i=0; i<${#CHAPTERS[@]}; i++)); do
        if ((${CHAPTERS[i]} == 0)) && [[ -z ${GROUP[i]} ]]; then
            CHAPTERS[i]=1
            chapter_error=:
        fi
    done
    if $chapter_error; then
        yecho
        yecho "Please use -chapters 1 not -chapters 0, if you do not want chapters."
        yecho "-chapters 0 is a special case for -group videos, meaning the each video is a chapter."
        yecho "Changing all chapters that were '0' to '1' for you"
        yecho "Please ctrl-c to exit if you wish to reexamine the situation"
        yecho
        ! $NO_WARN && sleep 15
    fi
fi
# create_dirs
echo
yecho "Creating pics directories..."
for ((i=0; i<=NUM_FILES; i++)); do
    mkdir -pv "$REAL_WORK_DIR/pics/$i"
done
# textmenu is static unless there is an animated background or showcase video
if $TEXTMENU && [[ -z $SHOWCASE_VIDEO && -z $BG_VIDEO ]]; then STATIC=:; fi
# prevent user from using mutually exclusive options
if $STATIC; then
    MENU_FADE=false
fi
if [ $FADE = 0 ]; then # in case user thinks he needs to specify 0 for fade
    AUDIO_FADE=false
elif [ $SM_AUDIO_FADE = 0 ]; then
    SM_AUDIO_FADE=false
fi
if $MENU_FADE || test -n "$BG_VIDEO"; then mkdir -v "$REAL_WORK_DIR/bg"; fi
mkdir -v "$REAL_WORK_DIR/animenu"
if $ANI_SUB_MENU; then
    for ((i=0; i<MAX_CHAPTERS; i++)); do
        mkdir -v "$REAL_WORK_DIR/animenu/$i"
    done
fi
if $SUB_MENU && ! $ANI_SUB_MENU; then
    mkdir -v "$REAL_WORK_DIR/submenu"
fi
if [[ -n "$SHOWCASE_VIDEO" ]]; then
    mkdir -v "$REAL_WORK_DIR/showcase"
fi
# if Fading menu, and no BG IMAGE OR VIDEO, fade thumbs right in after title
if $MENU_FADE && [[ -z "$BG_PIC" && -z "$BG_VIDEO" ]]; then
    THUMBS_FADE_IN_START_TIME=2.5
fi
# if more than one value for AUDIO_LANG, make sure they equal video #
if $AUDIOLANG &&  [[ ${#FILES[@]} -ne ${#AUDIO_LANG[@]} &&  ${#AUDIO_LANG[@]} -ne 1 ]]; then
    usage_error "Please give the same number of audio channels as videos.
    You gave ${#FILES[@]} video files and ${#AUDIO_LANG[@]} audio channel values"
fi
# make sure number of -rotate-thumbs arguments equals number of videos
if [[ -n ${ROTATE_ARRAY[@]} ]]; then
    if  [[ ${#FILES[@]} -ne ${#ROTATE_ARRAY[@]} ]]; then
        usage_error "Please give the same number of thumb rotate values as videos.
        You gave  ${#FILES[@]} video files and ${#ROTATE_ARRAY[@]} thumb rotate values."
    fi
fi
# if only one seek value, then use for all videos
if [ ${#SEEK_VAL[@]} -eq 1 ]; then
    for ((i=0; i<=NUM_FILES; i++)); do
        SEEK_VAL[i]=${SEEK_VAL[0]}
        SEEK[i]="-ss ${SEEK_VAL[i]}" # create seek value for each video
    done
fi
# make sure if more than one seek value, they equal the number of video
if ! $VMGM_ONLY &&  [[ ${#FILES[@]} -ne ${#SEEK_VAL[@]} &&  ${#SEEK_VAL[@]} -ne 1 ]]; then
    usage_error "Please give the same number of seek times as videos, or just use one value.
    You gave ${#FILES[@]} video files and ${#SEEK_VAL[@]} seek times"
fi
#create seek value for each video
for ((i=0; i<=NUM_FILES; i++)); do
    # translate SEEK_VAL into frames for transcode
    SEEK_FRAMES[i]=$(awk_math ${SEEK_VAL[i]} times $FRAME_RATE)
done
# var for dcdemux and the navigation log
#TCDEMUX_MODE="-M 0"
if ! $VMGM_ONLY; then
    echo
    echo "Verifying that input files are video files"
    for ((i=0; i<=NUM_FILES; i++)); do
        IN_FILE="${IN_FILES[i]}"
        if test -e "$IN_FILE"; then
            if mencoder -quiet -oac pcm -ovc copy \
            -frames 0 -o /dev/null "$IN_FILE" &>/dev/null; then
                echo "$IN_FILE ok"
            else
                usage_error "Sorry, $IN_FILE is not a video file"
            fi
        else
            usage_error "Sorry, $IN_FILE does not exist"
        fi
    done
    echo
fi
##############################################################################
# Font defaults
##############################################################################

# Menu title font size
test $TARGET = "dvd" && : ${MENU_FONTSIZE:="30"}
test $TARGET = "svcd" && : ${MENU_FONTSIZE:="26"}
# Thumbnail title font size
if test -z "$THUMB_FONTSIZE"; then
# if not -thumb-fontsize N passed, use default, based on the following:
    if $SHOWCASE; then
        if test "$NUM_FILES" -lt 2; then
            THUMB_FONTSIZE=20
        elif  test "$NUM_FILES" -eq 2; then
            THUMB_FONTSIZE=18
        elif  test "$NUM_FILES" -ge 3; then
            THUMB_FONTSIZE=16
        fi
    else
        THUMB_FONTSIZE=10
    fi
fi

# See if "Helvetica" or "helvetica" are available as default fonts
if convert -size 50x20 xc:none -font Helvetica -gravity Center \
-draw "text 0,0 'test'" "$WORK_DIR/font.png"; then
    DEFAULT_FONT="Helvetica"
elif convert -size 200x100 xc:none -font helvetica -gravity Center \
-draw "text 0,0 'test'" "$WORK_DIR/font.png"; then
    DEFAULT_FONT="helvetica"
fi
# If user did not specify fonts, use default
test -z "$MENU_FONT" && MENU_FONT=$DEFAULT_FONT
test -z "$THUMB_FONT" && THUMB_FONT=$DEFAULT_FONT
rm -f "$WORK_DIR/font.png"


# Some user feedback
yecho
yecho "Disc title: \"$MENU_TITLE\""
yecho "  (adjust with -menu-title)"
yecho "Including the following videos:"
# do not echo all of long or multiline titles AND files
for ((i=0; i<${#TITLES[@]}; i++)); do
    if [[ ${#TITLES[i]} -gt 35 || $(echo -e "${TITLES[i]}" |wc -l) -gt 1 ]]; then
        TITLE[i]=$(sed 's/^  *//'<<<${TITLES[i]//\\n/ }) # remove spaces and \n
        TITLE[i]=${TITLE[i]:0:35} # cut down to 35 characters maximum
        if [ ${#TITLES[i]} -gt 35 ]; then
            echo "  \"${TITLE[i]}...\" (${IN_FILES[i]})" # "..." if truncated
        else
            echo "  \"${TITLE[i]}\" (${IN_FILES[i]})"
        fi
    else # echo titles "as is"
        echo "  \"${TITLES[i]}\" (${IN_FILES[i]})"
    fi
    if [[ $(echo -e "${TITLES[i]}" |wc -l) -gt 1 ]]; then
        # if there is a multiline title we need to align to right of thumbs
        SC_TITLE_ALIGN=east
        ALIGN_OVERRIDE=:
    fi
done
yecho "Current font settings: "
yecho "  -menu-font $MENU_FONT"
yecho "  -menu-fontsize $MENU_FONTSIZE"
yecho "  -thumb-font $THUMB_FONT"
yecho "  -thumb-fontsize $THUMB_FONTSIZE"
if ! $VMGM_ONLY; then
    yecho "Current menu settings: "
    if  ! $STATIC; then
        yecho "  -menu-length $ANI_MENU_LENGTH seconds"
    fi
    if $ANI_SUB_MENU; then
        yecho "  -submenu-length $ANI_SUBMENU_LENGTH seconds"
        if $SUBMENU_AUDIO; then
            yecho "  -submenu-audio-fade $SM_FADE second(s)"
        fi
    fi
        for ((i=0; i<=NUM_FILES; i++)); do
            echo -n "Video $((i+1)):"
            echo -n "  -seek ${SEEK_VAL[i]} second(s)"
            echo "  -chapters ${CHAPTERS[i]}"
        done
    if [ ! $STATIC ]; then
        yecho "  -menu-audio-fade $FADE second(s)"
    fi
    yecho
fi


# TODO: Merge these globals with the ones up top
DVD_GEO_ARRAY=(320x240 272x204 192x144 192x144 184x138 184x138 136x102 136x102 \
120x90 120x90 120x90 120x90 96x72 96x72 96x72 96x72 96x72 96x72 96x72 96x72 \
80x60 80x60 80x60 80x60 80x60 80x60 80x60 80x60 80x60 80x60 60x40 40x30)
SVCD_GEO_ARRAY=(240x240 180x180 120x120 120x120 120x120 120x120 96x96 96x96 \
96x96 80x80 80x80 80x80 64x64 64x64 64x64 64x64 64x64 64x64 64x64 64x64 \
48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48)
TILE_ARRAY=(1x1 2x1 2x2 2x2 3x2 3x2 4x2 4x2 3x3 4x3 4x3 4x3 4x4 4x4 4x4 \
4x4 5x4 5x4 5x4 5x4 5x5 5x5 5x5 5x5 5x5 6x5 6x5 6x5 6x5 6x5 6x6 6x6)
SHOWCASE_THUMB_Y_ARRAY=("166" "110 240" "75 175 275" "68 148 228 308" \
"68 131 194 257 320" "75 175 275 75 175 275" "68 148 228 308 68 148 228" \
"68 148 228 308 68 148 228 308" "68 131 194 257 320 68 131 194 257" \
"68 131 194 257 320 68 131 194 257 320")
SHOWCASE_TITLES_Y_ARRAY=("144" "88 218" "54 154 254" \
"50 130 210 290" "49 112 175 238 301" "54 154 254 54 154 254" \
"50 130 210 290 50 130 210" "50 130 210 290 50 130 210 290" \
"49 112 175 238 301 49 112 175 238" \
"49 112 175 238 301 49 112 175 238 301")
SHOWCASE_THUMB_X_ARRAY=("86" "86 86" "86 86 86" "86 86 86 86" \
"86 86 86 86 86" "86 86 86 538 538 538" "86 86 86 86 554 554 554" \
"86 86 86 86 554 554 554 554" "86 86 86 86 86 574 574 574 574" \
"86 86 86 86 86 574 574 574 574 574")
SHOWCASE_THUMB_X_ARRAY=( ${SHOWCASE_THUMB_X_ARRAY[NUM_FILES]} )
SHOWCASE_THUMB_Y_ARRAY=( ${SHOWCASE_THUMB_Y_ARRAY[NUM_FILES]} )
SHOWCASE_TITLES_X_ARRAY=( ${SHOWCASE_THUMB_X_ARRAY[@]} )
SHOWCASE_TITLES_Y_ARRAY=( ${SHOWCASE_TITLES_Y_ARRAY[NUM_FILES]} )
if $TEXTMENU ; then
    ! $USER_SPLIT && SPLIT=13 # max number of text only titles in one column (-textmenu)
    if [[ $NUM_FILES -gt 12 ]] && ! $USER_SPLIT; then
        SPLIT=$((V_TOTAL / 2))
        [[ $(( SPLIT * 2)) -ne $V_TOTAL ]] && let SPLIT=SPLIT+1
    fi
#    for ((b=0; b<=NUM_FILES; b++)); do
#        ((b < SPLIT)) && SHOWCASE_TITLES_X_ARRAY[b]=86 || SHOWCASE_TITLES_X_ARRAY[b]=360
#    done
fi
# needed to centre showcase img: col 1 will always be larger value than col 2
if $SHOWCASE && ! $TEXTMENU; then
    ((NUM_FILES < 5)) && SPLIT=$((NUM_FILES+1))
    ((NUM_FILES == 5)) && SPLIT=3
    ((NUM_FILES >= 6)) && SPLIT=4
    ((NUM_FILES >= 8)) && SPLIT=5
fi
if  [ $TARGET = "dvd" ]; then
    AUDIO_EXT="ac3"
    SAMPLERATE="48000"
    MPLEX_FORMAT="8"
    GEO_ARRAY=("${DVD_GEO_ARRAY[@]}")
    FFMPEG_OPTS="-b 7000k  -maxrate 8000k -bufsize 230KiB  -aspect $ASPECT_RATIO"
    SHOWCASE_SIZE=384x256
    if [ $TV_STANDARD = ntsc ]; then
        VIDSIZE="720x480"
        FRAME_RATE=29.970
    elif [ $TV_STANDARD = pal ]; then
        VIDSIZE="720x576"
        FRAME_RATE=25
    fi
elif [ $TARGET = "svcd" ]; then
    AUDIO_EXT="mp2"
    SAMPLERATE="44100"
    MPLEX_FORMAT="4"
    GEO_ARRAY=("${SVCD_GEO_ARRAY[@]}")
    FFMPEG_OPTS="-b 2200k -minrate 2200k -maxrate 2200k -bufsize 112KiB -aspect $ASPECT_RATIO"
    SHOWCASE_SIZE=256x256
    if [ $TV_STANDARD = ntsc ]; then
        VIDSIZE="480x480"
        FRAME_RATE=29.970
    elif [ $TV_STANDARD = pal ]; then
        VIDSIZE="480x576"
        FRAME_RATE=25
    fi
fi
THUMB_SIZE="${GEO_ARRAY[NUM_FILES]}"
if $SHOWCASE; then
    if [ -z ${BLUR/.*} ]; then
        BLUR=0.${BLUR/*.}
    fi
    if [ ${BLUR/.*} -ge 2 ]; then
        BLUR=2.0
    fi
    if [ $V_TOTAL -lt 3 ]; then
        THUMB_SIZE="${GEO_ARRAY[10]}"
    elif [ $V_TOTAL -eq 3 ]; then
        THUMB_SIZE="${GEO_ARRAY[13]}"
    elif [ $V_TOTAL -eq 4 ]; then
        THUMB_SIZE="${GEO_ARRAY[23]}"
    elif [ $V_TOTAL -eq 5 ]; then
        THUMB_SIZE="${GEO_ARRAY[30]}"
    elif [ $V_TOTAL -eq 6 ]; then
        THUMB_SIZE="${GEO_ARRAY[13]}"
    elif [[ $V_TOTAL -ge 7 && $V_TOTAL -le 8 ]]; then
        THUMB_SIZE="${GEO_ARRAY[23]}"
    elif [[ $V_TOTAL -ge 9 && $V_TOTAL -le 10 ]]; then
        THUMB_SIZE="${GEO_ARRAY[30]}"
    fi
fi
# some choices needed for different title alignments
if $SHOWCASE && ! $TEXTMENU; then
    if [ $V_TOTAL -le 5 ]; then
        if [[ $SC_TITLE_ALIGN = east ]]; then
            SHOWCASE_SIZE=288x216  # smaller to allow for titles
            [ $TARGET = "svcd" ] && SHOWCASE_SIZE=216x216
        else
            SHOWCASE_SIZE=384x256
            [ $TARGET = "svcd" ] && SHOWCASE_SIZE=256x256
        fi
        AUTOORDER="rows"       # spumux var
    else
        SHOWCASE_SIZE=288x216  # smaller showcase thumb because we have 2 rows
        [ $TARGET = "svcd" ] && SHOWCASE_SIZE=216x216
        AUTOORDER="columns"
        if ! $NO_SC_THUMB && [[ "$SC_TITLE_ALIGN" = east ]] && [[ -n $SHOWCASE_FILE ]]; then
            usage_error "Sorry, there is no room for the showcase thumb " \
            "if you use more than 5 videos with -showcase-titles-align east|west. " \
            "Either remove the -showcase-titles-align switch or remove the " \
            "showcase image/video by using -showcase-no-thumb. " " " \
            "Consider using -bgimage or -bgvideo instead of a showcase thumb."
        fi
    fi
elif ! $SHOWCASE && ! $TEXTMENU; then
    AUTOORDER="rows"
elif $TEXTMENU; then
    AUTOORDER="columns"
fi
$TEXTMENU && LEFT_MAX=$SPLIT || LEFT_MAX=5
if [ "$SC_TITLE_ALIGN" = "west" ] || $TEXTMENU; then #FIXME
    THUMB_TITLE_ALIGN="west" # for non TEXTMENU menu
    for ((i=0; i<=NUM_FILES; i++)); do
        if [ $i -lt $LEFT_MAX ]; then
            SHOWCASE_THUMB_X_ARRAY[i]=$(( ${SHOWCASE_THUMB_X_ARRAY[i]} - SAFE_OFFSET ))
            SHOWCASE_TITLES_X_ARRAY[i]=$(( ${SHOWCASE_TITLES_X_ARRAY[i]} - SAFE_OFFSET ))
        fi
        if ! $TEXTMENU && ! [[ $SHOWCASE_FILE ]]; then
            if [ ${SHOWCASE_THUMB_X_ARRAY[i]} -gt $(( ${VIDSIZE/x*} / 2 )) ]; then
                SHOWCASE_THUMB_X_ARRAY[i]=$(( ${VIDSIZE/x*} / 2 ))
                SHOWCASE_TITLES_X_ARRAY[i]=$(( ${VIDSIZE/x*} / 2 ))
            fi
        fi
    done
fi
# centre aligned titles are not for textmenu style
if $TEXTMENU && [[ $SC_TITLE_ALIGN = center ]]; then
    yecho
    yecho "Sorry, you can not use center align for textmenu titles"
    yecho "Using title alignment of 'west': please check the preview"
    yecho
    SC_TITLE_ALIGN="west"
    ! $NO_WARN && sleep 10
fi
if  [[ $BUTTON_STYLE = text-rect ]] && ! $SHOWCASE; then
    yecho  "You can only use text-rect button style with showcase or textmenu arrangements"
    yecho "Setting button style to 'rect'"
    yecho "If you would rather use 'text' style please ctrl-c now to exit and reform your command"
    BUTTON_STYLE="rect"
    ! $NO_WARN && sleep 15
fi
# text-rect only for -align east
if [[ $BUTTON_STYLE = text-rect ]] && ! [[ $SC_TITLE_ALIGN = east ]] && ! $TEXTMENU; then
    yecho "***Warning*** : text-rect buttons need to be aligned east of thumbs: \
    by using: '-showcase-titles-align east'"
    if [[ -n $SHOWCASE_FILE ]]; then
        echo "However, you are using a -showcase FILE, so choosing 'line' buttons instead"
        echo "If you wish you may use instead: '-button-style rect' - in which case exit now . . ."
        BUTTON_STYLE="line"
    else
        SC_TITLE_ALIGN="east"
    fi
    yecho
    ! $NO_WARN && sleep 10
fi
if $SHOWCASE && [ "$SC_TITLE_ALIGN" = "east" ] && ! $TEXTMENU; then
    THUMB_TITLE_ALIGN="west" # align titles left to allow longer titles
    for ((i=0; i<=NUM_FILES; i++)); do
        if [ $i -lt $LEFT_MAX ] && ! $ALIGN_OVERRIDE; then
            SHOWCASE_THUMB_X_ARRAY[i]=$(( ${SHOWCASE_THUMB_X_ARRAY[i]} - SAFE_OFFSET ))
            SHOWCASE_TITLES_X_ARRAY[i]=$(( ${SHOWCASE_TITLES_X_ARRAY[i]} - SAFE_OFFSET ))
        fi
        if [ ${SHOWCASE_THUMB_X_ARRAY[i]} -gt 360 ]; then
            SHOWCASE_THUMB_X_ARRAY[i]=360
        fi
        if ! $TEXTMENU; then
            SHOWCASE_TITLES_X_ARRAY[i]=$(( ${SHOWCASE_THUMB_X_ARRAY[i]} + ${THUMB_SIZE/x*} + 5 ))
            SHOWCASE_TITLES_Y_ARRAY[i]=$(( ${SHOWCASE_TITLES_Y_ARRAY[i]} + 18 ))
        fi
    done
fi
if ($USER_GRAVITY && $SHOWCASE && ! $TEXTMENU) && [[ $BUTTON_GRAVITY != north ]]; then
    SW_CORNER=$(( ${SHOWCASE_THUMB_Y_ARRAY[SPLIT-1]} + ${THUMB_SIZE/*x} ))
    if [[ $BUTTON_GRAVITY = *south* ]]; then
        Y_OFFSET=$(( ( ${VIDSIZE/*x} - SAFE_AREA) - SW_CORNER ))
    elif [[ $BUTTON_GRAVITY = *st* ]] || [[ $BUTTON_GRAVITY = *center* ]]; then
        COL1_HEIGHT=$(( SW_CORNER - ${SHOWCASE_TITLES_Y_ARRAY[0]} ))
        Y_OFFSET=$(( ( ${VIDSIZE/*x} / 2) - (COL1_HEIGHT / 2) ))
        Y_OFFSET=$(( Y_OFFSET - ${SHOWCASE_TITLES_Y_ARRAY[0]} ))
    fi
    for ((i=0; i<=NUM_FILES; i++)); do
        SHOWCASE_THUMB_Y_ARRAY[i]=$(( ${SHOWCASE_THUMB_Y_ARRAY[i]} + Y_OFFSET ))
        SHOWCASE_TITLES_Y_ARRAY[i]=$(( ${SHOWCASE_TITLES_Y_ARRAY[i]} + Y_OFFSET ))
    done
fi

# find out the showcase thumb "-page" array for this arrangement
for ((i=0; i<=NUM_FILES; i++)); do
    if $TEXTMENU; then
        SHOWCASE_THUMB_PAGES_ARRAY[i]=+${SHOWCASE_TITLES_Y_ARRAY[i]}+${SHOWCASE_TITLES_X_ARRAY[i]}
    else
        SHOWCASE_THUMB_PAGES_ARRAY[i]=+${SHOWCASE_THUMB_X_ARRAY[i]}+${SHOWCASE_THUMB_Y_ARRAY[i]}
    fi
done

PATTERN=$(for ((i=1; i<=79; i++)); do echo -n \*; done)
printf "%s\n%s\n%s\n\n\n" "$PATTERN" \
"todisc from the tovid suite - log for `date`" \
"$PATTERN" >> "$LOG_FILE"

# Do everything in $WORK_DIR
echo -e "**** NOTE ****\n"
echo "Doing all work in directory $REAL_WORK_DIR"
echo "$WORK_DIR will be a symlink pointing to this directory"
echo -e "\n**************"
sleep 1
cd "$WORK_DIR"
# BASEDIR is the dir of the calling script, if unset, use WORK_DIR (For vmgm)
: ${BASEDOR:-$WORK_DIR}

# default of no blur if using 3D thumbs
if $THUMBS_3D; then
    BLUR=0.1
fi

# allow specifically setting the geometry for 3 videos to 1x3 page
if $THREExONE && [ $V_TOTAL -eq 3 ]; then
    TILE_ARRAY[2]=3x1
fi
# do not use frame for showcase-framestyle glass
if [[ "$SC_FRAMESTYLE" = "glass" && -n "$SHOWCASE_VIDEO" ]] ; then
    unset SC_FRAME
fi
if $SHOWCASE; then
    THUMB_BG_COLOUR="none"   # mist backgrounds look a bit funny with showcase
fi
if ! $USER_BSTYLE && $SHOWCASE; then # line is better than rect for "none" bg
    BUTTON_STYLE="line"
fi
# check if user passed a usable button shape
if [[ -n $THUMB_SHAPE ]]; then
    ! egrep -q  '^egg$|^oval$|^plectrum$|^normal$' <<< "$THUMB_SHAPE"  && \
        usage_error "Please supply a usable thumb shape with -thumb-shape option. You gave \"$THUMB_SHAPE\""
fi

if [[ -n ${ROTATE_ARRAY[@]} ]]; then
    $SHOWCASE && [[ $BUTTON_STYLE != text-rect ]] && BUTTON_STYLE="line"
    if ! $SHOWCASE; then
        if [[ $BUTTON_STYLE != "text" ]]; then
            BUTTON_STYLE="text"
            yecho
            yecho "Setting button style to 'text' so it will work with rotatation"
            yecho
            ! $NO_WARN && sleep 10
        fi
    fi
fi
# use a suitable button style
for ((i=0; i<=NUM_FILES; i++)); do
    if test $(wc -l <<< "$(echo -e "${TITLES[i]}")") -gt 1; then
        MULTILINE_TITLE=:
        if $FEATHER && [ $THUMB_SHAPE != "normal" ]; then
            # multiline titles not suitable for text buttons
            BUTTON_STYLE="text-rect"
        elif $TEXTMENU; then
             ! $USER_BSTYLE && BUTTON_STYLE="text-rect"
        else
            [[ $BUTTON_STYLE != "text-rect" ]] &&  ! $USER_BSTYLE && BUTTON_STYLE="rect"
        fi
    fi
done
# multiline titles not allowed unless showcase style
$MULTILINE_TITLE && ! $SHOWCASE && usage_error "Sorry, multiline titles only allowed for showcase style"
# no rect button style with rotated thumbs yet, so use text-rect fallback
if ([[ -n ${ROTATE_ARRAY[@]} ]] && $MULTILINE_TITLE) && [[ $BUTTON_STYLE = rect ]]; then
    BUTTON_STYLE="text-rect"
    yecho
    yecho "Using 'text-rect' instead of 'rect' button style for rotated thumbs"
    yecho
    ! $NO_WARN && sleep 15
fi

# transparent border around text so rect spumux outline can fit
if [[ $BUTTON_STYLE = text-rect ]]; then
    TEXT_BORDER="-bordercolor Transparent -border 8x8"
fi

# easier to have non transparent showcase use the transparent block
if $SHOWCASE && ! $TRANSPARENT; then TRANSPARENT=:; fi
AUDIO_OPTS="-ab 224k -ar $SAMPLERATE -ac 2 -acodec $AUDIO_EXT"
# spumux and dvdauthor vars
if $WIDE_SCREEN; then
        TITLES_VIDEO_TAG="<video widescreen=\"$WIDESCREEN\" $V_ASPECT/>"
        TITLES_VIDEO_TAG="$(sed 's/ \/>/\/>/' <<< ${TITLES_VIDEO_TAG})"
    if [ ${#WIDESCREEN_ARGS[@]} -lt 1 ]; then
        TITLES_VIDEO_TAG="<video widescreen=\"$WIDESCREEN\" $V_ASPECT/>"
        TITLES_VIDEO_TAG="$(sed 's/ \/>/\/>/' <<< ${TITLES_VIDEO_TAG})"
    fi
fi
if [[ -n "$V_ASPECT" ]] &&  ! $WIDE_SCREEN; then
    TITLES_VIDEO_TAG="<video $V_ASPECT/>"
fi
START="00:00:00.0"
$PLAYALL && TITLESET_PRE="g4=0;"
$ITLESET_MODE && TITLESET_PRE="$TITLESET_PRE g2=1;"

if $AUDIOLANG; then
    # if only one -audio-lang value, then use for all videos
        for ((i=0; i<=NUM_FILES; i++)); do
            if [ ${#AUDIO_LANG[@]} -eq 1 ]; then
                AUDIO_PRE[i]="audio=${AUDIO_LANG[0]};"
            else
                AUDIO_PRE[i]="audio=${AUDIO_LANG[i]};"
            fi
        done
    for ((i=0; i<=NUM_FILES; i++)); do # create audio tag for dvdauthor
        VOB_PRE[i]="        <pre> ${AUDIO_PRE[i]} </pre>"
    done
fi

MAIN_POST="        <post> jump cell 1; </post>"
if $MENU_FADE; then
    . todisc-fade-routine
    END_TIME=$(format_seconds $THUMBS_FADE_OUT_END_TIME)
    END=" end=\"$END_TIME\""
    START=$(format_seconds $THUMBS_FADE_IN_START_TIME)
    POST="<post> jump cell 1; </post>"
fi
if $STATIC; then
    if ! $STATIC_LOOP; then
        VMGM_PAUSE_TIME="inf"
    else
        VMGM_PAUSE_TIME=$PAUSE_TIME
    fi
else
    VMGM_PAUSE_TIME=$PAUSE_TIME
fi
# pausing a faded menu gives a long a period of unselectable thumbs so we use 0
$MENU_FADE && VMGM_PAUSE_TIME=0
if [ "$PAUSE_TIME" = "inf" ]; then
    unset MAIN_POST
fi
###############################################################################
#     generate title_txt png, and template.png needed for all operations       #
###############################################################################

if [ -z "$BG_PIC" ]; then
    echo
    echo "Creating a black background"
    BG_PIC="$WORK_DIR/pics/template.png"
    convert  -resize $VIDSIZE! xc:"#161514" "$BG_PIC"
else
    convert -resize $VIDSIZE! "$BG_PIC" "$WORK_DIR/pics/template.png"
fi
if $MENU_FADE; then
    cp "$WORK_DIR/pics/template.png" "$WORK_DIR/pics/template.bk.png"
fi

if $MENU_FADE || $FEATHER; then
    convert -size $VIDSIZE xc:"#161514" "$WORK_DIR/black.jpg"
fi
DIMY=$(cut -f1 -dx <<< $THUMB_SIZE)
DIMX=$(cut -f2 -dx <<< $THUMB_SIZE)
DIMY1=$((DIMY / 20))
DIMX1=$((DIMX / 20))
DIMY2=$((DIMY - DIMY1))
DIMX2=$((DIMX - DIMY1))
DIMY3=$(($DIMY2 / 2))
DIMX3=$(($DIMX2 / 2))
DIMY4=$((DIMY / 2))
DIMX4=$((DIMX / 2))
DIMY5=$((DIMY / 3))
DIMX5=$((DIMX4 / 3))
BLUR_CMD=(convert - -blur 0x$BLUR -channel RGBA +matte miff:-)
if $THUMBS_3D && $SHOWCASE && [ "$THUMB_SHAPE" = "normal" ]; then
    MASK_DIM="0,0 $DIMY,$DIMX"
    BLUR_CMD=(convert - miff:-)
else
    MASK_DIM="$DIMY1,$DIMY1 $DIMY2,$DIMX2"
fi

if [[ -n "$THUMB_SHAPE" ]]; then
    # make a mask for the mist if called for
    convert -size $THUMB_SIZE xc:none -fill  "$THUMB_BG_COLOUR" -stroke none \
    -draw "rectangle $DIMY1,$DIMY1 $DIMY2,$DIMX2" "$WORK_DIR/feather_orig.png"
    convert "$WORK_DIR/feather_orig.png" -channel RGBA \
    -blur 0x60 "$WORK_DIR/feather_mask2.png"
fi
if [[ -z "$THUMB_TEXT_COLOUR" ]]; then
    if $FEATHER && ! $SHOWCASE &&  [ $THUMB_BG_COLOUR != none ]; then
        THUMB_TEXT_COLOUR="#161514" # dark font for misted backgrounds
    else
        THUMB_TEXT_COLOUR="#C6C6C6"
    fi
fi
if test "$THUMB_SHAPE" = "normal"; then
    THUMB_MASK="$WORK_DIR/feather_mask.png"
    yecho "Creating normal mask with the following command:"
    MASK_CMD="convert -size $THUMB_SIZE xc:black -fill white \
    -draw \"Rectangle $MASK_DIM\" \
    +matte -compose CopyOpacity miff:- | \
    convert - -bordercolor none -border 8x8 miff:- |
    ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | \
    convert -resize $THUMB_SIZE! - $THUMB_MASK"
    # TODO (if desired): move this 'sed' line to a separate function for
    # cleaning up excess spaces in a multi-line command.
    #    sed 's/    */ /g'|sed -e "s/^ *//"

elif test "$THUMB_SHAPE" = "oval"; then
    THUMB_MASK="$WORK_DIR/oval_mask.png"
    yecho "Creating oval mask with the following command:"
    MASK_CMD="convert -size $THUMB_SIZE xc:black -fill white \
    -draw \"RoundRectangle $DIMY1,$DIMY1 $DIMY2,$DIMX2, $DIMY3,$DIMX3\" \
    +matte -compose CopyOpacity miff:- | \
    convert - -bordercolor none -border 6x6 miff:- |
    ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | \
    convert -resize $THUMB_SIZE! - $THUMB_MASK"
    MASK_HILITE_CMD="convert -size $THUMB_SIZE xc:none \
    -draw \"RoundRectangle $DIMY1,$DIMY1 $DIMY2,$DIMX2, $DIMY3,$DIMX3\" \
    -negate  -channel A -gaussian 0x8 $WORK_DIR/oval_highlight.png"

elif test "$THUMB_SHAPE" = "egg"; then
    THUMB_MASK="$WORK_DIR/egg_mask.png"
    yecho "Creating egg-shaped mask with the following command:"
    MASK_CMD="convert -size $THUMB_SIZE xc:black -fill white \
    -draw \"circle $DIMY4,$DIMX4 $DIMY5,$DIMX5\" \
    +matte -compose CopyOpacity miff:- | \
    ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | \
    convert -resize $THUMB_SIZE! - $THUMB_MASK"

elif test "$THUMB_SHAPE" = "plectrum"; then
    THUMB_MASK="$WORK_DIR/plectrum_mask.png"
    yecho "Creating plectrum-shaped mask with the following command:"
    MASK_CMD="convert -size 200x200 xc:none -fill white \
    -draw 'circle 100,100 150,150' miff:- |
    convert -background none -wave -50x456 - miff:- |
    convert - -bordercolor none -border 3x3 -trim +repage miff:- |
    convert - -bordercolor none -border 18x18 miff:- |
    ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} |
    convert -resize $THUMB_SIZE! - $THUMB_MASK"
fi

# Print and execute the thumb-shape mask command
yecho "$MASK_CMD"
cmd_exec "$MASK_CMD"
yecho "Creating a title image"
if [[ -z "$BG_PIC" && -z "$BG_VIDEO" ]]; then
    STROKE=none
elif [ -z "$STROKE" ]; then
    STROKE=gray
fi

# make a title image
#! [[ -z ${STR// /} || -z $STR ]] && TRIM_CMD="-trim +repage -blur 0x0.4 "
TRIM_CMD="-trim +repage -blur 0x0.4"
TITLE_CMD=(convert  -size 620x100 xc:none -font "$MENU_FONT"  -pointsize $MENU_FONTSIZE \
-fill black -stroke black -gravity center  -annotate +0+0 "$MENU_TITLE" \
-fill "$TITLE_COLOUR" -stroke "$STROKE" -strokewidth 1 -annotate +1+1 "$MENU_TITLE")
TITLE_CMD1=(convert - $TRIM_CMD  "$WORK_DIR/title_txt.png")

echo "Running "${TITLE_CMD[@]}" miff:- |
"${TITLE_CMD1[@]}"" | format_output|tee -a "$LOG_FILE"
"${TITLE_CMD[@]}" miff:- | "${TITLE_CMD1[@]}" >> "$LOG_FILE" 2>&1
#"${TITLE_CMD[@]}" miff:- | "${TITLE_CMD1[@]}" 2>/dev/null
# make playall if titlesets and playall
if $TITLESET_MODE && $PLAYALL; then
    PLAYALL_CMD=( convert -size 100x100 xc:none -gravity center \
    -font "$THUMB_FONT" -pointsize 20  -fill $THUMB_TEXT_COLOUR \
    -stroke "$STROKE" -strokewidth 1 -annotate +0+0 "Play all" )
    TRIM_CMD=(convert - -background none -rotate -10 -trim +repage \
    "$WORK_DIR/PLAYALL.png")
    "${PLAYALL_CMD[@]}" miff:- | "${TRIM_CMD[@]}"
fi
# make thumb titles if $SHOWCASE
if $SHOWCASE; then
    for ((i=0; i<=NUM_FILES; i++)); do
        unset ts_dim j
        THUMB_TITLE_CMD=(convert  -size 620x300 xc:none \
        -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE \
        -fill black -stroke black -gravity $THUMB_TITLE_ALIGN  \
        -annotate +0+0 "${TITLES[i]}" \
        -fill $THUMB_TEXT_COLOUR  -stroke "$STROKE" -strokewidth 1 \
        -annotate +1+1 "${TITLES[i]}")
        TT_CMD1=(convert - -trim +repage $TEXT_BORDER "$WORK_DIR/thumb_title${i}.png")
        echo "Running "${THUMB_TITLE_CMD[@]}" miff:- | "${TT_CMD1[@]}"" \
        |fold -bs >> "$LOG_FILE"
        "${THUMB_TITLE_CMD[@]}" miff:- | "${TT_CMD1[@]}" 2> /dev/null

        # find out dimension of the thumb title png
        TT_DIM=( ${TT_DIM[@]} $(get_image_dim "$WORK_DIR/thumb_title${i}.png") )
        # get widest png in each colum for use later for alignment use
        if ((i < SPLIT)); then
            val=${TT_DIM[i]/x*}
            [ -z "$WIDEST_TITLE" ] || ((val > WIDEST_TITLE)) && WIDEST_TITLE=$val
        else
            val2=${TT_DIM[i]/x*}
            [ -z "$WIDEST_TITLE2" ] || ((val2 > WIDEST_TITLE2)) && WIDEST_TITLE2=$val2
        fi
        # get just X demension to help determine final title pos below
        tt_dim=${TT_DIM[i]/x*}
        # thumb pos plus 1/2 (X dim) of thumbsize, less 1/2 (X dim) of title size
        if [ "$SC_TITLE_ALIGN" = "center" ]; then
            f=$(( ${THUMB_SIZE/x*} / 2 ))
            j=$(( (f + ${SHOWCASE_THUMB_X_ARRAY[i]}) - (tt_dim / 2) ))
            k=( ${k[@]} "$j" )
            l=$((j + tt_dim))
            if [ $j -lt 48 ]; then
                off_left=$j
                titlesafe_error $off_left
            elif [ $l -gt 672 ]; then
                off_right=$((720 - l))
                titlesafe_error $off_right
            fi
        fi
    done
    if $TEXTMENU; then
        # text-rect can get along with a small space between titles for spumux
        [[ $BUTTON_STYLE = text-rect ]] && SPACER=${SPACER:-"10"} || SPACER=${SPACER:-"15"}
        # get an array of title Y positions
        offsets1=$(for ((c=0; c<NUM_FILES; c++)); do
        ((c < (LEFT_MAX-1))) && echo $(( ${TT_DIM[c]#*x} + SPACER )); done)
        if [[ $NUM_FILES -ge $SPLIT ]]; then
            offsets2=$(for ((d=0; d<=NUM_FILES; d++)); do
            ((d >= LEFT_MAX)) && echo $(( ${TT_DIM[d]#*x} + SPACER )); done)
            [[ $offsets2 ]] && offsets2="$TEXT_YSTART $offsets2"
            tt_ygeos_col2=$(running_total <<< $offsets2)
        fi
        offsets1="$TEXT_YSTART $offsets1"
        tt_ygeos_col1=$(running_total <<< $offsets1)
        tt_ygeos="$tt_ygeos_col1 $tt_ygeos_col2"
        unset SHOWCASE_TITLES_Y_ARRAY
        SHOWCASE_TITLES_Y_ARRAY=( $tt_ygeos_col1 $tt_ygeos_col2 )
        # get the y position of the last title in 1st column (tt_ygeos_col1)
        last_title_col1=$(wc -w <<< "$tt_ygeos_col1")
        last_title_col1_ygeo=${SHOWCASE_TITLES_Y_ARRAY[last_title_col1-1]/*x}
        # add the y dimension of the last title size to the above y position
        SW_YCORNER=$(( ${TT_DIM[last_title_col1-1]/*x} + $last_title_col1_ygeo ))
        avail_space1=$(( ( ${VIDSIZE/*x} - SAFE_AREA ) - $SW_YCORNER ))
        # if there are 2 columns, get same data for column 2
        if [[ -n $tt_ygeos_col2 ]]; then
            last_title_col2=$NUM_FILES
            last_title_col2_ygeo=${SHOWCASE_TITLES_Y_ARRAY[last_title_col2]/*x}
            last_title_col2_xgeo=${SHOWCASE_TITLES_Y_ARRAY[last_title_col2]/x*}
            SE_YCORNER=$(( ${TT_DIM[last_title_col2]/*x} + $last_title_col2_ygeo ))
            avail_space2=$(( ( ${VIDSIZE/*x} - SAFE_AREA ) - $SE_YCORNER ))
        fi
        # availible space is lowest value of 2 *space* vars ( if 2 columns)
        if [[ -n $tt_ygeos_col2 ]] && ((SE_YCORNER > SW_YCORNER)); then
            avail_space=$avail_space2
        else
            avail_space=$avail_space1
        fi
        # get the height of each column for -align centre
        if [[ $BUTTON_GRAVITY = center || $BUTTON_GRAVITY = east || $BUTTON_GRAVITY = west ]]; then
            WEST_YSPACE=$(( SW_YCORNER - TEXT_YSTART))
            EAST_YSPACE=$((SE_YCORNER - TEXT_YSTART))
            ((WEST_YSPACE > EAST_YSPACE)) && YSPACE=$WEST_YSPACE || YSPACE=$EAST_YSPACE
            CANVAS=$(( ${VIDSIZE/*x} - (SAFE_AREA * 2) ))
            NEW_TEXT_YSTART=$(( ((CANVAS - YSPACE) / 2) + SAFE_AREA ))
            TEXT_YSTART_OFFSET=$((NEW_TEXT_YSTART - TEXT_YSTART))
        fi
        # add the available space to each title position for south alignment
        if [[ $BUTTON_GRAVITY = *south* ]] && ((avail_space > 0)); then
            for ((d=0; d<=NUM_FILES; d++)); do
                SHOWCASE_TITLES_Y_ARRAY[d]=$(( ${SHOWCASE_TITLES_Y_ARRAY[d]} + $avail_space ))
            done
        elif  [[ $BUTTON_GRAVITY = center || $BUTTON_GRAVITY = east || $BUTTON_GRAVITY = west ]]; then
            for ((d=0; d<=NUM_FILES; d++)); do
                SHOWCASE_TITLES_Y_ARRAY[d]=$(( ${SHOWCASE_TITLES_Y_ARRAY[d]} + $TEXT_YSTART_OFFSET ))
            done
        fi
            # this justifies titles to the right on the east side of the menu
            ((NUM_FILES >= SPLIT-1)) && WIDE_TITLE=$WIDEST_TITLE2 || WIDE_TITLE=$WIDEST_TITLE
            for ((d=0; d<=NUM_FILES; d++)); do
                ([[ "$BUTTON_GRAVITY" = *east* ]] || [[ -n $tt_ygeos_col2 ]]) && \
                    east_offset=$(( ( ${VIDSIZE/x*} - SAFE_AREA ) - ${TT_DIM[d]/x*} ))
                if (($NUM_FILES < SPLIT)); then
                    SHOWCASE_TITLES_X_ARRAY[d]=$SAFE_AREA
                    [[ "$BUTTON_GRAVITY" = *east* ]] && SHOWCASE_TITLES_X_ARRAY[d]=$east_offset
                else
                    if ((d >= LEFT_MAX)); then
                        SHOWCASE_TITLES_X_ARRAY[d]=$east_offset
                    else
                        SHOWCASE_TITLES_X_ARRAY[d]=$SAFE_AREA
                    fi
                fi
            done
        unset MAX_VAL val max_key
    fi
    # make array of SHOWCASE_PAGES for thumbs and THUMBTITLES_ARRAY for titles
    # use preset values unless doing centre align for titles
    for ((i=0; i<=NUM_FILES; i++)); do
        if [ "$SC_TITLE_ALIGN" != "center" ]; then
            SHOWCASE_TITLES_ARRAY[i]=+${SHOWCASE_TITLES_X_ARRAY[i]}+${SHOWCASE_TITLES_Y_ARRAY[i]}
        else
            SHOWCASE_TITLES_ARRAY[i]=+${k[i]}+${SHOWCASE_TITLES_Y_ARRAY[i]}
        fi

        SHOWCASE_THUMB_PAGES[i]="-page ${SHOWCASE_THUMB_PAGES_ARRAY[i]}"
        THUMBTITLES_ARRAY[i]="-page ${SHOWCASE_TITLES_ARRAY[i]}"
    done
fi
# make a PLAYALL button if called for.  If we are doing titlesets, make a MAIN
# button to jump back to the vmgm here instead, and put the playall on vmgm page
if $TITLESET_MODE && ! $NO_VMGM_MENU; then
    SE_BTNTEXT="Main"
else
    SE_BTNTEXT="Play All"
fi
SE_BTN="$WORK_DIR/SE_BTN.png"
if ($TITLESET_MODE && ! $NO_VMGM_MENU) || $PLAYALL; then
    BTN_CMD=(convert -size 100x100 xc:none \
   -font "$MENU_FONT" -pointsize 20 \
    -fill black -stroke black -gravity center  \
    -annotate +0+0 "$SE_BTNTEXT" \
    -fill "$TITLE_COLOUR" -stroke "$STROKE" -strokewidth 1 \
    -annotate +1+1 "$SE_BTNTEXT")
    TRIM_CMD=(convert - -background none -rotate -30 -trim +repage "$SE_BTN")
    "${BTN_CMD[@]}" miff:- | "${TRIM_CMD[@]}"|fold -bs >> "$LOG_FILE"
    ADD_SE_BTN="$SE_BTN -gravity SouthEast -geometry +55+55 -composite"
fi

if [[ -n $MENU_TITLE ]]; then
    TITLE_TEXT_DIM=$(get_image_dim "$WORK_DIR/title_txt.png")
    TITLE_TEXT_XDIM=${TITLE_TEXT_DIM/x*}
    TITLE_TEXT_YDIM=${TITLE_TEXT_DIM/*x}
fi
if $MIST; then
    echo
    echo "Making a white or colored png for the misted title background"
    echo
    # make a white or coloured png for misted background effect, only for user bg
    # add 10 pixels to width and height compared to title text png
    y=$((TITLE_TEXT_YDIM + 40))
    x=$((TITLE_TEXT_XDIM + 40))
    newX=$((TITLE_TEXT_XDIM + 30))
    newY=$((TITLE_TEXT_YDIM + 30))
    DIM=${x}x${y}
    convert -size $DIM xc:none -fill $MIST_COLOUR -stroke none \
    -draw "rectangle 10,10 $newX,$newY" "$WORK_DIR/white_orig.png"
    convert $WORK_DIR/white_orig.png -channel RGBA -blur 0x4 "$WORK_DIR/white.png"
    unset X Y x y
fi
# offsets for placing title and mist for Y dimension
# place menu title lower if not text mist and -title-geo is not supplied
if $MIST; then
    if [[ $TITLE_GRAVITY = *south* || $TITLE_GRAVITY = *north* ]]; then
        title_yoffset=${title_yoffset:-"+65"}
        mist_yoffset="$(( ${title_yoffset#*[-+]} - 20))"
    else
        title_yoffset=${title_yoffset:-"+0"}
        mist_yoffset="$(( ${title_yoffset#*[-+]} - 0))"
    fi
else
    title_yoffset=${title_yoffset:-"+50"}
fi
[[ ${mist_yoffset:0:1} != [+-] ]] && mist_yoffset=+${mist_yoffset}
# offsets placing title and mist for X dimension
if $MIST; then
    mist_dim=$(get_image_dim "$WORK_DIR/white.png" )
    mist_xdim=${mist_dim/x*}
    mist_xdim_offset=$(( (mist_xdim - TITLE_TEXT_XDIM) / 2 ))
    if [[ $TITLE_GRAVITY = *st* ]]; then
        title_xoffset=${title_xoffset:-"+50"}
        mist_xoffset="$( awk_math ${title_xoffset#*[-+]} less $mist_xdim_offset)"
        [[ ${mist_xoffset:0:1} != [+-] ]] && mist_xoffset=+${mist_xoffset}
    else
        title_xoffset=${title_xoffset:-"+0"}
        mist_xoffset=$title_xoffset
    fi
else
        title_xoffset=${title_xoffset:-"+0"}
fi
###############################################################################
#      generate a basic preview of the main menu                              #
###############################################################################
# generate images for montage and title and resize them
if [[ -n "$BG_VIDEO" ]]; then
    echo "Getting background video images from $BG_VIDEO"
    FFMPEG_CMD=(ffmpeg -i "$BG_VIDEO" -s $VIDSIZE -ss $BG_SEEK -vframes 1 \
    -vcodec png -an  -f rawvideo -y "$WORK_DIR/pics/template.png")
    echo -e "\nRunning: "${FFMPEG_CMD[@]}"\n" | fold -bs >> "$LOG_FILE"
    SED_VAR="frame="
    if "${FFMPEG_CMD[@]}" >> "$LOG_FILE.tmp" 2>&1;then
        cleanlog 3
    else
        cleanlog 3
        runtime_error "Problem creating images from the video."
        exit 1
    fi
fi
if $SHOWCASE && ! $NO_SC_THUMB; then
[[ $SC_TITLE_ALIGN = east ]] && ! $TEXTMENU && TS="+ ${THUMB_SIZE/x*}"
    if (( (WIDEST_TITLE + SAFE_AREA $TS + ${SHOWCASE_SIZE/x*}) > ( ${VIDSIZE/x*} - SAFE_AREA) )); then
            SHOWCASE_SIZE=288x216
            [[ $TARGET = "svcd" ]] && SHOWCASE_SIZE=216x216
    fi
    if $TEXTMENU && [[ -n $tt_ygeos_col2 ]]; then
        SHOWCASE_SIZE=288x216
        [[ $TARGET = "svcd" ]] && SHOWCASE_SIZE=216x216
    fi
    if [[ -n "$SHOWCASE_VIDEO" ]]; then
        echo "Getting video images from $SHOWCASE_VIDEO"
        if [[ "$SC_FRAMESTYLE" = "glass" && -n "$SHOWCASE_VIDEO" ]]; then
            D=2
            OUTDIR="$WORK_DIR/showcase"
            OUT="$WORK_DIR/showcase_img.png"
            VOUT="png:z=7"; FRAMES=30
            FRAME_SIZE=$SHOWCASE_SIZE
            MPLAYER_SEEK_VAL=$SHOWCASE_SEEK_VAL
            echo "Using mplayer to get framed images from the showcase video"
            echo "Running: mplayer -ss $MPLAYER_SEEK_VAL -vo $VOUT \
            -vf expand=-5:-5,rectangle=384:256,rectangle=382:254,rectangle=380:252,rectangle=378:250 \
            -ao null -zoom -x 384 -y 256  -ss 0:0:05 -frames $FRAMES "$SHOWCASE_VIDEO"" |
            format_output | tee -a "$LOG_FILE"
            echo
            get_framed_pics "$SHOWCASE_VIDEO" >> "$LOG_FILE" 2>&1

            mv -v "$WORK_DIR"/00000025.png "$OUT"
            rm -f "$WORK_DIR"/00000*.png
            convert "$WORK_DIR/showcase_img.png" \
            -background none $ROTATE $WAVE miff:-|
            convert - -resize $SHOWCASE_SIZE! "$WORK_DIR/showcase_img.png"
        elif [ "$SC_FRAMESTYLE" = "none" ]; then
            FFMPEG_CMD=(ffmpeg -i "$SHOWCASE_VIDEO" -ss $SHOWCASE_SEEK_VAL \
            -s $SHOWCASE_SIZE  -vframes 1 -vcodec png -an -f rawvideo -y \
            "$WORK_DIR/showcase_img.png")
            echo -e "\nRunning: "${FFMPEG_CMD[@]}"\n" | fold -bs >> "$LOG_FILE"
            SED_VAR="frame="
            if "${FFMPEG_CMD[@]}" >> "$LOG_FILE.tmp" 2>&1;then
                cleanlog 3
            else
                cleanlog 3
                runtime_error "Problem creating images from the video."
                exit 1
            fi
            echo "Running convert "$WORK_DIR/showcase_img.png" -mattecolor gray"
            echo "$SC_FRAME "$WORK_DIR/showcase_img.jpg"" |format_output
            convert "$WORK_DIR/showcase_img.png" -mattecolor gray $SC_FRAME miff:- |
            convert -background none $ROTATE $WAVE - miff:-|
            convert - -resize $SHOWCASE_SIZE! "$WORK_DIR/showcase_img.png"
        fi
    elif [[ -n "$SHOWCASE_IMG" ]]; then
        echo "Running convert -resize $SHOWCASE_SIZE! "$SHOWCASE_IMG" miff:- | \
        convert -background none $ROTATE $WAVE -bordercolor Transparent -border 8x8 - miff:- | \
        convert - -trim +repage -resize $SHOWCASE_SIZE! "$WORK_DIR/showcase_img.jpg"" |format_output
        convert "$SHOWCASE_IMG" -resize $SHOWCASE_SIZE! -mattecolor gray $SC_FRAME miff:- |
        convert - -background none -bordercolor Transparent -border 8x8 $ROTATE $WAVE miff:- |
        convert - -trim +repage -resize $SHOWCASE_SIZE! "$WORK_DIR/showcase_img.png"
    fi
fi
# transcode makes it harder to switch between PNG and JPEG for output
if [ $IMG_FMT = "jpg" ]; then
    EXPORT="-y jpg,null"
elif [ $IMG_FMT = "png" ]; then
    EXPORT="-y im -F png"
fi

# create the preview images
if ! $TEXTMENU; then
    for ((i=0; i<=NUM_FILES; i++)) ; do
        # use a nav_seek file if long seek
        if [ ${SEEK_VAL[i]%.*} -gt 450 ]; then
            NAVSEEK[i]="--nav_seek "${IN_FILES[i]}".nav_log"
            NAVSEEK_CMD=(nice tcdemux  $TCDEMUX_MODE -f $FRAME_RATE -W -i "${IN_FILES[i]}")
            run_navseek()
            {
                yecho "Running "${NAVSEEK_CMD[@]}" > "${IN_FILES[i]}".nav_log"
               "${NAVSEEK_CMD[@]}"  2>> "$WORK_DIR/tc_pids" > "${IN_FILES[i]}".nav_log
            }

            run_navseek &
            NS_PID="$!"
            if [[ -n "$NS_PID" ]]; then
                while ps -p $NS_PID >/dev/null; do
                    sleep 2 # spinner interval
                    spin "Creating a nav_seek log for "${IN_FILES[i]}": $SPINNER"
                done
            fi
            length=( ${length[@]} $(( $(awk  '{ field = $2 }; END{ print field }'  "${IN_FILES[i]}".nav_log) + 1)) )
        fi
            echo
            echo "[$i of $NUM_FILES] Seeking to ${SEEK_VAL[i]} seconds in ${IN_FILES[i]}"

        FFMPEG_CMD=(ffmpeg -i "${IN_FILES[i]}" -an -ss ${SEEK_VAL[i]} -vframes 1 \
        -s $THUMB_SIZE $WORK_DIR/pics/$i/%06d.$IMG_FMT)
        CMD=( "${FFMPEG_CMD[@]}" )
        SED_VAR="frame="
        ! [[ "$SC_FRAMESTYLE" = "glass" ]] && echo -e "\nRunning: "${CMD[@]}"\n" | fold -bs >> "$LOG_FILE"
        VOUT="png:z=7"; FRAMES=30
        FRAME_SIZE=$THUMB_SIZE
        D=2

        if [ "$SC_FRAMESTYLE" = "glass" ]; then
            MPLAYER_SEEK_VAL=${SEEK_VAL[i]}
            get_framed_pics "${IN_FILES[i]}"  >> "$LOG_FILE" 2>&1
            mv -fv $WORK_DIR/$(printf "%08d%s"  25 .$IMG_FMT) \
            $WORK_DIR/pics/$i/$(printf "%06d%s"  0 .$IMG_FMT)
            rm -f "$WORK_DIR"/00000*.png
        elif [ "$SC_FRAMESTYLE" = "none" ]; then
            if "${FFMPEG_CMD[@]}" >> "$LOG_FILE" 2>&1;then
                : #cleanlog 3
            else
                #cleanlog 3
                runtime_error "Problem creating images from the video."
                exit 1
            fi
        fi

        wait
        unset NAVSEEK_CMD rectangle run_transcode FFMPEG_CMD TRANSCODE_CMD
    done
fi
# overlay menu title and thumb titles on template
if $MIST; then
    # overlay white.png onto background
    echo "Running:
    composite -dissolve $MIST_OPACITY -gravity $TITLE_GRAVITY -geometry ${mist_xoffset}${mist_yoffset} \
    "$WORK_DIR/white.png" "$WORK_DIR/pics/template.png" \
    "$WORK_DIR/pics/template.png"
    " | format_output
    composite -dissolve $MIST_OPACITY -gravity $TITLE_GRAVITY -geometry ${mist_xoffset}${mist_yoffset} \
    "$WORK_DIR/white.png" "$WORK_DIR/pics/template.png" \
    "$WORK_DIR/pics/template.png"
fi
if $SHOWCASE; then
    for ((i=0; i<=NUM_FILES; i++)); do
        sc_thumb_title_cmd=( "${sc_thumb_title_cmd[@]}" "${THUMBTITLES_ARRAY[i]}"  \
        "$WORK_DIR/thumb_title${i}.png")
    done
    echo "Running:
    convert  -size $VIDSIZE "$WORK_DIR/pics/template.png"
    ${sc_thumb_title_cmd[@]} -page +210+400 "$WORK_DIR/title_txt.png" \
    -mosaic "$WORK_DIR/pics/template.png" "| format_output
    convert -size $VIDSIZE "$WORK_DIR/pics/template.png" \
    ${sc_thumb_title_cmd[@]} -mosaic "$WORK_DIR/pics/template.png"
    convert "$WORK_DIR/pics/template.png" "$WORK_DIR/title_txt.png" \
    -gravity $TITLE_GRAVITY -geometry ${title_xoffset}${title_yoffset} \
    -composite "$WORK_DIR/pics/template.png"
fi
if $PLAYALL || ($TITLESET_MODE && ! $NO_VMGM_MENU) ; then
    convert "$WORK_DIR/pics/template.png" "$SE_BTN" \
    -gravity SouthEast -geometry +55+55 -composite "$WORK_DIR/pics/template.png"
    convert "$WORK_DIR/pics/template.png" "$SE_BTN" \
    -gravity SouthEast -geometry +55+55 -composite "$WORK_DIR/pics/template.jpg"
fi
# lets be sure of order by using a loop
for ((i=0; i<=NUM_FILES; i++)); do
    PICS=( "${PICS[@]}" \
    $(find $WORK_DIR/pics/$i/  -maxdepth 1 -name 000\*.$IMG_FMT) )
done
if ! $TEXTMENU; then
    for ((i=0; i<${#PICS[@]}; i++)); do
        [[ -n ${ROTATE_ARRAY[@]} ]] && THUMB_ROTATE="-background none -rotate ${ROTATE_ARRAY[i]}"
        if $THUMBS_3D && [ "$THUMB_SHAPE" != "normal" ]; then
        CURVE_VARS="5 3 5 1 1"
        . todisc-fade-routine
        fi
        PVIEW_CMD=(composite -compose CopyOpacity $THUMB_MASK +matte \
        "${PICS[i]}")
        PVIEW_CMD0=(convert "${PICS[i]}" $RAISE)
        PVIEW_CMD1=(convert - $RAISE)
        PVIEW_CMD2=(convert - -write mpr:${i}img -fx A  +matte \
        -blur 0x$( printf  "%.2f" $(awk_math 6.9 plus .${CURVE_ARRAY[i]/.} float) ) \
        -shade $(awk_math 115 plus ${CURVE_ARRAY[i]})x30 -normalize mpr:${i}img -compose \
        Overlay -composite mpr:${i}img  -matte  -compose Dst_In -composite)
        PVIEW_CMD3=(convert -trim +repage - "${PICS[i]}")
        if $FEATHER; then
            if $THUMBS_3D; then
                if $SHOWCASE; then
                    if [ "$THUMB_SHAPE" != "normal" ]; then
                        "${PVIEW_CMD[@]}" miff:- |
                        "${PVIEW_CMD2[@]}" miff:- |
                        "${PVIEW_CMD3[@]}"
                    else # normal thumbshape
                        "${PVIEW_CMD0[@]}" miff:- | "${PVIEW_CMD1[@]}" miff:- |
                        "${PVIEW_CMD3[@]}"
                    fi
                else  # not $SHOWCASE
                    if [ "$THUMB_SHAPE" != "normal" ]; then
                        "${PVIEW_CMD[@]}" miff:- |
                        "${PVIEW_CMD2[@]}" "${PICS[i]}"
                    else # normal thumbshape
                        echo "Running
                        "${PVIEW_CMD0[@]}" miff:- | "${PVIEW_CMD3[@]}"
                        "|format_output
                        "${PVIEW_CMD0[@]}" miff:- | "${PVIEW_CMD3[@]}"
                    fi
                fi
            else # not 3D
                "${PVIEW_CMD[@]}" miff:- | "${PVIEW_CMD3[@]}"
            fi
        else # not FEATHER
            "${PVIEW_CMD0[@]}" miff:- | "${PVIEW_CMD3[@]}"
        fi

        IM_CMD=(convert -background none $THUMB_FRAME -bordercolor "#444744" $RAISE "${PICS[i]}")
        IM_CMD0=(composite -gravity center -compose DstOver "$WORK_DIR/feather_mask2.png" "${PICS[i]}")
        IM_CMD1=(montage "${PICS[i]}" -geometry +4+4 -compose Copy  \
        -background  none -fill "$THUMB_TEXT_COLOUR" -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE \
        -title "${TITLES[i]}")
        IM_CMD2=(convert -resize $THUMB_SIZE! -)
        IM_CMD3=(composite -gravity center -compose DstOver "$WORK_DIR/feather_mask2.png" - )
        IM_CMD4=(convert -background none -frame 3x3 \
        -bordercolor "#444744" -)
        IM_CMD5=(convert - $THUMB_ROTATE -resize $THUMB_SIZE! "${PICS[i]}")
        if $FEATHER; then
            if $SHOWCASE; then
                "${IM_CMD0[@]}" miff:- | "${IM_CMD5[@]}"
            else  # feather, but not showcase
                "${IM_CMD1[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
                "${IM_CMD3[@]}" miff:- | "${IM_CMD5[@]}"
            fi
        else  # not feather
            if $SHOWCASE; then
                "${IM_CMD[@]}" miff:- | "${IM_CMD5[@]}"
            else # not feather and not showcase
                "${IM_CMD1[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
                "${IM_CMD4[@]}" miff:- | "${IM_CMD5[@]}"
            fi
        fi
    done
fi

##############################################################################
#                 create button layer for spumux                             #
##############################################################################
get_button_geo()
{
    GEOx=${MENU_BUTTON_SIZE/x*}
    GEOy=${MENU_BUTTON_SIZE/*x}
    GEOx=$((GEOx - 3))
    GEOy=$((GEOy - 3))
    GEO="$GEOx,$GEOy"
}
echo
echo "Creating the highlight and selection PNGs for the main menu"
if [ "$BUTTON_STYLE" = "rect" ]; then
    MENU_BUTTON_SIZE=$THUMB_SIZE
    get_button_geo
(
cat  <<EOF
rectangle 2,2 $GEO
EOF
)  > "$WORK_DIR/draw_file"
fi
if [ $BUTTON_STYLE = "text-rect" ]; then
    for ((i=0; i<=NUM_FILES; i++)); do
        MENU_BUTTON_SIZE=${TT_DIM[i]}
        get_button_geo
(
cat <<EOF
rectangle 1,1 $GEO
EOF
)  > "$WORK_DIR/draw_file${i}"
    done
fi
# command constructions for -button-style options
if $PLAYALL ||  ($TITLESET_MODE && ! $NO_VMGM_MENU); then
    for BUTTON in "$SELECT_COLOUR" "$HIGHLIGHT_COLOUR"; do
        convert -size 100x100 xc:none -font "$MENU_FONT" -pointsize 20 \
        -fill "$BUTTON" -stroke none -gravity center \
        -annotate +0+0 "$SE_BTNTEXT" \
        -fill "$BUTTON" -stroke none -strokewidth 1  \
        -annotate +1+1 "$SE_BTNTEXT" miff:- | convert  - -background none -rotate -30 \
        -trim +repage $WORK_DIR/${BUTTON/\#}_se_button.png
    done
fi

PNG_IS_DONE=false
for ((t=0; t<${#TITLES[@]}; t++)); do
    unset BUTTON_CMD6b BUTTON_CMD7b
    if $FEATHER; then FRAME=0; else FRAME=3x3;fi
    [[ -n ${ROTATE_ARRAY[@]} ]] && THUMB_ROTATE="-background none -rotate ${ROTATE_ARRAY[t]}"
    BUTTON_SIZE=$THUMB_SIZE
    BUTTON_CMD=(montage -size $THUMB_SIZE xc:none -geometry +4+4 \
    -background none -mattecolor none -bordercolor none -stroke none \
    -fill "$SELECT_COLOUR" -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE \
    -title "${TITLES[t]}" -compose CopyOpacity)
    BUTTON_CMD1=(montage -size $THUMB_SIZE xc:none -geometry +4+4 \
    -background none -mattecolor none -bordercolor none -stroke none \
    -fill "$HIGHLIGHT_COLOUR" -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE \
    -title "${TITLES[t]}" -compose CopyOpacity)
    BUTTON_CMD2=(convert -mattecolor none -background none \
    -bordercolor none -frame 3x3 -)
    BUTTON_CMD3=(convert - $THUMB_ROTATE -resize ${THUMB_SIZE}! +antialias)
    BUTTON_CMD4=(convert -size "${THUMB_SIZE}+5+5"  xc:none \
    -fill none +antialias -stroke "$SELECT_COLOUR" -strokewidth 4 -draw @draw_file \
    -colors 3 $THUMB_ROTATE -resize ${THUMB_SIZE}! "$WORK_DIR/Selectx1.png")
    BUTTON_CMD5=(convert -size "${THUMB_SIZE}+5+5" xc:none \
    -fill none +antialias -stroke "$HIGHLIGHT_COLOUR" -strokewidth 4 -draw @draw_file \
    -colors 3 $THUMB_ROTATE -resize ${THUMB_SIZE}! "$WORK_DIR/Highlightx1.png")
    BUTTON_CMD6=(convert -size ${THUMB_SIZE}+5+5 xc:none +antialias -fill none \
    -stroke "$SELECT_COLOUR" -strokewidth 4 -draw @draw_file "$WORK_DIR/Selectx1.png")
    BUTTON_CMD6b=(convert -size ${TT_DIM[t]} xc:none +antialias -fill none \
    -stroke "$SELECT_COLOUR" -strokewidth 4 -draw @draw_file${t} \
    "$WORK_DIR/$(printf %06d%s%s ${t} -select .png)")
    BUTTON_CMD7=(convert -size ${THUMB_SIZE}+5+5 xc:none +antialias -fill none \
    -stroke "$HIGHLIGHT_COLOUR" -strokewidth 4 -draw @draw_file "$WORK_DIR/Highlightx1.png")
    BUTTON_CMD7b=(convert -size ${TT_DIM[t]} xc:none +antialias -fill none \
    -stroke "$HIGHLIGHT_COLOUR" -strokewidth 4 -draw @draw_file${t} \
    "$WORK_DIR/$(printf %06d%s%s ${t} -highlight .png)")

    if [ "$BUTTON_STYLE" = "text" ]; then
        if $FEATHER; then
            "${BUTTON_CMD[@]}" miff:- | "${BUTTON_CMD3[@]}" \
            "$WORK_DIR/$(printf %06d%s%s ${t} -select .png)"
            "${BUTTON_CMD1[@]}" miff:- | "${BUTTON_CMD3[@]}" \
            "$WORK_DIR/$(printf %06d%s%s ${t} -highlight .png)"
        else
            "${BUTTON_CMD[@]}" miff:- | "${BUTTON_CMD2[@]}" miff:- |
            "${BUTTON_CMD3[@]}" \
            "$WORK_DIR/$(printf %06d%s%s ${t} -select .png)"
            "${BUTTON_CMD1[@]}" miff:- | "${BUTTON_CMD2[@]}" miff:- |
            "${BUTTON_CMD3[@]}" "$WORK_DIR/$(printf %06d%s%s ${t} -highlight .png)"
        fi
    elif [ $BUTTON_STYLE = "rect" ]; then
        if  ! $PNG_IS_DONE; then
            if $SHOWCASE; then
                "${BUTTON_CMD6[@]}"
                "${BUTTON_CMD7[@]}"
            else
                "${BUTTON_CMD4[@]}" 2> /dev/null
                "${BUTTON_CMD5[@]}" 2> /dev/null
            fi
        fi
    elif [ $BUTTON_STYLE = "text-rect" ]; then
        "${BUTTON_CMD6b[@]}"
        "${BUTTON_CMD7b[@]}"
    fi
    [[ -z ${ROTATE_ARRAY[@]} ]] && PNG_IS_DONE=: # do not loop over creating same png
done
#if ! $NOASK && ! $SHOWCASE; then
#    echo "Creating and displaying a preview of the main menu."
#    echo "(Press 'q' or ESC in the preview window to close it.)"
#fi
if [ "$BUTTON_STYLE" = "rect" ]; then
    BUTTON_DIM=$(get_image_dim "$WORK_DIR/Highlightx1.png")
    for button in Select Highlight; do
        if $SHOWCASE; then
            unset sc_spumux_cmd fake_montage_cmd
            convert -size $BUTTON_DIM xc:none -background none $WORK_DIR/empty-button.png
            fake_montage=( $WORK_DIR/Highlightx1.png $(for ((i=0; i<NUM_FILES-1; i++)); do
            echo $WORK_DIR/empty-button.png; done))
            for ((i=0; i<=NUM_FILES; i++)); do
                fake_montage_cmd=( ${fake_montage_cmd[@]} ${SHOWCASE_THUMB_PAGES[i]} "${fake_montage[i]}")
                sc_spumux_cmd=( ${sc_spumux_cmd[@]} ${SHOWCASE_THUMB_PAGES[i]} "$WORK_DIR/${button}x1.png" )
            done
            convert  -size $VIDSIZE xc:none -background none \
            ${fake_montage_cmd[@]} -mosaic "$WORK_DIR/fake_montage.png"
            convert  -size $VIDSIZE xc:none -background none \
            ${sc_spumux_cmd[@]} -mosaic "$WORK_DIR/${button}.png"
        else
            montage -background none \
            $(for ((i=0; i<=NUM_FILES; i++)); do echo $WORK_DIR/${button}x1.png;done) \
            -tile ${TILE_ARRAY[NUM_FILES]} -geometry ${THUMB_SIZE}+10+4 \
            -bordercolor none -mattecolor transparent miff:- |
            convert  -colors 3 -size $VIDSIZE xc:none - -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} \
            -composite  "$WORK_DIR/${button}.png"
            convert -size $BUTTON_DIM xc:none -background none $WORK_DIR/empty-button.png
            fake_montage=( $WORK_DIR/Highlightx1.png $(for ((i=0; i<NUM_FILES-1; i++)); do
            echo $WORK_DIR/empty-button.png; done))
            montage -background none ${fake_montage[@]} \
            -tile ${TILE_ARRAY[NUM_FILES]} -geometry ${GEO_ARRAY[NUM_FILES]}+10+4 \
            -bordercolor none -mattecolor transparent miff:- |
            convert  -size $VIDSIZE xc:none - -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} \
            -composite "$WORK_DIR/fake_montage.png"
        fi
    done
elif [[ "$BUTTON_STYLE" = *text* ]]; then
    if $SHOWCASE && [[ $BUTTON_STYLE = "text-rect" ]]; then
        select_buttons=( ${select_buttons[@]} \
        $(find $WORK_DIR/ -name 00\*select.png |sort) )
        highlight_buttons=( ${highlight_buttons[@]} \
        $(find $WORK_DIR/ -name 00\*highlight.png |sort) )
        for ((i=0; i<=NUM_FILES; i++)); do
            sc_select_cmd=(${sc_select_cmd[@]} ${THUMBTITLES_ARRAY[i]} "${select_buttons[i]}")
            sc_highlight_cmd=(${sc_highlight_cmd[@]} ${THUMBTITLES_ARRAY[i]} "${highlight_buttons[i]}")
        done
        convert -colors 3 -size $VIDSIZE xc:none -background none \
        ${sc_highlight_cmd[@]} -mosaic "$WORK_DIR/Highlight.png"
        convert  -colors 3 -size $VIDSIZE xc:none -background none \
        ${sc_select_cmd[@]} -mosaic "$WORK_DIR/Select.png"
    else
        select_buttons=( ${select_buttons[@]} \
        $(find $WORK_DIR/ -name 00\*select.png |sort) )
        highlight_buttons=( ${highlight_buttons[@]} \
        $(find $WORK_DIR/ -name 00\*highlight.png |sort) )
        montage -background none ${select_buttons[@]} \
        -tile ${TILE_ARRAY[NUM_FILES]} -geometry ${GEO_ARRAY[NUM_FILES]}+10+4 \
        -bordercolor none -mattecolor transparent miff:- |
        convert  -size $VIDSIZE xc:none - -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} \
        -composite "$WORK_DIR/Select.png"
        montage -background none ${highlight_buttons[@]} \
        -tile ${TILE_ARRAY[NUM_FILES]} -geometry ${GEO_ARRAY[NUM_FILES]}+10+4 \
        -bordercolor none -mattecolor transparent miff:- |
        convert  -size $VIDSIZE xc:none - -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} \
        -composite "$WORK_DIR/Highlight.png"
        BUTTON_DIM=$(get_image_dim "$WORK_DIR/000000-highlight.png")
        convert -size $BUTTON_DIM xc:none -background none $WORK_DIR/empty-button.png
        fake_montage=( $WORK_DIR/000000-highlight.png $(for ((i=0; i<NUM_FILES-1; i++)); do
        echo $WORK_DIR/empty-button.png; done))
    fi
    if $SHOWCASE; then
        if [[ $BUTTON_STYLE = "text-rect" ]]; then
            convert  -size $VIDSIZE xc:none -background none \
            ${THUMBTITLES_ARRAY[0]} $WORK_DIR/000000-highlight.png \
            -mosaic "$WORK_DIR/fake_montage.png"
        fi
    else
        montage -background none ${fake_montage[@]} \
        -tile ${TILE_ARRAY[NUM_FILES]} -geometry ${GEO_ARRAY[NUM_FILES]}+10+4 \
        -bordercolor none -mattecolor transparent miff:- |
        convert  -size $VIDSIZE xc:none - -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} \
        -composite "$WORK_DIR/fake_montage.png"
    fi
elif $SHOWCASE && [[ "$BUTTON_STYLE" = "line" ]]; then
    for i in ${!TITLES[@]}; do
        XPT1=$( cut -f2 -d+ <<< ${THUMBTITLES_ARRAY[i]} )
        XPT2=$(( XPT1 + ${TT_DIM[i]%%x*} ))
        YPT=$( cut -f3 -d+ <<< ${THUMBTITLES_ARRAY[i]} )
        YPT=$(( YPT + ${TT_DIM[i]##*x} ))
        echo  "line ${XPT1},${YPT} ${XPT2},${YPT}" >> "$WORK_DIR/spumux_drawfile"
        [[ $i -eq 0 ]] && echo  "line ${XPT1},${YPT} ${XPT2},${YPT}" >> "$WORK_DIR/fake_montage.mvg"
    done
        convert -size $VIDSIZE xc:none -fill none -stroke $SELECT_COLOUR \
        -strokewidth 2 -draw @spumux_drawfile "$WORK_DIR/Select.png"
        convert -size $VIDSIZE xc:none -fill none -stroke $HIGHLIGHT_COLOUR \
        -strokewidth 2 -draw @spumux_drawfile "$WORK_DIR/Highlight.png"
        convert  -size $VIDSIZE xc:none -fill none -stroke $HIGHLIGHT_COLOUR \
        -strokewidth 2 -draw @fake_montage.mvg "$WORK_DIR/fake_montage.png"
fi
if $PLAYALL ||  ($TITLESET_MODE && ! $NO_VMGM_MENU); then
    convert -gravity SouthEast -geometry +55+55 "$WORK_DIR/Select.png" \
    $WORK_DIR/${HIGHLIGHT_COLOUR/\#}_se_button.png -composite "$WORK_DIR/Select.png"
    convert -gravity SouthEast -geometry +55+55 "$WORK_DIR/Highlight.png" \
    $WORK_DIR/${SELECT_COLOUR/\#}_se_button.png -composite "$WORK_DIR/Highlight.png"
fi

# this reduces colours so spumux is happy
for button in Select Highlight; do
    mogrify -channel A -threshold 99% "$WORK_DIR/${button}.png"
done
if $SHOWCASE; then
    if ! $NO_SC_THUMB; then
        # find out where to put the showcase image/video in the X axis
        sc_size=$(get_image_dim "$WORK_DIR/showcase_img.png")
        sc_width=${sc_size/x*}
        sc_height=${sc_size/*x}
    fi
    if ! $NO_SC_THUMB; then #&& ! $TEXTMENU; then
        if [[ "$SC_TITLE_ALIGN" = "center" ]]; then
            if [[ $WIDEST_TITLE -ge ${THUMB_SIZE/x*} ]]; then
                BUTTON_COLUMN1=$(( (${THUMB_SIZE/x*} / 2) + (WIDEST_TITLE / 2) ))
            else
                BUTTON_COLUMN1=${THUMB_SIZE/x*}
            fi
        elif [[ "$SC_TITLE_ALIGN" = "west" ]]; then
            if [[ $WIDEST_TITLE -ge ${THUMB_SIZE/x*} ]]; then
                BUTTON_COLUMN1=$((WIDEST_TITLE + 5))
            else
                BUTTON_COLUMN1=${THUMB_SIZE/x*}
            fi
        elif [[ "$SC_TITLE_ALIGN" = "east" ]]; then
            BUTTON_COLUMN1=$(( ${THUMB_SIZE/x*} + WIDEST_TITLE ))
        fi
        if ! $TEXTMENU; then
        sc_space=$((${VIDSIZE%x*} - \
            ${SHOWCASE_THUMB_X_ARRAY[0]} - BUTTON_COLUMN1 - SAFE_AREA))
        sc_xpage=$(( ${SHOWCASE_THUMB_X_ARRAY[0]} + BUTTON_COLUMN1 \
            + (sc_space / 2) - (sc_width / 2) ))
        else
            BUTTON_COLUMN1=$((WIDEST_TITLE + 5))
            sc_space=$((${VIDSIZE%x*} - \
                ${SHOWCASE_TITLES_X_ARRAY[0]} - BUTTON_COLUMN1 - SAFE_AREA))
            sc_xpage=$(( ${SHOWCASE_TITLES_X_ARRAY[0]} + BUTTON_COLUMN1 \
            + (sc_space / 2) - (sc_width / 2) ))
            if [[ $BUTTON_GRAVITY = *east* ]]; then
                BUTTON_COLUMN1=$WIDEST_TITLE
                sc_space=$((${VIDSIZE%x*} - (SAFE_AREA * 2) - BUTTON_COLUMN1))
                sc_xpage=$((SAFE_AREA + (sc_space / 2) - (sc_width / 2) ))
            fi
        fi
        # find out where to put the showcase image in the Y axis
        if ! $TEXTMENU; then
            Y1=${SHOWCASE_THUMB_Y_ARRAY[0]}; Y2=${SHOWCASE_THUMB_Y_ARRAY[NUM_FILES]}
            ((NUM_FILES >= LEFT_MAX)) && Y2=${SHOWCASE_THUMB_Y_ARRAY[SPLIT-1]}
            Y_SPACE=$(( (Y2 - Y1) + ${THUMB_SIZE/*x} ))
            Y_SPACE=$(( Y_SPACE - sc_height ))
            SC_Y=$(( Y_SPACE / 2))
            SC_Y=$(( ${SHOWCASE_THUMB_Y_ARRAY[0]} + SC_Y ))
        else # TEXTMENU
#            ((NUM_FILES < SPLIT)) && split=$NUM_FILES || split=$((SPLIT - 1))
            # if there is a menu title, move the showcase thumb up or down
            if [[ -n $MENU_TITLE ]] && ! $USER_SC_GEO && ! $USER_TITLE_GEO; then
                [[ $TITLE_GRAVITY = south ]] && TITLE_SPACE="- $(( (title_yoffset + TITLE_TEXT_YDIM) / 2))"
                [[ $TITLE_GRAVITY = north ]] && TITLE_SPACE="+ $(( (title_yoffset + TITLE_TEXT_YDIM) / 2))"
            fi
            Y_SPACE=${VIDSIZE#*x}
            SC_Y=$(( (Y_SPACE / 2) - (sc_height / 2) $TITLE_SPACE ))
        fi

        ! $TEXTMENU && [[ $V_TOTAL -gt 5 ]] && sc_xpage=$(( ( ${VIDSIZE/x*} / 2 ) - (sc_width / 2) ))
        $TEXTMENU && [[ -n $tt_ygeos_col2 ]] && sc_xpage=$(( ( ${VIDSIZE/x*} / 2 ) - (sc_width / 2) ))
        $USER_SC_GEO && sc_xpage=${SHOWCASE_GEO/x*}
        $USER_SC_GEO && SC_Y=${SHOWCASE_GEO/*x}
        SC_IMG_PAGE="-page +$sc_xpage+$SC_Y"
        SC_IMG_CMD="$SC_IMG_PAGE "$WORK_DIR/showcase_img.png""
    fi
    if $NO_SC_THUMB; then unset SC_IMG_CMD; fi
    if [[ -n "$SHOWCASE_IMG" || -n "$SHOWCASE_VIDEO" ]]; then
        unset sc_cmd
        for ((i=0; i<=NUM_FILES; i++)); do
            sc_cmd=( ${sc_cmd[@]} ${SHOWCASE_THUMB_PAGES[i]} "${PICS[i]}")
        done
        $TEXTMENU && unset sc_cmd
        if $TRANSPARENT; then
            IM_CMD0=(convert  -size $VIDSIZE xc:none -background none \
            ${sc_cmd[@]} $SC_IMG_CMD -mosaic)
            IM_CMD1=(convert -size $VIDSIZE -background none \
            - ${sc_thumb_title_cmd[@]} -mosaic)
            IM_CMD2=(composite -size $VIDSIZE -background none \
            -gravity NorthWest  -dissolve $OPACITY - "$WORK_DIR/pics/template.png" \
            -background none)
            IM_CMD3=(convert - $WORK_DIR/title_txt.png  \
            -gravity $TITLE_GRAVITY -geometry ${title_xoffset}${title_yoffset} \
            -composite "$WORK_DIR/preview.jpg" )
            echo "Running
            "${IM_CMD0[@]}" miff:- | "${IM_CMD1[@]}" miff:- |
            "${IM_CMD2[@]}" miff:- | "${IM_CMD3[@]}"
            " |format_output
            "${IM_CMD0[@]}" miff:- | "${IM_CMD1[@]}" miff:- |
            "${IM_CMD2[@]}" miff:- | "${IM_CMD3[@]}"
        else
            echo "Running:
            convert  -size $VIDSIZE "$WORK_DIR/pics/template.png"
            ${sc_cmd[@]} $SC_IMG_CMD \
            -mosaic "$WORK_DIR/preview.jpg" "|sed "s/    */ /g;s/^ *//"|fold -bs
            convert  -size $VIDSIZE "$WORK_DIR/pics/template.png" \
            ${sc_cmd[@]} $SC_IMG_CMD \
            -mosaic "$WORK_DIR/preview.jpg"
        fi
        unset sc_cmd IM_CMD05 IM_CMD04 IM_CMD03 IM_CMD4
    fi
else # not showcase

    if $TRANSPARENT; then
        yecho "Running:
        montage ${PICS[@]} -blur 0x.3 -tile ${TILE_ARRAY[NUM_FILES]} \
        -geometry ${GEO_ARRAY[NUM_FILES]}+10+4 -background none -bordercolor "#444744" miff:- |
        composite -dissolve $OPACITY \
        -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} - \
        "$WORK_DIR/pics/template.png" -background none miff:- |
        convert - "$WORK_DIR/title_txt.png"  \
        -gravity $TITLE_GRAVITY -geometry ${title_xoffset}${title_yoffset} \
        -composite "$WORK_DIR/preview.jpg"
        " | fold -bs
        montage ${PICS[@]} -blur 0x.3 -tile ${TILE_ARRAY[NUM_FILES]} \
        -geometry ${GEO_ARRAY[NUM_FILES]}+10+4 -background none -bordercolor "#444744" miff:- |
        composite -dissolve $OPACITY \
        -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} - \
        "$WORK_DIR/pics/template.png" -background none miff:- |
        convert - "$WORK_DIR/title_txt.png"  \
        -gravity $TITLE_GRAVITY -geometry ${title_xoffset}${title_yoffset} \
        -composite "$WORK_DIR/preview.jpg"
    else # Not transparent
        montage ${PICS[@]} -tile ${TILE_ARRAY[NUM_FILES]} \
        -geometry ${GEO_ARRAY[NUM_FILES]}+10+4  -background none -bordercolor "#444744" miff:- |
        convert "$WORK_DIR/pics/template.png" "$WORK_DIR/title_txt.png"  -gravity $TITLE_GRAVITY \
        -geometry ${title_xoffset}${title_yoffset} -composite -  -gravity $BUTTON_GRAVITY \
        -geometry +${XGEO}+${YGEO} -composite "$WORK_DIR/preview.jpg"
    fi
fi
if ! $NOASK; then
    echo "Creating and displaying a preview of the main menu."
    echo "(Press 'q' or ESC in the preview window to close it.)"
fi
# make the fake montage with highlighted 1st button and display it
composite -compose Over "$WORK_DIR/fake_montage.png" "$WORK_DIR/preview.jpg" \
"$WORK_DIR/preview.jpg"
if ($PLAYALL || ($TITLESET_MODE && ! $NO_VMGM_MENU) ) && ! $VMGM_ONLY; then
convert -gravity SouthEast -geometry +55+55 "$WORK_DIR/preview.jpg" \
"$SE_BTN" -composite "$WORK_DIR/preview.jpg"
fi
if ! $NOASK; then
    convert -resize $PREVIEW_SIZE! "$WORK_DIR/preview.jpg" miff:- |
    display -title "todisc preview - close window to continue" -
    confirm_preview
fi
# copy the template back if using $MENU_FADE
if $MENU_FADE; then
    rm -v "$WORK_DIR/pics/template.png"
    cp -v "$WORK_DIR/pics/template.bk.png" "$WORK_DIR/pics/template.png"
fi
#rm -fv "${PICS[@]}"
unset PICS IM_CMD1 IM_CMD2 IM_CMD3 IM_CMD4 IM_CMD5

###############################################################################
#   get information about input videos, and some post preview preliminaries   #
###############################################################################

# if -bgvideo selected, but not -bgaudio, offer to use audio from bgvideo
if ! $NOASK; then
    if [[ -n "$BG_VIDEO" && -z "$BG_AUDIO" ]]; then
        if ! mencoder -quiet "$BG_VIDEO" -oac pcm -ovc copy -frames 0 \
        -o /dev/null 2>&1|grep Audio 2>&1 >/dev/null; then
            :
        else
            echo "You selected -bgvideo but not -bgaudio"
            echo "If you want to use the audio from "$BG_VIDEO" please type: yes"
            read bgaudio
            if [ ! -z "$bgaudio" -a "$bgaudio" = "yes" ]; then
                BG_AUDIO="$BG_VIDEO"
                echo "Using audio from "$BG_VIDEO""
            else
                echo "No audio selected, will use silence for main menu"
            fi
        fi
    fi
fi

# Check input files for compliance; offer to tovid-encode non-compliant files
if ! $VMGM_ONLY && [[ $MENU_NUM -eq 1 ]]; then
    check_compliance
    $GROUPING && check_compliance group
fi
# check bgvideo and showcase VIDEO for compliance ( if present )
tovid_reencode()
{
    VIDEO_IN="$1"
    VIDEO_IN_SEEK="$2"
    yecho
    yecho "$VIDEO_IN is not compliant - re-encoding $(bc <<< "$VIDEO_IN_SEEK + $ANI_MENU_LENGTH") second slice to DVD compliant file"
    yecho "if you used a long seek this will take some time and produce a large file."
    yecho "But if the file is not encoded this way there may be sync problems."
    yecho "Do you want to continue encoding this file?, type 'yes' to do so"
    if ! $NOASK; then
        read response
        if [ ! -z "$response" -a "$response" = "yes" ]; then
            :
        else
            return
        fi
    fi
    yecho
    tovid $NO_ASK -in "$VIDEO_IN" -slice 0-$((VIDEO_IN_SEEK + ANI_MENU_LENGTH)) -$TV_STANDARD \
    -$TARGET -in "$VIDEO_IN" -out "$VIDEO_IN.enc" $TOVID_OPTS
    # See if output file exists
    if ! test -f "$VIDEO_IN.enc.mpg"; then
        runtime_error "Could not encode file: $VIDEO_IN"
    fi
    SUPPORT_VIDEOS=( "${SUPPORT_VIDEOS[@]}" "$VIDEO_IN.enc.mpg" )
    yecho "Encoded file is "$VIDEO_IN.enc.mpg", this will be deleted when todisc is finished unless you used -keepfiles"
    yecho
}
if [[ -n $BG_VIDEO ]] && ! idvid -isformat dvd "$BG_VIDEO" >/dev/null; then
    tovid_reencode "$BG_VIDEO" $BG_SEEK && BG_VIDEO="$BG_VIDEO.enc.mpg"
elif [[ -n $SHOWCASE_VIDEO ]]  && ! idvid -isformat dvd "$SHOWCASE_VIDEO" >/dev/null; then
    tovid_reencode "$SHOWCASE_VIDEO" $SHOWCASE_SEEK_VAL && SHOWCASE_VIDEO="$SHOWCASE_VIDEO.enc.mpg"
fi
# symlink IN_FILES in $WORK_DIR to solve some quoting issues for dvdauthor
if [[ $MENU_NUM -eq 1 ]]; then
    for i in ${!IN_FILES[@]}; do
        (cd "$REAL_WORK_DIR" &&  ln -sv "${IN_FILES[i]}" "$BASEDIR/${TSET_NUM}-$((i+1)).mpg")
    done
fi
# Store info about input files in an array
for ((i=0; i<${#IN_FILES[@]}; i++)); do
    # use a nav_seek file and transcode if long seek
    if [ ${SEEK_VAL[i]%.*} -gt 450 ] || $SUB_MENU || $SWITCHED_MODE; then
        STATS_FRAMES="-frames 1"
        if [ ! -e  "${IN_FILES[i]}".nav_log ]; then
#            NAVSEEK[i]="--nav_seek "$BASEDIR/${TSET_NUM}-nav${i}_log""
            NAVSEEK[i]="--nav_seek "${IN_FILES[i]}".nav_log"
            NAVSEEK_CMD=(nice tcdemux  $TCDEMUX_MODE -f $FRAME_RATE -W -i "${IN_FILES[i]}")
            run_navseek()
            {
                yecho "Running "${NAVSEEK_CMD[@]}" > "${IN_FILES[i]}".nav_log"
                "${NAVSEEK_CMD[@]}"  2>> "$WORK_DIR/tc_pids" >  "${IN_FILES[i]}".nav_log
            }

            run_navseek &
            NS_PID="$!"
            if [[ -n "$NS_PID" ]]; then
                while ps -p $NS_PID >/dev/null; do
                    sleep 2 # spinner interval
                    spin "Creating a nav_seek log for "${IN_FILES[i]/*\/}": $SPINNER"
                done
            fi
        fi
    fi
    length=( ${length[@]} $(( $(awk '{ field = $2 }; END{ print field }' \
        "${IN_FILES[i]}".nav_log) + 1)) )
    [[ $MENU_NUM -eq 1 ]] && echo
    if [[ $MENU_NUM -eq 1 ]]; then
        echo "Getting stats on "${IN_FILES[i]}""
        mencoder_stats=("${mencoder_stats[@]}" \
        "$(mencoder -quiet "${IN_FILES[i]}" -oac pcm -ovc copy \
        $STATS_FRAMES -o /dev/null 2>&1)")
        unset NAVSEEK_CMD
    fi
done
if $GROUPING &&  [[ $MENU_NUM -eq 1 ]]; then
    echo
    echo ". . . Getting stats on grouped files now . . ."
    echo
    for u in ${!grouping[@]}; do
        echo "Getting stats on "$(readlink "${grouping[u]}")""
        echo
        group_mencoder_stats=( "${group_mencoder_stats[@]}" \
        "$(mencoder -quiet "${grouping[u]}" -oac pcm -ovc copy \
        $STATS_FRAMES -o /dev/null 2>&1)")
    done
fi

# put in the log file in case anyone is interested
if ! $VMGM_ONLY &&  [[ $MENU_NUM -eq 1 ]]; then get_stats files; echo; fi
if ! $VMGM_ONLY &&  [[ $MENU_NUM -eq 1 ]] && $GROUPING; then
    get_stats group
    echo; echo $SEPARATOR
fi

for ((i=0; i<${#mencoder_stats[@]}; i++)); do
    if [ -e "${IN_FILES[i]}".nav_log ]; then
        VID_LEN=( ${VID_LEN[@]}  $(awk_math ${length[i]} by $FRAME_RATE float) )
    else
        VID_LEN=( ${VID_LEN[@]}  "$(awk '/Video stream:/{print $10}' \
        <<<"${mencoder_stats[i]}")" )
    fi
done
if $GROUPING; then
    index=0
    for i in "${!IN_FILES[@]}"; do
        if [[ ${GROUP[i]} ]]; then
            iter=( $BASEDIR/${TSET_NUM}-group-$((i+1))-* )
            for ((t=index; t<index+${#iter[@]}; t++)); do
                GROUP_VID_LENGTHS[i]="${GROUP_VID_LENGTHS[i]} $(awk '/Video stream:/{print $10}' \
                <<< "${group_mencoder_stats[t]}")"
            done
            index=$((index+${#iter[@]}))
            unset iter
            GROUP_VID_LENGTHS[i]="${VID_LEN[i]} ${GROUP_VID_LENGTHS[i]}"
            GROUP_TOT_LEN[i]=$(awk_total <<< "${GROUP_VID_LENGTHS[i]}")
        fi
    done
fi
echo
for ((i=0; i<${#VID_LEN[@]}; i++)); do
    NEW_LENGTH=( ${NEW_LENGTH[@]}   ${VID_LEN[i]%.*} )
done
# find out longest video and shortest video
for ((i=0; i<${#NEW_LENGTH[@]}; i++)); do
    val=${NEW_LENGTH[i]}
    [ -z "$MAX_VAL" ] || ((val > MAX_VAL)) && MAX_VAL=$val && max_key=$i
    if $ANI_SUB_MENU; then
        [ -z "$MIN_VAL" ]  || ((val < MIN_VAL)) && MIN_VAL=$val && min_key=$i
    fi
done
# if animated submenu check if videos are long enough for the # of chapters
if $ANI_SUB_MENU; then
    for ((i=0; i<=NUM_FILES; i++)); do
        S=$(awk_math ${SEEK_VAL[i]} times $FRAME_RATE)
        F=$(awk_math  "${CHAPTERS[i]}" times 340 )
        V=$(awk_math "${VID_LEN[i]}" times $FRAME_RATE)
        if [ $((V - S)) -le $F ] ; then
            echo "Sorry, you can not use ${CHAPTERS[i]} chapters for ${IN_FILES[i]}"
            echo "The maximum number for this video (using a -seek of ${SEEK_VAL[i]}):"
            echo "$(awk_math $((V - S)) by 340) chapters"
            exit 1
        fi
        unset V F
    done
fi
# allow animated menus of length of longest video
MAX_ANI_LENGTH=$(awk_math $FRAME_RATE times $ANI_MENU_LENGTH)
MAX_VAL_FRAMES="$((MAX_VAL * 30))"
#if [ $MAX_VAL_FRAMES -lt $MAX_ANI_LENGTH ]; then #FIXME - removed to see how it flys
#    MAX_ANI_LENGTH=$MAX_VAL_FRAMES
#fi
# if submenu selected, translate seconds of submenu length into # of frames
if $ANI_SUB_MENU; then
    ANI_SUBMENU_FRAMES=$(awk_math $FRAME_RATE times $ANI_SUBMENU_LENGTH)
fi

ANI_FRAMES=$MAX_ANI_LENGTH
if $STATIC; then
    FRAMES=1
else
    FRAMES=$ANI_FRAMES
fi
###############################################################################
#                           End of info block                                 #
###############################################################################

###############################################################################
#                       work on the clip title images                         #
###############################################################################
# extract images from the provided background video
if ! $TEXTMENU; then
    echo
    echo "Creating $FRAMES images from each video for the main menu"
    if [ "$SC_FRAMESTYLE" = "glass" ]; then
        D=2
        VOUT="png:z=7"
        FRAME_SIZE=$THUMB_SIZE
        for ((i=0; i<=NUM_FILES; i++)) ; do
            echo "Using mplayer to get framed images from "${IN_FILES[i]}""
            OUT=$WORK_DIR/pics/$i
            echo "Working on "${IN_FILES[i]}""
            MPLAYER_SEEK_VAL=${SEEK_VAL[i]}
            get_framed_pics "${IN_FILES[i]}"   >> "$LOG_FILE" 2>&1
            echo
            for ((p=1; p<=$FRAMES; p++)); do
                mv  "$WORK_DIR"/$(printf "%08d%s" $p .png) \
            $WORK_DIR/pics/$i/$(printf "%06d%s" $p .png) 2>/dev/null
            done
        done
    else
        for ((i=0; i<=NUM_FILES; i++)) ; do
            echo "Working on "${IN_FILES[i]}""
            TRANSCODE_CMD2=(nice transcode --print_status 10 \
            --write_pid $WORK_DIR/tcode$i.pid -q 1 -i "${IN_FILES[i]}" \
            -c ${SEEK_FRAMES[i]}-$((${SEEK_FRAMES[i]} + $FRAMES)) ${NAVSEEK[i]} \
            -o "$WORK_DIR/pics/$i/" -f $FRAME_RATE  -Z $THUMB_SIZE $EXPORT)

                    function run_transcode()
                    {
                        "${TRANSCODE_CMD2[@]}" >> "$LOG_FILE"  2>&1
                        sleep 1
                    }
                    run_transcode &
                    sleep 1 # short sleep to allow 1st jpg to appear
                    TRANSCODE_PID=$(<$WORK_DIR/tcode$i.pid)
                    check_stall &
                    if [[ -n "$TRANSCODE_PID" ]]; then
                        while ps -p $TRANSCODE_PID >/dev/null; do
                            sleep 2 # spinner interval
                        spin "Seeking in video and creating images: $(find $WORK_DIR/pics/$i \
                    -maxdepth 1 -name \*.$IMG_FMT|sort|awk -F / '{ field = $NF }; END{ print field }')"
                        done
                        echo
                        echo "Created $(find $WORK_DIR/pics/$i -maxdepth 1 -name \*.$IMG_FMT|wc -l) images of $FRAMES"
                        #cleanlog 1
                    else
                        #cleanlog 1
                        runtime_error "Problem creating images from the video."
                        exit 1
                    fi
                    unset TRANSCODE_CMD2 run_transcode
        done
    fi
fi
# create the pics for background image
    if [ -z "$BG_PIC" ]; then
        echo
        echo "Creating a black background"
        BG_PIC="$WORK_DIR/pics/template.jpg"
        convert  -size $VIDSIZE xc:"#161514" "$BG_PIC"
        convert  -size $VIDSIZE xc:"#161514" "$WORK_DIR/submenu_template.jpg"
    else
        convert -resize $VIDSIZE! "$BG_PIC" "$WORK_DIR/pics/template.jpg"
        convert -size $VIDSIZE xc:"#161514" "$WORK_DIR/submenu_template.jpg"
    fi

echo
# chapters and submenu xml stuff

for ((s=0; s<=NUM_FILES; s++)); do
    # make appropriate chapter lengths for each video
    # get chapter lengths by dividing by $CHAPTERS, then getting running totals
    CHAPT_INTERVALS=( ${CHAPT_INTERVALS[@]} "$(awk_math ${VID_LEN[s]} by ${CHAPTERS[s]} float)" )
    # <TODO if GROUPING:  for making chapter thumbs for the group
    # feed group chapter points to transcode in a loop to transcode as usual, but output
    # to different subdirs.  Then rename according to framenumber, moving all to the same subdir
    # then follow same procedure as usual in moving into chapter subdirs for final montages
    # /TODO>
    # and format in HH:MM:SS
    L=( ${L[@]} $(for ((i=1; i<=${CHAPTERS[s]}; i++)) ; do echo "${CHAPT_INTERVALS[s]}";done) )
    chapt_intervals=$(running_total <<< ${L[@]})
    chapters="$(for c in $chapt_intervals; do echo $(format_seconds $c); done)"
    chapters="00:00:00.000 $chapters"
    if [ ${CHAPTERS[s]} = 1 ]; then chapters="00:00:00.000"; fi
    CHAPTS=$(for i in $chapters; do echo -n $i,;done)
    CHAPT_ARRAY[s]="${CHAPTS%?}" # %? to remove trailing ','
    unset L cmd
    if $SUB_MENU; then
        echo
        echo "Creating the highlight and selection PNGs for submenu $((s + 1))"
        C=$((${CHAPTERS[s]} - 1))
        MENU_BUTTON_SIZE="${GEO_ARRAY[C]}"
        get_button_geo
(
cat  <<EOF
rectangle 2,2 $GEO
EOF
)  > $WORK_DIR/draw_file${s}

        convert -size "${GEO_ARRAY[C]}+5+5" xc:none -fill none \
        +antialias -stroke "$SELECT_COLOUR" -strokewidth 4 -draw @draw_file${s} \
        -colors 3 "$WORK_DIR/Submenu${s}_Selectx1.png"
        convert -size "${GEO_ARRAY[C]}+5+5" xc:none -fill none \
        +antialias -stroke "$HIGHLIGHT_COLOUR" -strokewidth 4 -draw @draw_file${s} \
        -colors 3 "$WORK_DIR/Submenu${s}_Highlightx1.png"
        for button in Select Highlight; do
            montage -background none \
            $(for ((i=0; i<=C; i++)); do
            echo $WORK_DIR/Submenu${s}_${button}x1.png;done) \
            -tile ${TILE_ARRAY[C]} \
            -geometry ${GEO_ARRAY[C]}+5+5 \
            -bordercolor none -mattecolor transparent miff:- |

            convert  -colors 3 -size $VIDSIZE xc:none  - \
            -gravity north -geometry +0+45  \
            -composite  $WORK_DIR/Submenu${s}_${button}.png
        done
        # make submenu spumux.xml
(
    cat <<EOF
<subpictures>
   <stream>
     <spu force="yes" start="00:00:00.0"
          highlight="$WORK_DIR/Submenu${s}_Highlight.png"
          select="$WORK_DIR/Submenu${s}_Select.png"
          autooutline="infer"
          autoorder="rows"/>
   </stream>
 </subpictures>
EOF
) > "$WORK_DIR/submenu$((s + 1))_spumux.xml"
    fi
done
# debug chapters
if ! $VMGM_ONLY &&  [[ $MENU_NUM -eq 1 ]]; then
    echo
    for ((i=0; i<=NUM_FILES; i++)); do
        echo -e "Chapters for "${IN_FILES[i]}" are: \n"${CHAPT_ARRAY[i]}"\n"
    done
fi
if [[ "$BUTTON_STYLE" = "text" && -z "$OUTLINEWIDTH" ]]; then
    OUTLINEWIDTH="\"14\""
else
    [[ -z "$OUTLINEWIDTH" ]] && OUTLINEWIDTH="\"6\""
fi
if $PLAYALL ||  ($TITLESET_MODE && ! $NO_VMGM_MENU) || ($TSET_MODE && ! $NO_VMGM_MENU); then
    NUM_BUTTONS=$(( ${#FILES[@]} + 1 ))
else
    NUM_BUTTONS=${#FILES[@]}
fi
($SWITCHED_MODE || $SWITCHED_MENUS) && SPUMUX_XML="$BASEDIR/spumux.xml"
(
    cat <<EOF
<subpictures>
   <stream>
     <spu force="yes" start="$START"$END
       highlight="$WORK_DIR/Highlight.png"
       select="$WORK_DIR/Select.png"
       autooutline="infer"
       outlinewidth=$OUTLINEWIDTH
       autoorder="$AUTOORDER">
$(if $QUICK_NAV; then
    if $SWITCHED_MENUS; then
        down="down=\"ActionDown\"" && up="up=\"ActionUp\"" &&  lastup="up=\"ActionDown\""
        right="right=\"ActionDown\"" && left="left=\"ActionUp\""
    fi
    for ((i=1; i<=$NUM_BUTTONS; i++)); do
        ! $SWITCHED_MENUS && right="right=\"$((i+1))\"" && left="left=\"$((i-1))\""
        if [[ $i -eq 1 ]]; then
            echo -n "       <button name=\"$i\" $down $up"
        elif [[ $i -eq ${#FILES[@]} ]]; then
            if $TITLESET_MODE || $PLAYALL; then
                echo -n "       <button name=\"$i\" $up"
            else
                echo -n "       <button name=\"$i\" $down $up"
            fi
        else
            [[ $i -ne $(( ${#FILES[@]} + 1)) ]] && \
            echo -e "       <button name=\"$i\" $left $right $down $up/>"
        fi
        [[ $i -eq 1 ]] && echo -e " left=\"ActionLeft\" $right/>"
        if [[ $i -eq ${#FILES[@]} ]]; then
            echo -e " right=\"ActionRight\" $left/>"
            echo -e "       <action name=\"ActionLeft\"/>"
            echo -e "       <action name=\"ActionRight\"/>"
            if $SWITCHED_MENUS; then
                echo -e "       <action name=\"ActionDown\"/>"
                echo -e "       <action name=\"ActionUp\"/>"
            fi
        fi
        if [[ $i -eq $(( ${#FILES[@]} + 1 )) ]]; then
            echo -e "       <button name=\"$i\" $down $lastup/>"
        fi
    done
fi)   
$(if $SWITCHED_MENUS && ! $QUICK_NAV; then
    updown="down=\"ActionDown\" up=\"ActionUp\""
    for ((i=1; i<=$NUM_BUTTONS; i++)); do
        echo -e "       <button name=\"$i\" $updown/>"
    done
    echo -e "       <action name=\"ActionDown\"/>"
    echo -e "       <action name=\"ActionUp\"/>"
fi)
     </spu>
   </stream>
</subpictures>
EOF
) |sed '/^ *$/d'  > "$SPUMUX_XML"

if $SUB_MENU; then
    JUMP=menu
    POST="        <post> jump cell 1; </post>"
    if $ANI_SUB_MENU; then
        PAUSE=" pause=\"$PAUSE_TIME\""
    else
        PAUSE=" pause=\"inf\""
        unset POST
    fi
else
    JUMP=title
fi
if [ "$TARGET" = "dvd" ]; then
# make dvdauthor.xml
# g1 register: switched menus, g2: vmgm intro, g3: -quick-nav, g4: playall

# TSET_NUM supplied by the calling todisc script and is the current titleset #
MENU_FILE="$BASEDIR/animenu${TSET_NUM}-${MENU_NUM}.mpg"
$VMGM_ONLY && MENU_FILE="$BASEDIR/VMGM.mpg"
$SWITCHED_MODE && ! $VMGM_ONLY && MENU_FILE="$BASEDIR/animenu${TSET_NUM}-${MENU_NUM}.mpg"
$SWITCHED_MENUS && VMGM_PRE="<pre>$VMGM_PRE g1=1;</pre>"
$SWITCHED_MENUS && NUM_MENUS=${#FILES[@]} || NUM_MENUS=1
! $AUTHOR && DVDAUTHOR_XML="$BASEDIR/dvdauthor.xml"
(
    cat <<EOF
$(if $AUTHOR ; then
    echo "<?xml version=\"1.0\" encoding=\"utf-8\"?>"
    echo -e "<dvdauthor dest=\"$OUT_DIR\" jumppad=\"0\">"
    echo -e "  <vmgm>\n    <menus>\n      <pgc entry=\"title\" pause=\"0\">"
    echo -e "        $VMGM_PRE"
    echo -e "        $INTRO"
    echo -e "        <vob file=\"$WORK_DIR/dummy.mpg\"/>"
    echo -e "        <post>jump titleset 1 menu;</post>"
    echo -e "      </pgc>\n    </menus>\n  </vmgm>"
fi)
  <titleset>
    <menus>
$(for ((menu_num=1; menu_num<=NUM_MENUS; menu_num++)); do
    echo -e "      <pgc>"
    for ((i=1; i<=$V_TOTAL; i++)); do
        if $SUB_MENU; then
            JUMP_INC=$((i + NUM_MENUS))
        else
            JUMP_INC=$i
        fi
        echo -e "        <button name=\"$i\">jump $JUMP $JUMP_INC;</button>"
    done
    if $QUICK_NAV; then
        [[ $TSET_NUM -eq 1 ]] && PREV=$TSET_TOT || PREV=$(( TSET_NUM - 1 ))
        [[ $TSET_NUM -eq $TSET_TOT ]] && NEXT=1 || NEXT=$(( TSET_NUM + 1))
        echo -e "        <button name=\"ActionLeft\"> {g3=$PREV; button=1024; jump vmgm menu entry title;}</button>"
        echo -e "        <button name=\"ActionRight\"> {g3=$NEXT; button=1024; jump vmgm menu entry title;}</button>"
    fi
    if $SWITCHED_MENUS; then
        if [[ $menu_num -eq $NUM_MENUS ]]; then
            inc=1
        else
            inc=$((menu_num+1))
        fi
        [[ $menu_num -eq 1 ]] && dec=$NUM_MENUS || dec=$((menu_num - 1))
        echo -e "        <button name=\"ActionUp\">{ g1 = $dec; jump menu $dec; }</button>"
        echo -e "        <button name=\"ActionDown\">{ g1 = $inc; jump menu $inc; }</button>"
    fi
    if  $TITLESET_MODE && ! $NO_VMGM_MENU; then
        echo -e "        <button name=\"$((V_TOTAL + 1))\">g2=1; g3=1000; button=1024; jump vmgm menu;</button>"
    else
        $PLAYALL && echo -e "        <button name=\"$((V_TOTAL + 1))\">g4=1; jump title 1 chapter 1;</button>"
    fi
    echo -e "        <vob file=\"$BASEDIR/animenu${TSET_NUM}-${menu_num}.mpg\" pause=\"$VMGM_PAUSE_TIME\"/>"
    if $SWITCHED_MENUS; then
        if [[ $menu_num -eq 1 ]]; then
            echo -e "        <pre> { if (g1 ne 1) {jump menu 2;} button = g1 * 1024; } </pre>"
        else
            echo -e "        <pre> { button = g1 * 1024;} </pre>"
        fi
    fi    
    echo -e "$MAIN_PRE"
    echo -e "$MAIN_POST"
    echo -e "      </pgc>"
done)
$(if $SUB_MENU; then
    echo -ne "      <pgc>\n"
        for ((Y=1; Y<=$V_TOTAL; Y++)); do
            for ((g=1; g<="${CHAPTERS[Y-1]}"; g++)); do
                echo -e "        <button name=\"$g\">jump title $Y chapter $g;</button>"
            done
            echo -e "        <vob file=\"$BASEDIR/${TSET_NUM}-Menu$Y.mpg\"$PAUSE/>"
echo "$POST"
            echo "      </pgc>"
            echo "      <pgc>"
        done | sed '$d'
fi)
    </menus>
    <titles>
      $TITLES_VIDEO_TAG
$(if $SUBTITLES; then
    for ((s=0; s<${#SUBS_ARRAY[@]}; s++)); do
        echo -e "      <subpicture lang=\"${SUBS_ARRAY[s]}\"/>"
    done
fi)
$(for ((i=0; i<${#IN_FILES[@]}; i++)); do
    unset j
    echo -e "      <pgc>"
    if $AUDIOLANG; then
        echo "${VOB_PRE[i]}"
    fi
    if [[ -n ${GROUP[i]} ]]; then
        get_group_chapters $i format
        if ((${CHAPTERS[i]} == 0)); then
            echo -e "        <vob file=\"$BASEDIR/$i.mpg\"/>"
            for mpg in $BASEDIR/${TSET_NUM}-group-$((i+1))-*; do
                echo -e "        <vob file=\"$mpg\"/>"
            done
        else
            echo -e "        <vob file=\"$BASEDIR/${TSET_NUM}-$((i+1)).mpg\" $chpts0/>"
            for mpg in $BASEDIR/${TSET_NUM}-group-$((i+1))-*; do
                echo -e "        <vob file=\"$mpg\" ${chpts[++j]}/>"
            done
        fi
    else
        echo -ne "        <vob file=\"$BASEDIR/${TSET_NUM}-$((i+1)).mpg\""
        echo -e  " chapters=\""${CHAPT_ARRAY[i]}"\"/>"
    fi
    if $CHAIN_VIDEOS; then
        if [ "${POST_PLAY[i]}" = "chain" ]; then
            (( i < NUM_FILES )) && CHAIN_PP="jump title $((i + 2)) chapter 1"
            (( i == NUM_FILES )) && CHAIN_PP="jump title 1 chapter 1"
        else
            CHAIN_PP="call menu"
        fi
        if $PLAYALL; then
            if [ $i -lt $NUM_FILES ]; then
                echo -e "        <post>if (g4==1) jump title $((i+2)) chapter 1; $CHAIN_PP;</post>"
            else
                echo -e "        <post>call menu;</post>"
            fi
        else
            echo -e "        <post>$CHAIN_PP;</post>"
        fi
    else
        if $PLAYALL; then
            if [ $i -lt $NUM_FILES ]; then
                echo -e "        <post>if (g4==1) jump title $((i+2)) chapter 1; call menu;</post>"
            else
                echo -e "        <post>call menu;</post>"
            fi
        else
            echo -e "        <post>call menu;</post>"
        fi
    fi
    echo -e "      </pgc>"
done)
    </titles>
  </titleset>
$(if $AUTHOR; then
echo -e "</dvdauthor>"
fi)
EOF
) |sed '/^ *$/d' >> "$DVDAUTHOR_XML"
fi


##############################################################################
#                            Animenu stuff                                   #
##############################################################################

# make dummy VMGM mpeg
if ! $TITLESET_MODE && ! $DO_TITLESETS; then
    yecho "Creating a blank mpeg for the vmgm menu"
    convert  -resize $VIDSIZE! xc:"#161514" "$WORK_DIR/dummy.jpg"
    ENC_CMD1=(jpeg2yuv -v 0 -f $FRAME_RATE -I p -n 1 -l 30 -L 1 -b1 \
    -j "$WORK_DIR/dummy.jpg")
    ENC_CMD2=(ffmpeg   -f yuv4mpegpipe -i - -an -r $FRAME_RATE -s $VIDSIZE \
    -tvstd $TV_STANDARD $FFMPEG_OPTS -y "$WORK_DIR/dummy.m2v")
    if ${ENC_CMD1[@]} | ${ENC_CMD2[@]}  >> "$LOG_FILE.tmp" 2>&1; then
        cleanlog 3
    else
        cleanlog 3
        runtime_error
    fi
    TIME=$(vid_length "$WORK_DIR/dummy.m2v")
    BGAUDIO_CMD=(ffmpeg -f s16le -i /dev/zero -t $TIME \
    $AUDIO_OPTS -y "$WORK_DIR/dummy.$AUDIO_EXT")
    if "${BGAUDIO_CMD[@]}" >> "$LOG_FILE.tmp" 2>&1; then #run command
        cleanlog 3
    else
        cleanlog 3
        runtime_error
    fi

    MPLEX_CMD=(mplex -V -f $MPLEX_FORMAT -o  "$BASEDIR/dummy.mpg" \
     "$WORK_DIR/dummy.$AUDIO_EXT"  "$WORK_DIR/dummy.m2v")
    echo "Running: "${MPLEX_CMD[@]}"" >> "$LOG_FILE.tmp"
    cleanlog 1
    if "${MPLEX_CMD[@]}" >> "$LOG_FILE.tmp" 2>&1; then
        cleanlog 1
    else
        cleanlog 1
        runtime_error
    fi
#    $VMGM_ONLY && $SKIP_VMGM && mv "$BASEDIR/dummy.mpg" "$BASEDIR/VMGM.mpg"
fi

# do submenu 1st for debug purposes
if $SUB_MENU; then
    yecho
    yecho "Building submenus"
    yecho
    yecho "Creating images for each chapter"
    if [ -z "$SM_TITLES" ]; then
        if $MULTILINE_TITLE; then
            for i in ${!TITLES[@]}; do
                SM_TITLES[i]="${TITLES[i]//\\n/ }"
            done
        else
            SM_TITLES=("${TITLES[@]}")
        fi
    fi
    for ((i=0; i<${#IN_FILES[@]}; i++)); do
        C=$((${CHAPTERS[i]} - 1))
        yecho "Creating a transparent title PNG"
        convert -size 620x300 xc:none -font "$MENU_FONT" \
        -pointsize $MENU_FONTSIZE \
        -fill "$SM_TITLE_COLOUR" -draw "gravity center text 2,2 \"${SM_TITLES[i]}\"" \
        -stroke "$SUBMENU_STROKE" -strokewidth 1 \
        -fill "$SM_TITLE_COLOUR" -stroke "$SUBMENU_STROKE" \
        -draw "gravity center text 1,1 \"${SM_TITLES[i]}\"" miff:- | \
        convert -trim +repage - -blur 0x0.4 $WORK_DIR/title${i}_txt.png 2>/dev/null

        # which is harmless as they get removed, but needs to be tweaked
        if $ANI_SUB_MENU; then
            JPEG2YUV_OPTS=(-n $ANI_SUBMENU_FRAMES)
            PICS_IN=($WORK_DIR/animenu/%0d.$SM_IMG_FMT)
            PICS_OUT=($WORK_DIR/animenu/)
            CUT_TIME=340
            JPEG_DIR="$WORK_DIR/animenu"
            SLEEP=1
            TOTAL_JPEGS=$((340 * ${CHAPTERS[i]}))

        else  # not animated submenu
            if [[ -n "$SUBMENU_AUDIOLENGTH" ]]; then
                SM_LOOPS=$( bc <<< "$SUBMENU_AUDIOLENGTH * $FRAME_RATE")
                SM_LOOPS=${SM_LOOPS%.*}
            else
                SM_LOOPS=60
            fi
            JPEG2YUV_OPTS=(-n 1 -l $SM_LOOPS)
            PICS_IN=($WORK_DIR/${i}-submenu.$SM_IMG_FMT)
            PICS_OUT=($WORK_DIR/submenu/)
            CUT_TIME=1
            JPEG_DIR="$WORK_DIR/submenu"
            SLEEP=.5
            TOTAL_JPEGS=${CHAPTERS[i]}
            PREFIX=${i}-
        fi
        counts=$(awk_math ${CHAPT_INTERVALS[i]} times $FRAME_RATE)
        CUT=( 30 $(running_total <<<  $(for ((a=0; a<${CHAPTERS[i]} ; a++)); \
        do echo -n "$counts ";done)) )
        for ((c=0; c<${#CUT[@]}; c++)); do
            cmd[c]=${CUT[c]}-$(( ${CUT[c]} + CUT_TIME))
        done
        key=$((${#cmd[@]} - 1))
        unset cmd[key]
        # create a nav_seek log with tcdemux if not already present
        NAVSEEK_CMD=(nice tcdemux  $TCDEMUX_MODE -f $FRAME_RATE -W -i "${IN_FILES[i]}")
        if [ ! -e "${IN_FILES[i]}".nav_log ]; then
            yecho "Running "${NAVSEEK_CMD[@]}" > "${IN_FILES[i]}".nav_log"
            "${NAVSEEK_CMD[@]}"  2>> "$WORK_DIR/tc_pids" > "${IN_FILES[i]}".nav_log
        fi
        NAVSEEK[i]="--nav_seek "${IN_FILES[i]}".nav_log"
        yecho
        yecho "Creating $TOTAL_JPEGS chapter images for "${IN_FILES[i]}""
        yecho
        for t in "${cmd[@]}"; do
            echo "Running nice transcode --print_status 10 -q 1 -i "${IN_FILES[i]}" \
            ${NAVSEEK[i]} -o $WORK_DIR/submenu/ \
            -f $FRAME_RATE -Z ${GEO_ARRAY[C]},fast -c $t -y $SM_IMG_FMT,null" |
            sed 's/    */ /g'|sed -e "s/^ *//"|tee -a "$LOG_FILE"

            TCODE_CMD=(nice transcode --print_status 10 --write_pid $WORK_DIR/tcode$i.pid \
            -q 1 -i "${IN_FILES[i]}"   ${NAVSEEK[i]} -o "${PICS_OUT[@]}" \
            -f $FRAME_RATE -Z ${GEO_ARRAY[C]},fast -c $t -y $SM_IMG_FMT,null)
            function run_transcode()
            {
                "${TCODE_CMD[@]}" >> "$LOG_FILE"  2>&1
                sleep 1
            }
            run_transcode &
            sleep 2 # short sleep to allow 1st jpg to appear
            TCODE_PID=$(<$WORK_DIR/tcode$i.pid)
            check_stall &
            if [[ -n "$TCODE_PID" ]]; then
                while ps -p $TCODE_PID >/dev/null; do
                    sleep $SLEEP # spinner interval
                spin "Seeking in video and creating images: $(find "$JPEG_DIR" \
            -maxdepth 1 -name \*.jpg|sort|awk -F / '{ field = $NF }; END{ print field }')"
                done
                echo

                echo "Created $(find "$JPEG_DIR" -maxdepth 1 -name \*.jpg|wc -l) JPEGS of $TOTAL_JPEGS"
                #cleanlog 1
            else
                #cleanlog 1
                runtime_error "Problem creating images from the video."
                exit 1
            fi
            unset TCODE_CMD cmd run_transcode
            if ! $ANI_SUB_MENU ; then
                echo
                mv $WORK_DIR/submenu/000000.$SM_IMG_FMT \
                $WORK_DIR/submenu/$(printf "%08d%s\n" ${t%-*} .$SM_IMG_FMT)
            elif $ANI_SUB_MENU; then
                echo "renaming images by frame number"
                echo
                u=${t/*-}; v=${t/-*}
                for ((n=0; n<340; n++)); do
                    if [ $v -eq 30 ]; then
                        mv  $WORK_DIR/animenu/$(printf "%06d%s\n" $n .jpg) \
                        $WORK_DIR/animenu/$(printf "%08d%s\n" $((n+30)) .jpg)
                    else
                        mv  $WORK_DIR/animenu/$(printf "%06d%s\n" $n .jpg) \
                        $WORK_DIR/animenu/$(printf "%08d%s\n" $((n+v)) .jpg)
                    fi
                done
            fi
        done
            if $ANI_SUB_MENU ; then
                # move 340 images to each subdir:  $WORK_DIR/animenu/{0,1,2,3,etc}
                echo "moving images into subdirectories"
                for ((a=0; a<${CHAPTERS[i]}; a++)); do
                    # 2>/dev/null to work around perplexing spawned xterm bug
                    pics=( $(find $WORK_DIR/animenu/ -maxdepth 1 -name 00\*.$SM_IMG_FMT | sort 2>/dev/null|head -n 340 2>/dev/null) )
                    echo "${pics[@]}" >> "$WORK_DIR/pics.log"
                    for f in ${pics[@]}; do
                        mv "$f" $WORK_DIR/animenu/$a
                    done
                    unset pics
                done
                for ((a=0; a<${CHAPTERS[i]}; a++)); do
                    find $WORK_DIR/animenu/$a/ -name 00\*.$SM_IMG_FMT |
                    sort| head -n 20|xargs rm -f
                    find $WORK_DIR/animenu/$a/ -name 00\*.$SM_IMG_FMT |
                    sort|tail -n 20|xargs rm -f
                done
                # clean up left over pics in animenu/ dir
#                rm -f $WORK_DIR/animenu/*.$SM_IMG_FMT
            fi

        if $ANI_SUB_MENU; then
            echo
            echo "Making 300 montage images for "${IN_FILES[i]}""

            for ((a=1; a<300; a++)); do
                spin "\rProcessing "$a.$SM_IMG_FMT"  "
                for ((b=0; b<${CHAPTERS[i]}; b++)); do
                    IMGS=( "${IMGS[@]}" $(find $WORK_DIR/animenu/$b \
                    -name \*.$SM_IMG_FMT| sort 2>/dev/null | head -n $a | sed -n -e "$a p") )
                done
                IM_CMD=(montage ${IMGS[@]} -tile ${TILE_ARRAY[C]} \
                -geometry ${GEO_ARRAY[C]}+5+5 -bordercolor '#161514' \
                -mattecolor '#161514' -background '#161514' miff:-)
                IM_CMD2=(convert $WORK_DIR/submenu_template.jpg \
                $WORK_DIR/title${i}_txt.png  -gravity south \
                -geometry +0+55 -composite -  -gravity north -geometry +0+45 \
                -composite $WORK_DIR/animenu/$a.$SM_IMG_FMT)
                "${IM_CMD[@]}" | "${IM_CMD2[@]}"
                unset IMGS
            done

            unset IM_CMD IM_CMD2 d f PIC

        else # not $ANI_SUB_MENU

            yecho
            yecho "Making montage images for "${IN_FILES[i]}""
            # just use $CHAPTERS number of images
            imgs=( $(find $WORK_DIR/submenu -name \*.$SM_IMG_FMT |
            sort| head -n ${CHAPTERS[i]}) )
            # create frames for the chapter thumbs
            for PIC in "${imgs[@]}"; do
            spin "\rProcessing $(awk -F / '{ print $NF }' <<< "$PIC")  "
                convert -background '#141614' -frame 3x3 \
                -bordercolor none -mattecolor "#444744" "$PIC" miff:- |
                convert -resize "${GEO_ARRAY[C]}"! - "$PIC"
            done

            IM_CMD=(montage "${imgs[@]}" -tile ${TILE_ARRAY[C]} -geometry \
            ${GEO_ARRAY[C]}+5+5 -background '#141614' miff:-)
            IM_CMD2=(convert $WORK_DIR/submenu_template.jpg \
            $WORK_DIR/title${i}_txt.png  -gravity south -geometry +0+55 \
            -composite - -gravity north -geometry +0+45 -composite \
            $WORK_DIR/${i}-submenu.$SM_IMG_FMT)
            "${IM_CMD[@]}" | "${IM_CMD2[@]}"
        fi

        yecho
        yecho "Converting chapter montages of "${IN_FILES[i]}" to m2v video format"
        IMG_STREAM_CMD1=(jpeg2yuv -v 0 -f $FRAME_RATE -I p \
        "${JPEG2YUV_OPTS[@]}" -L 1 -b 1  -j "${PICS_IN[@]}")
        ENC_CMD1=(ffmpeg   -f yuv4mpegpipe -i - -r $FRAME_RATE -s $VIDSIZE \
        -tvstd $TV_STANDARD $FFMPEG_OPTS -y "$WORK_DIR/menu$i.m2v")
        echo "Running "${IMG_STREAM_CMD1[@]}" | "${ENC_CMD1[@]}""|format_output | tee -a "$LOG_FILE" 2>&1
        if "${IMG_STREAM_CMD1[@]}" | "${ENC_CMD1[@]}" >> "$LOG_FILE.tmp" 2>&1; then
            cleanlog 3
        else
            cleanlog 3
            runtime_error
        fi

        # check if m2v was created ok before proceeding
        if mencoder -quiet -oac pcm -ovc copy -frames 0 \
        "$WORK_DIR/menu$i.m2v" -o /dev/null &>/dev/null; then
            :
        else
            echo
            runtime_error  \
            "The submenu video (m2v) does not appear to have been created"
        fi
        # clean out submenu dirs of images
        echo "Cleaning up leftover pics in $REAL_WORK_DIR/animenu"
        rm -fv $WORK_DIR/submenu/*
        find $WORK_DIR/animenu/ -maxdepth 1 -type f -exec rm -f {} \;
        if $ANI_SUB_MENU; then
            find $WORK_DIR/animenu/[0-9]/ -type f -exec rm -f {} \;
        fi
    done
    unset IMG_STREAM_CMD1 ENC_CMD1 JPEG2YUV_OPTS
    for ((s=0; s<=NUM_FILES; s++)); do
        # create audio background for either animated or plain submenus
        yecho
        yecho "Creating an audio background"
        yecho "Working on submenu audio for "${IN_FILES[s]}""
        if $SUBMENU_AUDIO; then # user supplied audio file for ths video
            if ! $ANI_SUB_MENU ; then  # if static, see if length option given
                [[ -n "$SUBMENU_AUDIOLENGTH" ]] && TIME=$SUBMENU_AUDIOLENGTH
                if [[ -n "$SM_AUDIO_FILE" ]]; then # one audio file for all menus
                    TIME_TMP=$(ffmpeg -i "$SM_AUDIO_FILE" 2>&1|
                    awk '/Duration/ {print $2}')
                    TIME_TMP=${TIME_TMP/,/}
                else # audio will be different for each menu
                    TIME_TMP=$(ffmpeg -i "${SM_AUDIO[s]}" 2>&1|
                    awk '/Duration/ {print $2}')
                    TIME_TMP=${TIME_TMP/,/}
                fi
            else # if animated, get time from video instead of the audio file
                TIME_TMP=$(vid_length "$WORK_DIR/menu$s.m2v")
            fi
            # if length option is supplied, we use that, else use $TIME_TMP
            TIME=${TIME:-$TIME_TMP}
            # silence only need be the length of the static menu
            if [ "${SM_AUDIO[s]}" = "none" ]; then # user asked for silence
                TIME=$(vid_length "$WORK_DIR/menu$s.m2v")
                BGAUDIO_CMD=(ffmpeg -f s16le -i /dev/zero -t $TIME \
                $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT)
            elif [[ -n "$SM_AUDIO_FILE" ]]; then # user supplied "1" audio file
                COPY_AC3=(cp -v $WORK_DIR/submenu.$AUDIO_EXT \
                $WORK_DIR/menu$s.$AUDIO_EXT)
                BGAUDIO_CMD=(ffmpeg -i "$SM_AUDIO_FILE" -t $TIME -ar 48000 \
                -ac 2 -acodec pcm_s16le -y $WORK_DIR/submenu.wav)
            else # SM_AUDIO[s] is an audio file we will process it
                # make seperate wavs for each supplied audio bg for each submenu
                BGAUDIO_CMD=(ffmpeg -i "${SM_AUDIO[s]}" -t $TIME -ar 48000 \
                -ac 2 -acodec pcm_s16le -y $WORK_DIR/menu$s.wav)
                BGAUDIO_CMD2=(ffmpeg -i $WORK_DIR/menu$s.wav \
                $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT)
            fi
        else # no supplied audio for submenu so create silence
            TIME=$(vid_length "$WORK_DIR/menu$s.m2v")
            BGAUDIO_CMD=(ffmpeg -f s16le -i /dev/zero -t $TIME \
            $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT)
        fi
        if [ ! -e $WORK_DIR/submenu.wav ]; then # only run if no wav
            yecho "Running "${BGAUDIO_CMD[@]}"" >> "$LOG_FILE.tmp" 2>&1
            cleanlog 1
            if "${BGAUDIO_CMD[@]}" >> "$LOG_FILE.tmp" 2>&1; then #run command
                cleanlog 3
            else
                cleanlog 3
                runtime_error
            fi
        fi
        # convert to DVD/SVCD format as long as not "none" or single audio file
        if $SUBMENU_AUDIO && [[ ! "${SM_AUDIO[s]}" = "none" && -z "$SM_AUDIO_FILE" ]]; then
            if $SM_AUDIO_FADE; then
                TIME=$(ffmpeg -i "$WORK_DIR/menu$s.wav" 2>&1|awk '/Duration/ {print $2}')
                TIME=${TIME/,/}
                echo -e "Running:
                sox $WORK_DIR/menu$s.wav \
                $WORK_DIR/menu$s-processed.wav fade t $SM_FADE $TIME $SM_FADE" |
                sed 's/    */ /g'|sed -e "s/^ *//"
                sox -q $WORK_DIR/menu$s.wav \
                $WORK_DIR/menu$s-processed.wav fade t $FADE $TIME $FADE
                rm $WORK_DIR/menu$s.wav
                mv $WORK_DIR/menu$s-processed.wav $WORK_DIR/menu$s.wav
            fi
            echo "Running "${BGAUDIO_CMD2[@]}"" >> "$LOG_FILE.tmp" 2>&1
            cleanlog 1
            if "${BGAUDIO_CMD2[@]}" >> "$LOG_FILE.tmp" 2>&1; then
                cleanlog 3
            else
                cleanlog 3
                runtime_error
            fi
            unset TIME
        fi
        # if "1" audio file, then convert it if it has not been done yet
        if [[ -n "$SM_AUDIO_FILE" && ! -e $WORK_DIR/submenu-processed.wav ]]; then
            if $AUDIO_FADE; then
                TIME=$(ffmpeg -i "$WORK_DIR/submenu.wav" 2>&1|awk '/Duration/ {print $2}')
                TIME=${TIME/,/}
                echo -e "Running:
                sox $WORK_DIR/submenu.wav \
                $WORK_DIR/submenu-processed.wav fade t $SM_FADE $TIME $SM_FADE" |sed 's/    */ /g'

                sox -q $WORK_DIR/submenu.wav \
                $WORK_DIR/submenu-processed.wav fade t $FADE $TIME $FADE
                rm -f $WORK_DIR/submenu.wav
                cp  $WORK_DIR/submenu-processed.wav $WORK_DIR/submenu.wav
            fi
            BGAUDIO_CMD3=(ffmpeg -i $WORK_DIR/submenu.wav \
            $AUDIO_OPTS -y $WORK_DIR/submenu.$AUDIO_EXT)
            if [ -e $WORK_DIR/submenu.$AUDIO_EXT ]; then # if file exists do nothing
                :
            else
                echo "Running "${BGAUDIO_CMD3[@]}"" >> "$LOG_FILE.tmp" 2>&1
                if "${BGAUDIO_CMD3[@]}" >> "$LOG_FILE.tmp" 2>&1; then
                    cleanlog 3
                else
                    cleanlog 3
                    runtime_error
                fi
            fi
        fi
        # copy the final file for each submenu if only 1 supplied
        "${COPY_AC3[@]}"
        yecho
        yecho "Multiplexing video and audio together"
        S=$((s + 1))
        MPLEX_CMD=(mplex -V -f $MPLEX_FORMAT -o $WORK_DIR/menu$S.mpg \
        $WORK_DIR/menu$s.$AUDIO_EXT $WORK_DIR/menu$s.m2v)
        echo "Running: "${MPLEX_CMD[@]}"" >> "$LOG_FILE.tmp"
        cleanlog 1
        if "${MPLEX_CMD[@]}" >> "$LOG_FILE.tmp" 2>&1; then
            cleanlog 1
        else
            cleanlog 1
            runtime_error
        fi
        # remove wav to save space
        rm -fv $WORK_DIR/menu$s.wav
    done
    rm -fv $WORK_DIR/submenu.{wav,$AUDIO_EXT}
    rm -fr $WORK_DIR/animenu/*
fi

##############################################################################
#                      Work on main menu                                     #
##############################################################################
yecho
yecho "Building main menu"
if [[ -n "$BG_VIDEO" ]]; then
    yecho "Getting background video from $BG_VIDEO"
    FFMPEG_CMD="ffmpeg -i \"$BG_VIDEO\" -ss $BG_SEEK -vframes $FRAMES $BG_ASYNC \
    -s $VIDSIZE -sameq \"$WORK_DIR/bg/%d.jpg\""
    yecho "Extracting/resizing background images with the following command:"
    yecho "$FFMPEG_CMD"
    # Filter ffmpeg output
    LOG_FILTER="sed s/\\r/\\r\\n/g"
    # Run command and check for failure
    if ! cmd_exec "$FFMPEG_CMD"; then
        runtime_error "Problem creating images from the background video"
    fi
    # make sure there are enough pics to make a bg video
    IMAGES=( "${IMAGES[@]}" \
    $(find $WORK_DIR/bg -maxdepth 1 -name \*[1-9]\*.jpg|sort) )
    last_pic=${#IMAGES[@]}
    next_pic=$(($last_pic + 1))
    if [ $last_pic -lt $MAX_ANI_LENGTH ]; then
        for ((l=next_pic; l<=MAX_ANI_LENGTH; l++)); do
            cp $WORK_DIR/bg/${last_pic}.jpg $WORK_DIR/bg/$l.jpg
        done
    fi
    unset IMAGES PICS last_pic next_pic
fi
#if [ -n "$SHOWCASE_VIDEO" ] && ! $NO_SC_THUMB; then
if [[ -n "$SHOWCASE_VIDEO" ]] && ! $NO_SC_THUMB; then
    echo "Getting showcase video images from $SHOWCASE_VIDEO"
    if [ "$SC_FRAMESTYLE" = "glass" ]; then
        FIND_FRAMES=$((FRAMES + 1)) # unfortunately mplayer starts at 1 not 0
        D=2
        FRAME_SIZE=$SHOWCASE_SIZE
        VOUT="png:z=7"
        MPLAYER_SEEK_VAL=$SHOWCASE_SEEK_VAL
        get_framed_pics "$SHOWCASE_VIDEO"  >> "$LOG_FILE" 2>&1
        for ((i=1; i<=$FIND_FRAMES; i++)); do
            mv  "$WORK_DIR"/$(printf "%08d%s"  $i .png) \
            "$WORK_DIR"/showcase/$(printf "%06d%s"  $i .png) 2>/dev/null
        done
    elif [ "$SC_FRAMESTYLE" = "none" ]; then
        FIND_FRAMES=$FRAMES # ffmpeg starts at 0
        FFMPEG_CMD=(ffmpeg -i "$SHOWCASE_VIDEO" -ss $SHOWCASE_SEEK_VAL $BG_ASYNC \
        -s $SHOWCASE_SIZE -vframes $FRAMES -an -y "$WORK_DIR/showcase/%06d.png")
        echo -e "\nRunning: "${FFMPEG_CMD[@]}"\n" | fold -bs >> "$LOG_FILE"
        SED_VAR="frame="
        if "${FFMPEG_CMD[@]}" >> "$LOG_FILE.tmp" 2>&1;then
            cleanlog 3
        else
            cleanlog 3
            runtime_error "Problem creating images from the video."
            exit 1
        fi
    fi

    for ((i=0; i<$FRAMES; i++)); do
        SC_PICS=( ${SC_PICS[@]} $(find $WORK_DIR/showcase -maxdepth 1  -name $(printf "%06d%s"  $i .png) ) )
    done
    if [[ "$SC_FRAMESTYLE" = "glass" ]] &&  [[ -z "$ROTATE" && -z "$WAVE" ]]; then
        :
    else
        for pic in "${SC_PICS[@]}"; do
            spin "\rProcessing $(awk -F / '{ print $NF }' <<< "$pic") of $FRAMES  "
            SC_CMD=(convert -resize $SHOWCASE_SIZE! "$pic" -mattecolor gray $SC_FRAME)
            SC_CMD1=(convert "$pic" -background none $ROTATE $WAVE)
            SC_CMD2=(convert -background none $ROTATE $WAVE -)
            SC_CMD3=(convert - -resize $SHOWCASE_SIZE! "$pic")
            # if glass and either wave or rotate
            if [ "$SC_FRAMESTYLE" = "glass" ] && [[ -n "$WAVE" || -n "$ROTATE" ]]; then
                "${SC_CMD1[@]}" miff:- | "${SC_CMD3[@]}"
            # if glass and neither wave or rotate
            elif [ "$SC_FRAMESTYLE" = "glass" ] && [[ -z "$WAVE" && -z "$ROTATE" ]]; then
                :
            else # not glass
                "${SC_CMD[@]}" miff:- | "${SC_CMD2[@]}" miff:- | "${SC_CMD3[@]}"
            fi
        done
    fi
    # make sure showcase video finishes at the time time as other menu items
    IMAGES=( $(find $WORK_DIR/showcase -maxdepth 1 -name 00\*.png|sort) )
    last_pic=$(( ${#IMAGES[@]} - 1 ))
    next_pic=$(($last_pic + 1))
    if [ $last_pic -lt $MAX_ANI_LENGTH ] && ! $STATIC; then
        for ((l=next_pic; l<=MAX_ANI_LENGTH; l++)); do
            cp $WORK_DIR/showcase/$( printf %06d $last_pic).png \
            $WORK_DIR/showcase/$(printf %06d $l).png
        done
    fi

fi
unset IMAGES last_pic next_pic FFMPEG_CMD pic

yecho
if [[ ! "$SC_FRAMESTYLE" = "glass" && ! $TEXTMENU ]]; then
    if $SHOWCASE; then
        yecho "Processing video images"
    else
        yecho "Adding title to video images and resizing"
    fi
fi
if ! $TEXTMENU; then
    for ((i=0; i<=NUM_FILES; i++)); do
        if $FEATHER && $THUMBS_3D && [ "$THUMB_SHAPE" != "normal" ]; then
            unset CURVE_ARRAY CURVE_VALUES CURVE_VARS
            CURVE_VARS="5 3 5 1 1"
            . todisc-fade-routine "3 5 5 1 1"
        fi
        PICS=( "${PICS[@]}" \
        $(find $WORK_DIR/pics/$i -maxdepth 1 -name \*[0-9]\*.$IMG_FMT|sort) )
        echo
        yecho "Working on ${#PICS[@]} images from ${IN_FILES[i]}"
        for ((p=0; p<${#PICS[@]}; p++)); do
            unset IM_CMD6
            [[ -n ${ROTATE_ARRAY[@]} ]] && THUMB_ROTATE="-background none -rotate ${ROTATE_ARRAY[i]}"
            IM_CMD=(composite -compose CopyOpacity $THUMB_MASK +matte "${PICS[p]}")
            IM_CMD0=(montage -  -geometry +4+4 -compose Copy -background none \
            -fill "$THUMB_TEXT_COLOUR" -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE -title "${TITLES[i]}")
            IM_CMD01=(convert -background '#161514' -frame 3x3 \
            -bordercolor none -mattecolor "#444744" "${PICS[p]}")
            IM_CMD02=(convert "${PICS[p]}" $RAISE)
            IM_CMD03=(composite -compose CopyOpacity $THUMB_MASK +matte -)
            IM_CMD04=(montage - -geometry +4+4 -background '#444744' \
            -mattecolor "#444744" -fill "$THUMB_TEXT_COLOUR" -font "$THUMB_FONT" \
            -pointsize $THUMB_FONTSIZE -title "${TITLES[i]}")
            IM_CMD1=(convert -resize $THUMB_SIZE! -)
            IM_CMD2=(composite -gravity center -compose DstOver $WORK_DIR/feather_mask2.png -)
            IM_CMD3=(montage -geometry +4+4 -background '#444744' \
            -fill "$THUMB_TEXT_COLOUR" -font "$THUMB_FONT" \
            -pointsize $THUMB_FONTSIZE -title "${TITLES[i]}" "${PICS[p]}")
            IM_CMD4=(convert -background none -frame 3x3 \
            -bordercolor "#444744" -)
            IM_CMD4b=(convert -background none -frame 3x3 \
            -bordercolor none -)
            IM_CMD5=(convert - $THUMB_ROTATE -resize $THUMB_SIZE! "${PICS[p]}")
            IM_CMD6=(convert - -write mpr:img${p} -fx A  +matte \
            -blur 0x$( printf "%.2f" $(awk_math 7 plus .${CURVE_ARRAY[p]/.} float) )  \
            -shade $(awk_math 115 plus ${CURVE_ARRAY[p]} float)x30 -normalize mpr:img${p} \
            -compose Overlay -composite mpr:img${p} -matte -compose Dst_In -composite)
            IM_CMD7=(convert -trim +repage - )
            if $FEATHER &&  [ "$THUMB_SHAPE" != "normal" ] && $THUMBS_3D; then
                CURVE_UPDATE="with -blur 0x$( printf  "%.2f" $(awk_math 7 plus .${CURVE_ARRAY[p]/.} float) ) \
                -shade $( printf "%.2f" $(awk_math 115 plus ${CURVE_ARRAY[p]} float) )x30"
            fi
            if $FEATHER; then
                spin "\rProcessing $(awk -F / '{ print $NF }' <<< "${PICS[p]}") \
                $(echo $CURVE_UPDATE | format_output) "
                if $SHOWCASE; then
                    if $THUMBS_3D; then
                        if [ "$THUMB_SHAPE" != "normal" ]; then # normal has $RAISE
                            "${IM_CMD[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
                            "${IM_CMD6[@]}" miff:- |  "${IM_CMD7[@]}" miff:- |
                            "${IM_CMD5[@]}"
                        else # normal thumbshape, with feather and 3D
                            "${IM_CMD02[@]}" miff:- | "${IM_CMD03[@]}" miff:- |
                            "${IM_CMD2[@]}" miff:- |"${IM_CMD7[@]}" miff:- |
                            "${IM_CMD5[@]}"

                        fi
                    else
                        "${IM_CMD[@]}" miff:- | "${IM_CMD2[@]}" miff:- |"${IM_CMD5[@]}"
                    fi
                else # not SHOWCASE
                    if $THUMBS_3D; then
                        if [ "$THUMB_SHAPE" != "normal" ]; then
                            "${IM_CMD[@]}" miff:- | "${IM_CMD6[@]}" miff:- |
                            "${IM_CMD1[@]}" miff:- |"${IM_CMD0[@]}" miff:- |
                            "${IM_CMD1[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
                            "${IM_CMD5[@]}"
                        else
                            "${IM_CMD02[@]}" miff:- | "${IM_CMD0[@]}" miff:- |
                            "${IM_CMD1[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
                            "${IM_CMD5[@]}"
                        fi
                    else # not 3D
                        "${IM_CMD[@]}" miff:- | "${IM_CMD0[@]}" miff:- |
                        "${IM_CMD1[@]}" miff:- |"${IM_CMD2[@]}" miff:- |
                        "${IM_CMD5[@]}"
                    fi
                fi
            else # not FEATHER
                if $SHOWCASE; then # showcase but not feather
                    if [[ "$SC_FRAMESTYLE" = "glass" && -z ${ROTATE_ARRAY[@]} ]]; then
                        :
                    else
                        spin "\rProcessing $(awk -F / '{ print $NF }' <<< "${PICS[p]}")  "
                        if $THUMBS_3D; then
                            "${IM_CMD02[@]}" miff:- | "${IM_CMD5[@]}"
                        else
                            "${IM_CMD01[@]}" miff:- | "${IM_CMD5[@]}"
                        fi
                    fi
                else # not showcase or feather
                    spin "\rProcessing $(awk -F / '{ print $NF }' <<< "${PICS[p]}")  "
                    if $THUMBS_3D; then
                        "${IM_CMD02[@]}" miff:- |"${IM_CMD04[@]}" miff:- |
                        "${IM_CMD4b[@]}" miff:- | "${IM_CMD5[@]}"
                    else
                        "${IM_CMD3[@]}" miff:- | "${IM_CMD4[@]}" miff:- |
                        "${IM_CMD5[@]}"
                    fi
                fi
            fi
            if $STATIC; then unset PICS; fi
            unset IM_CMD0 IM_CMD1 IM_CMD2 IM_CMD3 IM_CMD4 IM_CMD5 IM_CMD6
        done
        # make sure all animated thumbs finish at the same time
        if ! $STATIC; then
            IMAGES=( "${IMAGES[@]}" \
            $(find $WORK_DIR/pics/$i -maxdepth 1 -name 00\*.$IMG_FMT|sort) )
            last_pic=$(( ${#IMAGES[@]} - 1 ))
            next_pic=$(($last_pic + 1))
            if [ $last_pic -lt $MAX_ANI_LENGTH ]; then
                for ((l=next_pic; l<=MAX_ANI_LENGTH; l++)); do
                    cp $WORK_DIR/pics/$i/$( printf %06d $last_pic).$IMG_FMT \
                    $WORK_DIR/pics/$i/$(printf %06d $l).$IMG_FMT
                done
            fi
            unset IMAGES last_pic next_pic
        fi
        unset PICS
    done
fi
if ! $MENU_FADE; then
    yecho
    yecho "Making $FRAMES final montages and compositing onto background with title"
    yecho
fi
if $MENU_FADE && ! $STATIC; then
    . todisc-fade-routine
    yecho
    yecho "Creating background fade"
    yecho
    if [ -z "$BG_VIDEO" ]; then
        for ((frame=0; frame<=ANI_MENU_END_FRAME; frame++)); do
            # copy template for fade out beginning and end frames
            cp $WORK_DIR/pics/template.jpg $WORK_DIR/bg/$(($frame + 1)).jpg
        done
    fi
    for ((frame=0; frame<=BACKGROUND_FADE_IN_END_FRAME; frame++)); do
        D=`get_bg_opacity`
        composite -dissolve $D $WORK_DIR/bg/$(($frame + 1)).jpg $WORK_DIR/black.jpg \
        $WORK_DIR/bg/$(($frame + 1)).jpg
    done
    yecho
    yecho "Making $FRAMES final montages and compositing onto background with title"
    yecho
    for ((frame=BACKGROUND_FADE_OUT_START_FRAME; frame<BACKGROUND_FADE_OUT_END_FRAME; frame++)); do
        D=`get_bg_opacity`
        composite -dissolve $D $WORK_DIR/bg/$(($frame + 1)).jpg $WORK_DIR/black.jpg \
        $WORK_DIR/bg/$(($frame + 1)).jpg
    done
    for ((frame=0; frame<ANI_MENU_END_FRAME; frame++)); do
        # set dissolve vars from todisc-fade-routine functions
        BC=$(get_title_opacity)
        B=$(awk -F ':' '{print $1'}<<<$BC)
        C=$(awk -F ':' '{print $2'}<<<$BC)
        S=$(get_thumb_opacity)

        spin  "\rProcessing "$(($frame + 1)).jpg"  "

        for ((cnt=0; cnt<=NUM_FILES; cnt++)); do
            ANI_PICS=( "${ANI_PICS[@]}" $(find $WORK_DIR/pics/$cnt  -name $(printf "%06d%s"  $((frame + 1)) .$IMG_FMT) ) )
        done
        if $SHOWCASE; then
            if ! $TEXTMENU; then
                for ((i=0; i<${#ANI_PICS[@]}; i++)); do
                    sc_cmd=( ${sc_cmd[@]} ${SHOWCASE_THUMB_PAGES[i]} "${ANI_PICS[i]}")
                done
            fi
            if ! $NO_SC_THUMB; then
                SC_VIDEO_CMD="$SC_IMG_PAGE \
                "$WORK_DIR"/showcase/$(printf "%06d%s"  $(($frame + 1)) .png)"
            else
                unset SC_VIDEO_CMD
            fi
        fi
        $TEXTMENU && unset sc_cmd
        ! $TEXTMENU && MOSAIC="-mosaic"
        BG_PIC=$(find $WORK_DIR/bg -name $(($frame + 1)).jpg)
        # create the montage from the images in each video dir
        MONTAGE_CMD=(convert  -size $VIDSIZE -background none \
        ${sc_cmd[@]} $SC_IMG_CMD $MOSAIC)
        MONTAGE_CMD0=(convert  -size $VIDSIZE "$WORK_DIR/pics/template.png" \
        ${sc_cmd[@]} $SC_VIDEO_CMD $MOSAIC $WORK_DIR/animenu/$(($frame + 1)).jpg)
        MONTAGE_CMD01=(convert  -size $VIDSIZE xc:none -background none \
        ${sc_cmd[@]} $SC_VIDEO_CMD $MOSAIC)
        MONTAGE_CMD02=(convert -size $VIDSIZE -background none \
        - ${sc_thumb_title_cmd[@]} -mosaic)
        MONTAGE_CMD03=(convert -size $VIDSIZE -background none \
        ${sc_thumb_title_cmd[@]} -mosaic)
        MONTAGE_CMD1=(montage "${ANI_PICS[@]}" -tile ${TILE_ARRAY[NUM_FILES]} \
        -geometry ${GEO_ARRAY[NUM_FILES]}+10+4 -background none)
        #  dissolve the finished montages onto the background
        MONTAGE_CMD2=(composite -dissolve $S -gravity $BUTTON_GRAVITY \
        -geometry +${XGEO}+${YGEO} - $WORK_DIR/bg/$(($frame + 1)).jpg -background none)
        MONTAGE_CMD2b=(composite -size $VIDSIZE -background none \
        -gravity NorthWest  -dissolve $S - $WORK_DIR/bg/$(($frame + 1)).jpg \
        -background none  $WORK_DIR/animenu/$(($frame + 1)).jpg)
        MONTAGE_CMD2c=(composite -size $VIDSIZE -background none \
        -gravity NorthWest  -dissolve $S - $WORK_DIR/bg/$(($frame + 1)).jpg \
        -background none)
        # if MIST is called for, this dissolves the mist onto the background
        MONTAGE_CMD3=(composite -dissolve $B -gravity $TITLE_GRAVITY \
        -geometry ${mist_xoffset}${mist_yoffset} $WORK_DIR/white.png -)
        # finally, we dissolve the title onto the MIST (or plain background)
        MONTAGE_CMD4=(composite -dissolve $C -gravity $TITLE_GRAVITY -geometry \
        ${title_xoffset}${title_yoffset} $WORK_DIR/title_txt.png - \
        -background none $WORK_DIR/animenu/$(($frame + 1)).jpg)
        if $PLAYALL; then
            MONTAGE_CMD5=(composite -dissolve $S -gravity SouthEast -geometry +55+55 \
            $SE_BTN - -background none)
        else
            MONTAGE_CMD5=(convert -)
        fi
        $TEXTMENU && unset MONTAGE_CMD
        $TEXTMENU && MONTAGE_CMD=( "${MONTAGE_CMD03[@]}" )
        # pipe all of above commands if using MIST
        if $MIST; then
            if $SHOWCASE; then
                if [[ -n "$SHOWCASE_VIDEO" ]]; then
                    "${MONTAGE_CMD01[@]}" miff:- | "${MONTAGE_CMD02[@]}" miff:- |
                    "${MONTAGE_CMD2c[@]}" miff:- | "${MONTAGE_CMD3[@]}" miff:- |
                    "${MONTAGE_CMD5[@]}" miff:- | "${MONTAGE_CMD4[@]}"
                else # not SHOWCASE_VIDEO (SHOWCASE_IMG)
                    "${MONTAGE_CMD[@]}" miff:- | "${MONTAGE_CMD02[@]}" miff:- |
                    "${MONTAGE_CMD2c[@]}" miff:- |  "${MONTAGE_CMD5[@]}" miff:- |
                    "${MONTAGE_CMD3[@]}" miff:- | "${MONTAGE_CMD4[@]}"
                fi
            else # not SHOWCASE
                "${MONTAGE_CMD1[@]}" miff:- | "${MONTAGE_CMD2[@]}" miff:- |
                "${MONTAGE_CMD3[@]}" miff:- | "${MONTAGE_CMD5[@]}" miff:- |
                "${MONTAGE_CMD4[@]}"
            fi
        else  # no mist: pipe all commands but the mist command
            if $SHOWCASE; then
                if [[ -n "$SHOWCASE_VIDEO" ]]; then
                    "${MONTAGE_CMD01[@]}" miff:- | "${MONTAGE_CMD02[@]}" miff:- |
                    "${MONTAGE_CMD2c[@]}" miff:- | "${MONTAGE_CMD5[@]}" miff:- |
                    "${MONTAGE_CMD4[@]}"
                else
                    "${MONTAGE_CMD[@]}" miff:- | "${MONTAGE_CMD02[@]}" miff:- |
                    "${MONTAGE_CMD2c[@]}" miff:- |  "${MONTAGE_CMD5[@]}" miff:- |
                    "${MONTAGE_CMD4[@]}"
                fi
            else
                "${MONTAGE_CMD1[@]}" miff:- | "${MONTAGE_CMD2[@]}" miff:- |
                "${MONTAGE_CMD5[@]}" miff:- | "${MONTAGE_CMD4[@]}"
            fi
        fi
        unset ANI_PICS sc_cmd
    done
    # copy a few black frames to make sure end frame is really "black"
    for ((i=FRAMES; i<FRAMES+18; i++)); do
        cp $WORK_DIR/black.jpg $WORK_DIR/animenu/$i.jpg
    done
else # Do not do menu fade
    if $TRANSPARENT; then # non transparent -showcase-* uses this block too
        for (( count=1; count<=$FRAMES; count++)); do
            spin "\rProcessing "$count.jpg"  "
            for ((cnt=0; cnt<=NUM_FILES; cnt++)); do
                ANI_PICS=( "${ANI_PICS[@]}" $(find $WORK_DIR/pics/$cnt  \
                -name $(printf "%06d%s"  $((count - 1)) .$IMG_FMT) ) )
            done
            for ((f=0; f<${#ANI_PICS[@]}; f++)); do
                sc_cmd=( ${sc_cmd[@]} ${SHOWCASE_THUMB_PAGES[f]} "${ANI_PICS[f]}")
            done
            SC_VIDEO_CMD="$SC_IMG_PAGE \
            "$WORK_DIR"/showcase/$(printf "%06d%s"  $count .png)"
            $STATIC && SC_VIDEO_CMD="$SC_IMG_PAGE \
            "$WORK_DIR"/showcase_img.png"
            $TEXTMENU && unset sc_cmd

            IM_CMD0=(convert  -size $VIDSIZE "$WORK_DIR/pics/template.png" \
            ${sc_cmd[@]} $SC_IMG_CMD -mosaic)
            IM_CMD01=(convert  -size $VIDSIZE xc:none -background none \
            ${sc_cmd[@]} $SC_VIDEO_CMD -mosaic)
            # dissolve piped images onto bgimage
            IM_CMD02=(composite \
            -gravity NorthWest  -dissolve $OPACITY - $WORK_DIR/pics/template.png)
            # dissolve piped images onto bgvideo
            IM_CMD03=(composite -size $VIDSIZE -background none \
            -gravity NorthWest  -dissolve $OPACITY - $WORK_DIR/bg/$count.jpg \
            -background none)
            # dissolve titles onto bgvideo
            IM_CMD04=(convert -size $VIDSIZE -background none \
            - ${sc_thumb_title_cmd[@]} -mosaic)
            IM_CMD05=(convert  -size $VIDSIZE xc:none -background none \
            ${sc_cmd[@]} $SC_IMG_PAGE -mosaic)
            IM_CMD1=(montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[NUM_FILES]} \
            -geometry ${GEO_ARRAY[NUM_FILES]}+10+4 -background none miff:-)
            IM_CMD2=(composite -dissolve $OPACITY \
            -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} - \
            $WORK_DIR/pics/template.jpg -background none miff:-)
            IM_CMD2b=(composite -dissolve $OPACITY \
            -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} - \
            $WORK_DIR/bg/$count.jpg -background none miff:-)
            IM_CMD3=(composite -dissolve 30 -gravity $TITLE_GRAVITY \
            -geometry ${mist_xoffset}${mist_yoffset} $WORK_DIR/white.png - miff:-)
            IM_CMD4=(convert - $WORK_DIR/title_txt.png -gravity $TITLE_GRAVITY \
            -geometry ${title_xoffset}${title_yoffset} -composite $ADD_SE_BTN \
            $WORK_DIR/animenu/$count.jpg )
            if $MIST; then
                if $SHOWCASE && [[ -n "$SHOWCASE_VIDEO" ]]; then # showcase, mist, showcase-video
                    if test -n "$BG_VIDEO"; then # showcase, mist, showcase-video, bgvideo
                        "${IM_CMD01[@]}" miff:- | "${IM_CMD04[@]}" miff:- |
                       "${IM_CMD03[@]}" miff:- |  "${IM_CMD3[@]}" |  "${IM_CMD4[@]}"
                    else # showcase, mist showcase-video, not bgvideo
                        "${IM_CMD01[@]}" miff:- | "${IM_CMD02[@]}" "$WORK_DIR/animenu/$count.jpg"
                    fi
                elif $SHOWCASE && [[ -n "$SHOWCASE_IMG" ]]; then # showcase, mist, showcase-image
                    if test -n "$BG_VIDEO"; then # showcase, mist, showcase-image with bgvideo
                        "${IM_CMD05[@]}" miff:- | "${IM_CMD04[@]}" miff:- |
                        "${IM_CMD03[@]}" miff:- |"${IM_CMD3[@]}" |  "${IM_CMD4[@]}"
                    else # showcase, mist, showcase-image, not bgvideo
                        "${IM_CMD0[@]}" $WORK_DIR/animenu/$count.jpg
                    fi
                elif ! $SHOWCASE; then
                    if test -n "$BG_VIDEO"; then
                        "${IM_CMD1[@]}" | "${IM_CMD2b[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
                    else
                    "${IM_CMD1[@]}" | "${IM_CMD2[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
                    fi
                fi
            else # not mist
                if $SHOWCASE && [[ -n "$SHOWCASE_VIDEO" ]]; then # showcase, no mist, showcase-video
                    if test -n "$BG_VIDEO"; then # showcase, no mist, showcase-video, bgvideo
                        "${IM_CMD01[@]}" miff:- | "${IM_CMD04[@]}" miff:- |
                        "${IM_CMD03[@]}" miff:- | "${IM_CMD4[@]}"
                    else # showcase, no mist, showcase-video, not bgvideo
                        "${IM_CMD01[@]}" miff:- | "${IM_CMD04[@]}" miff:- |
                        "${IM_CMD02[@]}" miff:- | "${IM_CMD4[@]}"
                    fi
                elif $SHOWCASE && [[ -n "$SHOWCASE_IMG" ]]; then # showcase, no mist, showcase-image
                    if test -n "$BG_VIDEO"; then # showcase, no mist, showcase-image with bgvideo
                        "${IM_CMD05[@]}" miff:- | "${IM_CMD04[@]}" miff:- |
                        "${IM_CMD03[@]}" miff:- | "${IM_CMD4[@]}"
                    else # showcase, no mist, showcase-image, no bgvideo
                        "${IM_CMD0[@]}" $WORK_DIR/animenu/$count.jpg
                    fi
                elif ! $SHOWCASE; then
                    if test -n "$BG_VIDEO"; then
                        "${IM_CMD1[@]}" | "${IM_CMD2b[@]}" | "${IM_CMD4[@]}"
                    else
                        "${IM_CMD1[@]}" | "${IM_CMD2[@]}" | "${IM_CMD4[@]}"
                    fi
                fi
            fi
            rm -f ${ANI_PICS[@]}
            unset ANI_PICS sc_cmd
        done
    else # Not transparent (non transparent showcase uses transparent block ^^)
         C=$((${CHAPTERS[s]} - 1))
        for (( count=1; count <=FRAMES; count++)); do
            spin -ne "\rProcessing "$count.jpg"  "
            for ((cnt=0; cnt<=NUM_FILES; cnt++)); do
                ANI_PICS=( "${ANI_PICS[@]}" \
                $(find $WORK_DIR/pics/$cnt  -name $(printf "%06d%s"  $((count - 1))  .$IMG_FMT) ) )
            done
            # make final montages and composite onto grey background with title
            IM_CMD0=(montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[NUM_FILES]} \
            -geometry ${GEO_ARRAY[NUM_FILES]}+10+4 -background none miff:-)
            IM_CMD1=(convert $WORK_DIR/pics/template.jpg \
            -  -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} -composite miff:-)
            IM_CMD2=(convert $WORK_DIR/bg/$count.jpg \
            -  -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} -composite miff:-)
            IM_CMD3=(composite -dissolve 30 -gravity $TITLE_GRAVITY \
            -geometry ${mist_xoffset}${mist_yoffset} $WORK_DIR/white.png - miff:-)
            IM_CMD4=(convert - $WORK_DIR/title_txt.png  \
            -gravity $TITLE_GRAVITY -geometry ${title_xoffset}${title_yoffset} \
            -composite $ADD_SE_BTN $WORK_DIR/animenu/$count.jpg )

            if $STATIC; then
                if $MIST; then
                    "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
                else  # static and no MIST
                    echo "running "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD4[@]}""
                    "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD4[@]}" >> "$LOG_FILE"
                fi
            else # animated
                if test -n "$BG_VIDEO"; then
                    if $MIST; then
                        "${IM_CMD0[@]}" | "${IM_CMD2[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
                    else # no mist
                        "${IM_CMD0[@]}" | "${IM_CMD2[@]}" | "${IM_CMD4[@]}"
                    fi
                else # no bg video
                    if $MIST; then
                        "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
                    else # no mist
                        "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD4[@]}"
                    fi
                fi
            fi
            unset ANI_PICS
        done
    fi
fi
echo
echo "Converting images to video stream and encoding to DVD-compliant format"
# convert images to video stream and encode to dvd compliant m2v
if $STATIC; then
    if [[ -n "$MENU_AUDIOLENGTH" ]]; then
        LOOPS=$( bc <<< "$MENU_AUDIOLENGTH * $FRAME_RATE")
        LOOPS=${LOOPS%.*}
    else
        LOOPS=60
    fi
    JPEG2YUV_OPTS=(-n 1 -l $LOOPS)
    PICS_IN="$WORK_DIR/animenu/1.jpg"
else  # animated menu
    if $MENU_FADE; then
        JPEG2YUV_OPTS="-n $((ANI_MENU_END_FRAME + 18))"
    else
        JPEG2YUV_OPTS="-n $ANI_FRAMES"
    fi
    PICS_IN="$WORK_DIR/animenu/%d.jpg"
fi
ENC_CMD1=(jpeg2yuv -v 0 -f $FRAME_RATE -I p "${JPEG2YUV_OPTS[@]}" -L 1 -b1 \
-j "$PICS_IN")
ENC_CMD2=(ffmpeg   -f yuv4mpegpipe -i - -an -r $FRAME_RATE -s $VIDSIZE \
-tvstd $TV_STANDARD $FFMPEG_OPTS -y $WORK_DIR/intro.m2v)
yecho
echo "Running "${ENC_CMD1[@]}" | "${ENC_CMD2[@]}"" |format_output
if "${ENC_CMD1[@]}" | "${ENC_CMD2[@]}" >> "$LOG_FILE.tmp" 2>&1; then
    cleanlog 3
else
    cleanlog 3
    runtime_error
fi
echo
echo "Cleaning up montage images"
rm -fr $WORK_DIR/animenu/*.jpg
# check if m2v was created ok before proceeding
if mencoder -quiet -oac pcm -ovc copy -frames 0 $WORK_DIR/intro.m2v -o /dev/null &> /dev/null; then
    :
else
    echo
    runtime_error  "The menu video file does not appear to have been created"
fi
# if static then keep bg audio length (check later if -menu-audiolength opt used
if $STATIC && [[ -n "$BG_AUDIO" ]]; then
    TMP_TIME=$(ffmpeg -i "$BG_AUDIO" 2>&1|
    awk '/Duration/ {print $2}')
    TMP_TIME=$(awk_math ${TMP_TIME/,/} less $BG_AUDIO_SEEK float )
else
    MENU_ATIME=$(vid_length "$WORK_DIR/intro.m2v")
fi
if [[ -n "$MENU_AUDIOLENGTH" ]] && $STATIC; then MENU_ATIME=$MENU_AUDIOLENGTH; fi
MENU_ATIME=${MENU_ATIME:-$TMP_TIME}
BG_AUDIO_LENGTH="-t $MENU_ATIME"
# create audio background for the main menu
if [ -z "$BG_AUDIO" ]; then # no audio supplied: use silence
    cat /dev/zero 2>/dev/null | nice -n 0 sox -t raw -c 2 -r 48000 -w \
    -s - $WORK_DIR/intro.wav  trim 0 $MENU_ATIME
# Make sure file exists
elif test ! -e "$BG_AUDIO"; then
    runtime_error "Cannot find background audio file: $BG_AUDIO"
else # audio supplied: convert to wav then later to dvd/svcd format
    # TODO if ! $BG_AUDIOVIDEO_FILE; then  # check if same file and if so
    # decode the audio and jpegs in one step above, and skip this block
    BGAUDIO_CMD=(ffmpeg -i "$BG_AUDIO" -ar 48000 -ac 2 -acodec pcm_s16le -async 1 -y \
    -ss $BG_AUDIO_SEEK $BG_AUDIO_LENGTH $WORK_DIR/intro.wav)
    yecho
    echo "Running "${BGAUDIO_CMD[@]}"" >> "$LOG_FILE.tmp" 2>&1
    if "${BGAUDIO_CMD[@]}" >> "$LOG_FILE.tmp" 2>&1; then
        cleanlog 3
    else
        cleanlog 3
        runtime_error
    fi
    if $AUDIO_FADE; then  # bgaudio supplied and audio fade selected
        WAV_TIME=$(ffmpeg -i "$WORK_DIR/intro.wav" 2>&1|awk '/Duration/ {print $2}')
        WAV_TIME=${WAV_TIME/,/}
        echo "Running: "
        echo "sox $WORK_DIR/intro.wav $WORK_DIR/intro-processed.wav fade t \
        $FADE $WAV_TIME $FADE"
        sox $WORK_DIR/intro.wav \
        $WORK_DIR/intro-processed.wav fade t $FADE $WAV_TIME $FADE
        rm $WORK_DIR/intro.wav
        mv $WORK_DIR/intro-processed.wav $WORK_DIR/intro.wav
    fi
fi

unset BGAUDIO_CMD TIME

# convert to proper audio format
BGAUDIO_CMD=(ffmpeg -i $WORK_DIR/intro.wav \
$AUDIO_OPTS -y $WORK_DIR/intro.$AUDIO_EXT)
if "${BGAUDIO_CMD[@]}" >> "$LOG_FILE.tmp" 2>&1; then
    cleanlog 3
    else
    cleanlog 3
    runtime_error
fi
unset BGAUDIO_CMD
rm -fv "$WORK_DIR/intro.wav"
echo
echo "Multiplexing main menu audio and video together"
# mplex main menu audio and video together
INTRO_MPLEX_CMD="mplex -V -f $MPLEX_FORMAT -o $WORK_DIR/intro.mpg \
$WORK_DIR/intro.$AUDIO_EXT $WORK_DIR/intro.m2v"
echo -e "\nRunning: $INTRO_MPLEX_CMD\n" >> "$LOG_FILE.tmp"
cleanlog 1
yecho
if ${INTRO_MPLEX_CMD[@]} >> "$LOG_FILE.tmp" 2>&1; then
    cleanlog 1
else
    cleanlog 1
    runtime_error
fi

yecho
if $SWITCHED_MODE || $SWITCHED_MENUS; then
    yecho "Copying the menu mpeg"
    if [[ $MENU_NUM -ne 1 ]]; then
        cp -v "$REAL_WORK_DIR/intro.mpg" "$BASEDIR/${TSET_NUM}-${MENU_NUM}intro.mpg"
    else
        cp -v  "$REAL_WORK_DIR/intro.mpg"  "$REAL_WORK_DIR/${TSET_NUM}-${MENU_NUM}intro.mpg"
    fi
    sleep 2
    if $SWITCHED_MODE; then
        $KEEP_FILES && mv -v "$REAL_WORK_DIR" "$BASEDIR"/TITLESET${TSET_NUM}-MENU${MENU_NUM}
        ( KEEP_FILES=false && cleanup )
        exit
    fi
fi
function check_menufile()
{
    yecho
    if test -f "$MENU_FILE"; then
        echo "Menu file $MENU_FILE created"
        echo
    else
        runtime_error "Menu file $MENU_FILE not found.  Spumux seems to have had problems"
    fi
}
# FIXME no need for both the next 2 blocks running spumux
# "for intro in" should cover it if only one intro file for the TSET
if $SWITCHED_MENUS && [[ $TARGET != svcd ]]; then
    for ((i=1; i<=${#FILES[@]}; i++)); do
        MENU_FILE="$BASEDIR/animenu${TSET_NUM}-${i}.mpg"
        yecho "Running spumux "$SPUMUX_XML" < "$REAL_WORK_DIR/${TSET_NUM}-${i}intro.mpg" > "$MENU_FILE""
        spumux "$SPUMUX_XML" < "$WORK_DIR/${TSET_NUM}-${i}intro.mpg" > "$MENU_FILE" 2>> "$LOG_FILE"
        check_menufile
    done
fi
if [[ $TARGET != svcd ]] && ! $SWITCHED_MENUS && ! $SWITCHED_MODE; then
    yecho "Running spumux "$SPUMUX_XML" < $WORK_DIR/intro.mpg > "$MENU_FILE""
    spumux "$SPUMUX_XML" < $WORK_DIR/intro.mpg > "$MENU_FILE" 2>> "$LOG_FILE"
    check_menufile
fi
if $SUB_MENU; then
    echo "Creating submenus"
    for ((x=1; x<=V_TOTAL; x++)); do
        yecho "Running spumux "$WORK_DIR/submenu${x}_spumux.xml" < \
        $WORK_DIR/menu${x}.mpg > \
        $(sed 's/\(.*\)menu/\1Menu/' <<< $WORK_DIR/menu${x}.mpg)"|fold -bs
        spumux "$WORK_DIR/submenu${x}_spumux.xml" < \
        $WORK_DIR/menu${x}.mpg > \
        $(sed 's/\(.*\)menu/\1Menu/' <<< $BASEDIR/${TSET_NUM}-menu${x}.mpg) 2>> "$LOG_FILE"
    done
fi
if $TITLESET_MODE; then
    $KEEP_FILES && mv -v "$REAL_WORK_DIR" "$BASEDIR"/TITLESET${TSET_NUM}
fi
if [ "$TARGET" = dvd ] && $AUTHOR && ! $VMGM_ONLY && ! $DO_TITLESETS && ! $SWITCHED_MODE; then
    echo "Running dvdauthor to create the DVD filesystem"
    dvdauthor -x "$DVDAUTHOR_XML" 2>&1 | tee -a "$LOG_FILE"
    if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
        runtime_error "There was a problem creating the DVD structure"
    fi
elif [ "$TARGET" = svcd ]; then
    makexml -svcd -menu $WORK_DIR/intro.mpg "${IN_FILES[@]}" -out "$OUT_FILE"
    vcdxbuild -b "${OUT_FILE}.bin" -c "${OUT_FILE}.cue"  "${OUT_FILE}.xml"
fi
echo "Cleaning up unwanted files in $REAL_WORK_DIR"
find "$WORK_DIR"/ -name '*.png' ! -name Highlight.png ! -name Select.png -exec rm -f {} \;
find "$WORK_DIR"/ -name '*.jpg' ! -name preview.jpg -exec rm -f {} \;
rm -frv "$WORK_DIR/animenu" "$WORK_DIR/pics" "$WORK_DIR/submenu"
echo "Removing the link in /tmp"
rm -fv "$WORK_DIR"
#    if $SUB_MENU; then
#        makexml -vcd -topmenu "$WORK_DIR/animenu.mpg" \
#        $(for ((x=1; x<=V_TOTAL; x++)); do echo \
#        "-menu $WORK_DIR/Menu${x}.mpg";done) "${IN_FILES[@]}" -out MyDisc
#        vcdxbuild MyDisc.xml
#    else
if ! $VMGM_ONLY && ! [[ -n $TSET_NUM ]]; then
    SCRIPT_END_TIME=`date +%s`
    SCRIPT_TOT_TIME=`expr $SCRIPT_END_TIME \- $SCRIPT_START_TIME`
    HHMMSS=`format_time $SCRIPT_TOT_TIME`
    echo
    echo $SEPARATOR
    echo "todisc took $HHMMSS to finish on $CPU_MODEL $CPU_SPEED mhz"
    echo $SEPARATOR
    if [ "$TARGET" = dvd ]; then
        echo "Your new DVD should be in $OUT_DIR"
        echo "You can preview them in gxine with this command:"
        echo "    gxine \"dvd:/$OUT_DIR\""
        echo "If you are satisfied with the results, you can burn a disc with:"
        echo "    makedvd -burn \"$OUT_DIR\""
    elif [ "$TARGET" = svcd ]; then
        echo "Your svcd bin and cue files are ready. You can burn them with:"
        echo "    cdrdao write --device /dev/hdc --driver generic-mmc "${OUT_FILE}.cue""
    fi
    echo
    echo "Thanks for using todisc."
fi
cleanup
exit 0
