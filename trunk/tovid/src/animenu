#!/bin/bash
ME="[animenu]:"
. tovid-init

# animenu
# Part of the tovid suite
# =======================
# A bash script for generating a DVD with animated thumbnail menus
# from a collection of MPEG video files.
#
# Project homepage: http://www.tovid.org
#
#
# Copyright (C) 2005 tovid.org <http://www.tovid.org>
# 
# This program is free software; you can redistribute it and/or 
# modify it under the terms of the GNU General Public License 
# as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later 
# version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. Or see:
#
#           http://www.gnu.org/licenses/gpl.txt


# Mostly written by Robert Sohn:
#     <grepper@gmail.com>
#     grepper on irc.freenode.net

SCRIPT_NAME=`cat << EOF
--------------------------------
animenu
Generate a DVD filesystem with animated thumbnail menus
Part of the tovid suite, version $TOVID_VERSION
$BUILD_OPTIONS
$TOVID_HOME_PAGE
--------------------------------
EOF`

USAGE=`cat << EOF
Usage:
    animenu [OPTIONS] \\\\
      -files File1.mpg File2.mpg ... \\\\
      -titles "Title 1" "Title 2" ... \\\\
      -out OUT_PREFIX
Input files must be MPEG, and the number of -files and -titles must be equal. 
See the animenu manual page ('man animenu') for additional documentation.

EOF`

WORK_DIR="$(abspath "animenu-work")"
ANIMENU_LOG="`pwd`/animenu.log"
OUT_PREFIX=""
TV_STANDARD=ntsc
ANI_MENU_LENGTH=20
ANI_SUBMENU_LENGTH=10
MAX_ANI_LENGTH=""
TARGET=dvd
FRAME_RATE=29.970  # when -ntsc and -pal options added put in body in if block
LINE=$(for ((i=1; i<=79; i++));do echo -n =;done)
VID_SIZE=720x480
VMGM_TITLE="My Video Collection"
SPUMUX_XML="$WORK_DIR/spumux.xml"
SUBMENU_SPUMUX_XML="$WORK_DIR/submenu_spumux.xml"
DVDAUTHOR_XML="$WORK_DIR/dvdauthor.xml"
GRADIENT="$WORK_DIR/aqua_gradient.png"
STATIC=false
SUB_MENU=false
ANI_SUB_MENU=false
FANCY_TITLE=false
CHAPTERS=6
TITLE_FONT=""
THUMB_FONT=""
BG_AUDIO=""
BG_PIC=""
ANI_BG=""
SUBMENU_AUDIO=false
AUDIO_FADE=false
DISSOLVE=100
MENU_FADE=false
TRANSPARENT=false
PREVIEW=:
PAUSE_TIME=6
MIST=false
FEATHER=false
BLUR=5
SUB_MENU_FEATHER=false
IMG_FMT=jpg
SM_IMG_FMT=jpg  # submenu image format
KEEP_FILES=false
THUMB_FONTSIZE=false
THUMB_SHAPE=""

SCRIPT_START_TIME=`date +%s`

##############################################################################
#                                 Functions                                  #
##############################################################################

# Print script name, usage notes, and optional error message, then exit.
# Args: $@ == text string containing error message
usage_error ()
{
    printf "%s\n" "$USAGE"
    printf "%s\n" "$SEPARATOR"
    printf "*** %s\n" "$@"
    exit 1
}


function cleanlog()
# process $ANIMENU_LOG.tmp variously - eg. ffmpeg's output is ugly without this
{
    FOLD="fold -bs"
    NO_CR="tr -d '\r'"
    RELINE="{s/$SED_VAR/\n$SED_VAR/g}"
    TMP_LOG="$ANIMENU_LOG.tmp"
    NOSPACE="tr -s ' '"

    case "$1" in
        1 )
            $FOLD $TMP_LOG >> $ANIMENU_LOG
            echo >> $ANIMENU_LOG
            ;;
        2 )
            $NO_CR < $TMP_LOG | $FOLD >> $ANIMENU_LOG
            echo >> $ANIMENU_LOG
            ;;
        3 )
            $NO_CR < $TMP_LOG | sed $RELINE | $FOLD >> $ANIMENU_LOG
            echo >> $ANIMENU_LOG
            ;;
        4 )
            $NOSPACE < $TMP_LOG | $FOLD >> $ANIMENU_LOG
            ;;
    esac
    rm -f $ANIMENU_LOG.tmp
}

function sorry_msg()
{
    echo -e "Oops . . .Something went wrong."
    echo "There was a problem creating the $OUTPUT."
    echo "Please check the log at $ANIMENU_LOG"
}

function vid_length()
{
    mencoder "$1" -quiet -ovc copy -oac pcm -o /dev/null |
    awk '/Video stream/ {print $10}'
}

function cleanup()
{
    echo
    if $KEEPFILES; then
        echo "Keeping temporary files in $WORK_DIR"
    else
        rm -rf "$WORK_DIR"
    fi
}

function running_total ()
{
    awk '{
    for (i=1; i<=NF; i++) if (s=s+$i) printf("%s ",s);printf ("\n")}'
}

function format_seconds()
{
    awk '{
    hr=($1/3600); hd=(sprintf("%02d", hr))
    mr=((hr-hd)*60); md=(sprintf("%02d", mr))
    s=((mr-md)*60); sd=(sprintf("%02d", s))
    t=(sprintf("%02d:%02d:%06.3f" ,hd,md,s)); print t}' <<< $1
}


function confirm_msg()
{
    printf "%s\n" "$LINE"
    echo
    echo "Your current font arrangement is: "
    echo "menu title font: $TITLE_FONT at size $TITLE_FONT_SIZE "
    echo "thumb font: $THUMB_FONT at size $THUMB_FONTSIZE"
    echo
    echo "If you are happy with your preview, type 'yes' to continue: "
    echo
    read input
    echo
    if [ ! -z "$input" -a "$input" = 'yes' ]; then
        echo "Preview OK, continuing."
        echo
    else
        echo "If titles do not fit, or look bad, then -menu-font, -menu-fontsize"
        echo "-thumbfont and -thumb-fontsize are options to consider"
        echo "For other fine-tuning options, see 'man animenu'."
        echo
        echo "Exiting from animenu."
        exit 0
    fi
    printf "%s\n" "$LINE"
    echo
}

##############################################################################
#                          	End of functions                                 #
##############################################################################

trap 'cleanup; exit 13' TERM INT

###############################################################################
#       Process arguments to the script, set up VARS and WORK_DIR             #
###############################################################################

# ***********************************
# EXECUTION BEGINS HERE
# ***********************************

echo $"$SCRIPT_NAME"

while test $# -gt 0; do
    DO_SHIFT=:
    case "$1" in
        "-files" )
            shift
            # Hackish list-parsing
            while test $# -gt 0 && test ${1:0:1} != "-"; do
                VIDS=( "${VIDS[@]}" "$1" )
                shift
            done
            # Don't skip past the next argument
            if test $# -gt 0 && test ${1:0:1} = "-"; then DO_SHIFT=false; fi
            ;;
        "-titles" )
            shift
            # Hackish list-parsing
            IFS="";while test $# -gt 0 && test ${1:0:1} != "-"; do
                TITLES=( "${TITLES[@]}" "$1" )
                shift
            done
            # Don't skip past the next argument
            if test $# -gt 0 && test ${1:0:1} = "-"; then DO_SHIFT=false; fi
            unset IFS
            ;;
        "-out" )
            shift
            OUT_PREFIX="$1"
            ;;
        "-keepfiles" )
            KEEP_FILES=:
            ;;
        "-ntsc" )
            TV_STANDARD=ntsc
            ;;
        "-pal" )
            TV_STANDARD=pal
            ;;
        "-menu-length" )
            shift
            ANI_MENU_LENGTH="$1"
            ;;
        "-submenu-length" )
            shift
            ANI_SUBMENU_LENGTH="$1"
            ;;
        "-dvd" )
            TARGET=dvd
            ;;
        "-svcd" )
            TARGET=svcd
            ;;
        "-static" )
            STATIC=:
            ;;
        "-bgimage" )
            shift
            BG_PIC="$(abspath "$1")"
            MIST=: 
            ;;
        "-menu-fade" )
            MENU_FADE=:
            ;;
        "-bgvideo" )
            shift
            ANI_BG="$(abspath "$1")"
            MIST=: 
            ;;
        "-thumb-shape" )
            shift
            THUMB_SHAPE="$1"
            FEATHER=:
            IMG_FMT=png
            ;;
        "-feather" )
            shift
            BLUR="$1"
            FEATHER=:
            IMG_FMT=png
            ;;
        "-transparency" )
            shift
            TRANSPARENT=:
            DISSOLVE="$1"
            ;;
        "-submenu-audio" )
            shift
            # Hackish list-parsing
            while test $# -gt 0 && test ${1:0:1} != "-"; do
                SM_AUDIO=( "${SM_AUDIO[@]}" "$1" )
                shift
            done
            # Don't skip past the next argument
            if test $# -gt 0 && test ${1:0:1} = "-"; then DO_SHIFT=false; fi
            SUBMENU_AUDIO=:
            ;;
        "-chapters" )
            shift
            CHAPTERS="$1"
            ;;
        "-bgaudio" )
            shift
            BG_AUDIO="$(abspath "$1")"
            ;;
        "-menu-audio-fade" )
            shift
            FADE="$1"
            AUDIO_FADE=:
            ;;
        "-submenus" )
            SUB_MENU=:
            ;;
        "-ani-submenus" )
            ANI_SUB_MENU=:
            SUB_MENU=:
            ;;
        "-menu-title" )
            shift
            VMGM_TITLE="$1"
            ;;
        "-thumb-fontsize" )
            shift
            THUMB_FONTSIZE="$1"
            ;;
        "-menu-font" )
            shift
            # If there's a filename extension, find the absolute path
            if echo "$1" | grep -q '\...*$'; then
                TITLE_FONT="$(abspath "$1")"
            else
                TITLE_FONT="$1"
            fi
            ;;
        "-menu-fontsize" )
            shift
            TITLE_FONT_SIZE="$1"
            ;;
        "-fancy" )
            FANCY_TITLE=:
            ;;
        "-thumb-font" )
            shift
            # If there's a filename extension, find the absolute path
            if echo "$1" | grep -q '\...*$'; then
                THUMB_FONT="$(abspath "$1")"
            else
                THUMB_FONT="$1"
            fi
            ;;
        "-seek" )
            shift
            SEEK="$1"
            SEEK="-ss $SEEK"
            ;;
    esac
    $DO_SHIFT && shift
done
# Make sure equal, nonzero number of titles and files were provided
if test ${#VIDS[@]} -eq 0 || test ${#TITLES[@]} -eq 0; then
    usage_error "Please provide at least one file and one title."
elif test ${#VIDS[@]} -ne ${#TITLES[@]}; then
    usage_error "Please give the same number of files as titles."
fi

# Error if -out was not provided
if test -z "$OUT_PREFIX"; then
    usage_error "Please provide an output name with -out"
fi
OUT_DIR="$(abspath "$OUT_PREFIX")"
MENU_FILE="animenu.mpg"

# If output directory already exists, print a message and exit

if test -d "$OUT_DIR"; then
    echo "Output directory \"$OUT_DIR\" already exists."
    echo "Please use a different -out name, or (re)move the existing directory."
    exit 0
fi
# Clean out any existing WORK_DIR
if test -d "$WORK_DIR"; then
    echo "Removing existing files in \"$WORK_DIR\""
    rm -rf "$WORK_DIR"
fi
mkdir -pv "$WORK_DIR"
# mv any existing animenu.log to a new name to keep its size reasonable
if test -f $ANIMENU_LOG; then
    echo "Moving $(pwd)/animenu.log to $(pwd)/animenu-$(date +%s).log"
    mv $(pwd)/animenu.log $(pwd)/animenu-$(date +%s).log
fi

# Try to find a default font that is available
if [ -z "$TITLE_FONT" ]; then
    if convert -size 50x20 xc:none -font Helvetica -gravity Center \
    -draw "text 0,0 'test'" $WORK_DIR/font.png; then
        TITLE_FONT="Helvetica"
        THUMB_FONT="Helvetica"
    elif convert -size 200x100 xc:none -font helvetica -gravity Center \
    -draw "text 0,0 'test'" $WORK_DIR/font.png; then
        TITLE_FONT="helvetica"
        THUMB_FONT="helvetica"
    fi
fi

rm -f "$WORK_DIR/font.png"

for i in "${VIDS[@]}"; do
    VID_ARRAY=( "${VID_ARRAY[@]}" "$(abspath "$i")" )
done

# do everything in $WORK_DIR
cd $WORK_DIR


# make sure titles have no more than 12 characters
for ((i=0; i<${#TITLES[@]}; i++)); do
    val=${#TITLES[i]}
    [ -z "$MAX_VAL" ] || ((val > MAX_VAL)) && MAX_VAL=$val && key=$i
done

if [ $MAX_VAL -gt 12 ]; then
    echo -e "Sorry, maximum number of characters you can use for a title is 12"
    echo -e "The title \"${TITLES[key]}\" is too long"
    exit 1
fi

NTSC_SVCD_VIDSIZE="480x480"
PAL_SVCD_VIDSIZE="560x576"
NTSC_DVD_VIDSIZE="720x480"
PAL_DVD_VIDSIZE="720x576"
DVD_AUDIO_EXT=ac3
SVCD_AUDIO_EXT=mp2
DVD_SAMPLERATE="48000"
SVCD_SAMPLERATE="44100"
DVD_AUDIO_OPTS="-ab 224 -ar 48000 -ac 2 -acodec $DVD_AUDIO_EXT"
SVCD_AUDIO_OPTS="-ab 224 -ar 44100 -ac 2 -acodec $SVCD_AUDIO_EXT"
SVCD_FFMPEG_OPTS="-b 2200 -minrate 2200 -maxrate 2200 -bufsize 230 -aspect 4:3"
DVD_FFMPEG_OPTS="-b 8000  -maxrate 9000 -bufsize 230  -aspect 4:3"
SVCD_INTRO_SIZE="240x240"
#DVD_INTRO_SIZE="360x240"
SVCD_MPLEX_FORMAT=4
DVD_MPLEX_FORMAT=8
SVCD_TITLE_FONT_SIZE=32
DVD_TITLE_FONT_SIZE=40
# PTSIZE=(30 36 42 42 42 42 48 48 48 48 48 48 54 54 54 54 54 54 54 54 \
# 54 54 54 54 54 54 54 54 54 54)
THUMB_FONTSIZE_ARRAY=(18 16 14 14 12 12 12 12 12 11 11 11 11 11 11 11 11 11 \
11 11 11 11 11 11 11 11 11 11)
#DVD_GEO_ARRAY=(360x240 270x180 210x140 210x140 192x128 192x128 144x96 144x96 \
#144x96 120x80 120x80 120x80 96x64 96x64 96x64 96x64 96x64 96x64 96x64 96x64 \
#72x48 72x48 72x48 72x48 72x48 72x48 72x48 72x48 72x48 72x48)
DVD_GEO_ARRAY=(320x240 272x204 192x144 192x144 184x138 184x138 144x108 144x108 \
120x90 120x90 120x90 120x90 96x72 96x72 96x72 96x72 96x72 96x72 96x72 96x72 \
72x54 72x54 72x54 72x54 72x54 72x54 72x54 72x54 72x54 72x54)
SVCD_GEO_ARRAY=(240x240 180x180 120x120 120x120 120x120 120x120 96x96 96x96 \
96x96 80x80 80x80 80x80 64x64 64x64 64x64 64x64 64x64 64x64 64x64 64x64 \
48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48)
#TILE_ARRAY=(1x1 2x1 2x2 2x2 3x2 3x2 3x3 3x3 3x3 4x3 4x3 4x3 4x4 4x4 4x4
#4x4 5x4 5x4 5x4 5x4 5x5 5x5 5x5 5x5 5x5 6x5 6x5 6x5 6x5 6x5)
TILE_ARRAY=(1x1 2x1 2x2 2x2 3x2 3x2 4x2 4x2 3x3 4x3 4x3 4x3 4x4 4x4 4x4
4x4 5x4 5x4 5x4 5x4 5x5 5x5 5x5 5x5 5x5 6x5 6x5 6x5 6x5 6x5)


V_ARRAY_TOTAL=${#VID_ARRAY[@]}
A_ARRAY_TOTAL=${#TITLES[@]}
FILES=$(($V_ARRAY_TOTAL - 1))
if  "$THUMB_FONTSIZE"; then
    THUMB_FONTSIZE=$THUMB_FONTSIZE
else
    THUMB_FONTSIZE=${THUMB_FONTSIZE_ARRAY[FILES]}
fi
# set up our log file
PATTERN=$(for ((i=1; i<=79; i++)); do echo -n \*; done)
printf "%s\n%s\n%s\n\n\n" "$PATTERN" \
"tovid suite's animenu - log for `date`" \
"$PATTERN" >> $ANIMENU_LOG

# create_dirs
echo
echo "Creating pics directories..."
for ((i=0; i<=FILES; i++)); do
    mkdir -pv "$WORK_DIR/pics/$i"
done
if $MENU_FADE; then mkdir -v $WORK_DIR/bg; fi
mkdir -v "$WORK_DIR/animenu"
if $ANI_SUB_MENU; then
    for ((i=0; i<CHAPTERS; i++)); do
        mkdir -v "$WORK_DIR/animenu/$i"
    done
fi

echo
echo "Videos to be processed"
for vid in "${VID_ARRAY[@]}"; do echo "$vid";done
echo  
if  [ $TARGET = "dvd" ]; then
    AUDIO_EXT=$DVD_AUDIO_EXT
    AUDIO_OPTS=$DVD_AUDIO_OPTS
    SAMPLERATE=$DVD_SAMPLERATE
    MPLEX_FORMAT=$DVD_MPLEX_FORMAT
    GEO_ARRAY=("${DVD_GEO_ARRAY[@]}")
    INTRO_SIZE=$DVD_INTRO_SIZE
    FFMPEG_OPTS=$DVD_FFMPEG_OPTS
    if [ $TV_STANDARD = ntsc ]; then
        VIDSIZE=$NTSC_DVD_VIDSIZE
        FRAME_RATE=29.970
    elif [ $TV_STANDARD = pal ]; then
        VIDSIZE=$PAL_DVD_VIDSIZE
        FRAME_RATE=25
    fi
    if [ -z $TITLE_FONT_SIZE ]; then
        TITLE_FONT_SIZE=$DVD_TITLE_FONT_SIZE
    else
        TITLE_FONT_SIZE=$TITLE_FONT_SIZE
    fi
elif [ $TARGET = "svcd" ]; then
    AUDIO_EXT=$SVCD_AUDIO_EXT
    AUDIO_OPTS=$SVCD_AUDIO_OPTS
    SAMPLERATE=$SVCD_SAMPLERATE
    MPLEX_FORMAT=$SVCD_MPLEX_FORMAT
    GEO_ARRAY=("${SVCD_GEO_ARRAY[@]}")
    INTRO_SIZE=$SVCD_INTRO_SIZE
    FFMPEG_OPTS=$SVCD_FFMPEG_OPTS
    if [ $TV_STANDARD = ntsc ]; then
        VIDSIZE=$NTSC_SVCD_VIDSIZE
        FRAME_RATE=29.970
    elif [ $TV_STANDARD = pal ]; then
        VIDSIZE=$PAL_SVCD_VIDSIZE
        FRAME_RATE=25
    fi

    if [ -z $TITLE_FONT_SIZE ]; then
        TITLE_FONT_SIZE=$SVCD_TITLE_FONT_SIZE
    else
        TITLE_FONT_SIZE=$TITLE_FONT_SIZE
    fi
fi
INTRO_SIZE="${GEO_ARRAY[FILES]}"
###############################################################################
#     generate title_txt png, and template.png needed for all operations       #
###############################################################################

if [ -z "$BG_PIC" ]; then
    echo
    echo "Creating a black background"
    BG_PIC="$WORK_DIR/pics/template.png"
    convert  -resize $VIDSIZE! xc:"#161514" "$BG_PIC"
else
    convert -resize $VIDSIZE! "$BG_PIC" "$WORK_DIR/pics/template.png"
fi

if $MENU_FADE || $FEATHER; then
    convert -size $VIDSIZE xc:"#161514" "$WORK_DIR/black.jpg"
fi
DIMY=$(echo $INTRO_SIZE|cut -f1 -dx)
DIMX=$(echo $INTRO_SIZE|cut -f2 -dx)
DIMY1=$((DIMY / 20))
DIMX1=$((DIMX / 20))
DIMY2=$((DIMY - DIMY1))
DIMX2=$((DIMX - DIMY1))
DIMY3=$(($DIMY2 / 2))
DIMX3=$(($DIMX2 / 2))
DIMY4=$((DIMY / 2))
DIMX4=$((DIMX / 2))
DIMY5=$((DIMY / 3))
DIMX5=$((DIMX4 / 3))
if [ -n "$THUMB_SHAPE" ]; then
    convert -size $INTRO_SIZE xc:none -fill white -stroke none \
    -draw "rectangle $DIMY1,$DIMY1 $DIMY2,$DIMX2" $WORK_DIR/feather_orig.png
    convert $WORK_DIR/feather_orig.png -channel RGBA \
    -blur 0x60 $WORK_DIR/feather_mask2.png
fi
if test "$THUMB_SHAPE" = "normal"; then
    THUMB_MASK=$WORK_DIR/feather_mask.png
    convert -size $INTRO_SIZE xc:black -fill white \
    -draw "Rectangle $DIMY1,$DIMY1 $DIMY2,$DIMX2," +matte -compose CopyOpacity miff:- |
    convert - -blur 0x$BLUR -channel RGBA +matte miff:- |
    convert - -blur 0x$BLUR -channel RGBA +matte miff:- |
    convert - -blur 0x$BLUR -channel RGBA +matte miff:- |
    convert - -blur 0x$BLUR -channel RGBA +matte miff:- |
    convert - -evaluate subtract 50% -normalize $THUMB_MASK
fi
if $FEATHER; then
    FILL="#161514"
else
    FILL="#C6C6C6"
fi
if test "$THUMB_SHAPE" = "oval"; then
    THUMB_MASK=$WORK_DIR/oval_mask.png
    echo "Running:
    convert -size $INTRO_SIZE xc:black -fill white \
    -draw "RoundRectangle $DIMY1,$DIMY1 $DIMY2,$DIMX2, $DIMY3,$DIMX3" \
    +matte -compose CopyOpacity miff:- |
    convert - -blur 0x$BLUR -channel RGBA +matte miff:- |
    convert - -evaluate subtract 50% -normalize $THUMB_MASK" |
    sed 's/    */ /g'|sed -e "s/^ *//" 
    echo
    convert -size $INTRO_SIZE xc:black -fill white \
    -draw "RoundRectangle $DIMY1,$DIMY1 $DIMY2,$DIMX2, $DIMY3,$DIMX3" \
    +matte -compose CopyOpacity miff:- |
    convert - -blur 0x$BLUR -channel RGBA +matte miff:- |
    convert - -blur 0x$BLUR -channel RGBA +matte miff:- |
    convert - -blur 0x$BLUR -channel RGBA +matte miff:- |
    convert - -blur 0x$BLUR -channel RGBA +matte miff:- |
    convert - -evaluate subtract 50% -normalize $THUMB_MASK
fi

if test "$THUMB_SHAPE" = "rounded"; then
    THUMB_MASK=$WORK_DIR/rounded_mask.png
    echo "Running:

    convert -size $INTRO_SIZE xc:black -fill white \
    -draw "circle $DIMY4,$DIMX4 $DIMY5,$DIMX5" \
    +matte -compose CopyOpacity miff:- |
    convert - -blur 0x$BLUR -channel RGBA +matte miff:- |
    convert - -evaluate subtract 50% -normalize $THUMB_MASK" |
    sed 's/    */ /g'|sed -e "s/^ *//"
    echo
    convert -size $INTRO_SIZE xc:black -fill white \
    -draw "circle $DIMY4,$DIMX4 $DIMY5,$DIMX5" \
    +matte -compose CopyOpacity miff:- |
    convert - -blur 0x$BLUR -channel RGBA +matte miff:- |
    convert - -blur 0x$BLUR -channel RGBA +matte miff:- |
    convert - -blur 0x$BLUR -channel RGBA +matte miff:- |
    convert - -blur 0x$BLUR -channel RGBA +matte miff:- |
    convert - -evaluate subtract 50% -normalize - $THUMB_MASK
fi

if test "$THUMB_SHAPE" = "cloud"; then
    THUMB_MASK=$WORK_DIR/cloud_mask.png
    convert -size 320x240 xc:none -fill white \
    -draw "circle 80,80 120,120" \
    -draw "circle 160,80 200,120" \
    -draw "circle 240,80 280,120" \
    -draw "circle 80,160 120,200" \
    -draw "circle 160,160 200,200" \
    -draw "circle 240,160 280,200" \
    +matte -compose CopyOpacity  miff:- |
    convert -blur 0x$BLUR - miff:- |
    convert -blur 0x$BLUR - miff:- |
    convert -blur 0x$BLUR - miff:- |
    convert -blur 0x$BLUR - miff:- |
    convert -resize $INTRO_SIZE! - $THUMB_MASK
fi


if $FANCY_TITLE; then
    convert -size 1x512 gradient: -rotate 90 +matte \
    -fx '3.5u^3 - 5.05u^2 + 2.05u + 0.3' \
    -size 512x1 xc:"#08447B" -compose Overlay -composite "$GRADIENT"
    echo "Creating a transparent png with the title on it"

    convert -font "$TITLE_FONT" -pointsize $TITLE_FONT_SIZE -size 620x \
    -gravity Center caption:"\"$VMGM_TITLE\""  -negate  \( +clone \
    -shade 110x45 -normalize \
    $GRADIENT  -fx 'v.p{g*v.w,0}' \)  +matte +swap \
    -compose CopyOpacity -composite  \
    \( +clone -fx A +matte -shade 0x90 -normalize -negate \
    -evaluate multiply .4 -negate +clone  -compose Multiply -composite \) \
    -matte  -compose In  -composite miff:- |
     convert -trim +repage - -blur 0.4x0.4 $WORK_DIR/title_txt.png
else
    CMD="convert -size 620x100 xc:none -font \"$TITLE_FONT\" 
        -pointsize $TITLE_FONT_SIZE 
        -fill black -draw \"gravity center text 2,2 '$VMGM_TITLE'\" 
        -stroke grey -strokewidth 1 
        -fill '#CDC0B0' -stroke gray 
        -draw \"gravity center text 1,1 '$VMGM_TITLE'\" miff:- |
        convert -trim +repage - -blur 0.4x0.4 $WORK_DIR/title_txt.png"
    echo "Creating a plain white title with the following command:"
    echo $CMD|sed 's/    */ /g'
    echo "(Use the -fancy option for a fancier dark blue title)"
    echo
    eval $CMD
fi

if $MIST; then
    # make a white png for misted background effect, only for user's bg
    Y=$(identify $WORK_DIR/title_txt.png |awk '{print $3}'|cut -dx -f1)
    X=$(identify $WORK_DIR/title_txt.png |awk '{print $3}'|cut -dx -f2)
    # add 10 pixels to width and height compared to title text png
    y=$((Y + 20))
    x=$((X + 20))
    newX=$(($X + 10))
    newY=$(($Y + 10))
    DIM=${y}x${x}
    convert -size $DIM xc:none -fill white -stroke none \
    -draw "rectangle 5,10 $newY,$newX" $WORK_DIR/white_orig.png
    convert $WORK_DIR/white_orig.png -channel RGBA -blur 0x4 $WORK_DIR/white.png
    unset X Y x y
fi

###############################################################################
#      generate a basic preview of the main menu      #
###############################################################################
if $MIST; then
    # overlay white.png onto the background
    composite -dissolve 30 -gravity south -geometry +0+45 \
    $WORK_DIR/white.png $WORK_DIR/pics/template.png \
    $WORK_DIR/pics/template.png
fi
# generate images for montage and title and resize them
for ((i=0; i<=FILES; i++)) ; do
    FFMPEG_CMD=(ffmpeg -i "${VID_ARRAY[i]}" $SEEK -vframes 1 \
    -s $INTRO_SIZE $WORK_DIR/${i}-preview%d.$IMG_FMT)
    printf "%s\n\n" "$LINE" "$LINE" >> $ANIMENU_LOG
    echo -e "\nRunning: ${FFMPEG_CMD[@]}\n" | fold -bs >> $ANIMENU_LOG
    SED_VAR="frame="
    if "${FFMPEG_CMD[@]}" >> $ANIMENU_LOG.tmp 2>&1;then
        cleanlog 3
    else
        cleanlog 3
        OUTPUT="There was a problem creating images from the video.\n \
        Please see the output of $ANIMENU_LOG"
        SORRY_MSG=$OUTPUT
        sorry_msg
        exit 1
    fi
done
PICS=( "${PICS[@]}" \
$(find $WORK_DIR/ -maxdepth 1 -name \*preview\*.$IMG_FMT) )
for i in "${!PICS[@]}"; do
    if $FEATHER; then
        composite -compose CopyOpacity $THUMB_MASK +matte \
        "${PICS[i]}" miff:- |
        convert -trim +repage -  "${PICS[i]}"
    fi

    # **if horizontal lines in frames, try montage "${JPGS[i]}" -blur 0x.3**
    # using a mask just on the frame portion would be even better
    # www.cit.gu.edu.au/~anthony/info/graphics/imagemagick.hints 1/4 down
    IM_CMD1=(montage "${PICS[i]}" -geometry +4+4 -compose Copy  \
    -background  none -fill "$FILL" -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE \
    -title "${TITLES[i]}")
    IM_CMD2=(convert -resize $INTRO_SIZE! -)
    IM_CMD3=(composite -gravity center -compose DstOver $WORK_DIR/feather_mask2.png - )
    IM_CMD4=(convert -background none -frame 5x5 \
    -bordercolor "#444744" -)
    IM_CMD5=(convert -resize $INTRO_SIZE! - "${PICS[i]}")
    if $FEATHER; then
        "${IM_CMD1[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
        "${IM_CMD3[@]}" miff:- | "${IM_CMD5[@]}"
    else
        "${IM_CMD1[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
        "${IM_CMD4[@]}" miff:- | "${IM_CMD5[@]}"
    fi
done

echo "Creating and displaying a preview of the main menu."
echo "(Press 'q' or ESC in the preview window to close it.)"

if $TRANSPARENT; then
    montage ${PICS[@]} -blur 0x.3 -tile ${TILE_ARRAY[FILES]} \
    -geometry ${GEO_ARRAY[FILES]}+5+5 -background none -bordercolor "#444744" miff:- |
    composite -dissolve $DISSOLVE \
    -gravity north -geometry +0+50 - \
    $WORK_DIR/pics/template.png -background none miff:- |
    convert - $WORK_DIR/title_txt.png  \
    -gravity south -geometry +0+55 -composite miff:- |display
else # Not transparent
    montage ${PICS[@]} -tile ${TILE_ARRAY[FILES]} \
    -geometry ${GEO_ARRAY[FILES]}+5+5 -background none -bordercolor "#444744" miff:- |
    convert $WORK_DIR/pics/template.png \
    $WORK_DIR/title_txt.png  -gravity south -geometry +0+55 -composite \
    -  -gravity north -geometry +0+50 -composite miff:- | display
fi
confirm_msg

unset PICS IM_CMD1 IM_CMD2 IM_CMD3 IM_CMD4 IM_CMD5
###############################################################################
#             get information about videos and store in an array              #
###############################################################################

for i in ${!VID_ARRAY[@]}; do
    echo "Getting stats on "${VID_ARRAY[i]}""
    mencoder_stats=( "${mencoder_stats[@]}" \
    "$(mencoder -quiet "${VID_ARRAY[i]}" -oac pcm -ovc copy -o /dev/null 2>&1)" )
done
echo
echo $SEPARATOR
echo
# put in the log file in case anyone is interested
for i in ${!VID_ARRAY[@]}; do
    VCODEC="$(awk '/VIDEO:/ {gsub(/\[|\]/, ""); print $2}' \
    <<< "${mencoder_stats[i]}")"
    V_BR="$(awk '/Video stream:/{print $3}'<<<"${mencoder_stats[i]}")"
    ACODEC="$(awk  '/Selected audio codec/ {gsub(/\[|\]/, ""); print $4}' \
    <<< "${mencoder_stats[0]}")"
    A_BR="$(awk  '/AUDIO:/ {print $7}' <<< "${mencoder_stats[i]}")"
    if [ -z "$A_BR" ]; then
        A_BR="No audio found"
    fi
    V_LENGTH="$(awk '/Video stream:/{print $10}'<<<"${mencoder_stats[i]}")"
    FPS="$(awk '/VIDEO:/ {print $6}' <<<"${mencoder_stats[i]}")"
    printf "%s\n\n" "$LINE" "$LINE" >> $ANIMENU_LOG
    echo -e "Stats for" "${VID_ARRAY[i]}" "\n" \
    "video codec:   " \
    "$VCODEC" "\n" \
    "video bitrate: " "$V_BR" "kbps" "\n" \
    "framerate:     " "$FPS" "fps" "\n" \
    "audio codec:   " \
    "$ACODEC" "\n" \
    "audio bitrate: " \
    "$A_BR" " kbps" "\n" \
    "video length:  " \
    "$V_LENGTH" " seconds" "\n" |tee -a $ANIMENU_LOG
done
echo
echo $SEPARATOR

for i in ${!mencoder_stats[@]}; do
    VID_LEN=( ${VID_LEN[@]}  "$(awk '/Video stream:/{print $10}' \
    <<<"${mencoder_stats[i]}")" )
done

for i in ${!VID_LEN[@]}; do
    NEW_LENGTH=( ${NEW_LENGTH[@]}   ${VID_LEN[i]%.*} )
done
# find out longest video and shortest video 
for ((i=0; i<${#NEW_LENGTH[@]}; i++)); do
    val=${NEW_LENGTH[i]}
    [ -z "$MAX_VAL" ] || ((val > MAX_VAL)) && MAX_VAL=$val && max_key=$i
    if $ANI_SUB_MENU; then 
        [ -z "$MIN_VAL" ]  || ((val < MIN_VAL)) && MIN_VAL=$val && min_key=$i
    fi
done
# if shortest is less than 340 frames * $CHAPTERS then no animated submenu
if $ANI_SUB_MENU && [ $MIN_VAL -lt $(((340 * CHAPTERS) / 30)) ]; then
    echo -n "Sorry, the shortest length video must be greater than "
    echo "$(((340 * CHAPTERS) / 30)) seconds"
    echo "to use animated submenus."
    echo "${VID_ARRAY[min_key]} is only $MIN_VAL seconds long"
    exit 1
fi 
# allow animated menus of length of longest video
MAX_ANI_LENGTH=$(awk -v fr=$FRAME_RATE -v al=$ANI_MENU_LENGTH 'BEGIN { printf("%d\n", (fr*al)); }')
MAX_VAL_FRAMES="$(($MAX_VAL * 30))"
if [ $MAX_VAL_FRAMES -lt $MAX_ANI_LENGTH ]; then
    MAX_ANI_LENGTH=$MAX_VAL_FRAMES
fi
# if submenu selected, translate seconds of submenu length into # of frames
if $ANI_SUB_MENU; then
    ANI_SUBMENU_FRAMES=$(awk -v fr=$FRAME_RATE -v sml=$ANI_SUBMENU_LENGTH \
    'BEGIN { printf("%d\n", (fr*sml)); }')
fi

ANI_FRAMES=$MAX_ANI_LENGTH
if $STATIC; then
    FRAMES=1
else
    FRAMES=$ANI_FRAMES
fi

###############################################################################
#                           End of info block                                 #
###############################################################################

###############################################################################
#                       work on the clip title images                         #
###############################################################################
# extract images from the provided background video
echo
echo "Creating images from each video for the main menu"
for ((i=0; i<=FILES; i++)) ; do
    echo "Working on "${VID_ARRAY[$i]}""
    CREATE_IMG_CMD=(ffmpeg -i "${VID_ARRAY[$i]}"  $SEEK -vframes $FRAMES \
    -s "$INTRO_SIZE" "$WORK_DIR/pics/$i/%d.$IMG_FMT")
    printf "%s\n\n" "$LINE" "$LINE" >> $ANIMENU_LOG
    echo -e "\nRunning: ${CREATE_IMG_CMD[@]}\n" | fold -bs >> $ANIMENU_LOG

    SED_VAR="frame="
    if "${CREATE_IMG_CMD[@]}" >> $ANIMENU_LOG.tmp 2>&1;then
        cleanlog 3
    else
        cleanlog 3
        OUTPUT="There was a problem creating images from the video.\n \
        Please see the output of $ANIMENU_LOG"
        SORRY_MSG=$OUTPUT
        sorry_msg
        exit 1
    fi

done
# create the pics for background image
    if [ -z "$BG_PIC" ]; then
        echo
        echo "Creating a black background"
        BG_PIC="$WORK_DIR/pics/template.jpg"
        convert  -size $VIDSIZE xc:"#161514" "$BG_PIC"
        cp "$BG_PIC" "$WORK_DIR/submenu_template.jpg"
    else
        convert -resize $VIDSIZE! "$BG_PIC" "$WORK_DIR/pics/template.jpg"
        convert -size $VIDSIZE xc:"#161514" "$WORK_DIR/submenu_template.jpg"
    fi

echo
echo "Creating a gradient image for fancy titling"
convert -size 1x512 gradient: -rotate 90 +matte \
-fx '3.5u^3 - 5.05u^2 + 2.05u + 0.3' \
-size 512x1 xc:"#08447B" -compose Overlay -composite "$GRADIENT"


##############################################################################
#                     spumux and dvdauthor stuff                             #
##############################################################################
echo
echo "Creating the highlight and selection PNGs for the main menu"
echo
GEO="${GEO_ARRAY[FILES]/x/,}"
SELECT_CMD="-size "${GEO_ARRAY[FILES]}+5+5" xc:none -fill none +antialias \
-stroke '#DE7F7C' -strokewidth 4 -draw 'rectangle 0,0 $GEO'"
HIGHLIGHT_CMD="-size "${GEO_ARRAY[FILES]}+5+5" xc:none -fill none +antialias \
-stroke '#188DF6' -strokewidth 4 -draw 'rectangle 0,0 $GEO'"
eval convert "$SELECT_CMD" -colors 3 "$WORK_DIR/Selectx1.png"
eval convert "$HIGHLIGHT_CMD" -colors 3 "$WORK_DIR/Highlightx1.png"

for button in Select Highlight; do
    montage -background none \
    $(for ((i=0; i<=FILES; i++)); do echo $WORK_DIR/${button}x1.png;done) \
    -tile ${TILE_ARRAY[FILES]} -geometry ${GEO_ARRAY[FILES]}+5+5 \
    -bordercolor none -mattecolor transparent miff:- |
    convert  -colors 3 -size 720x480 xc:none - -gravity north -geometry +0+50 \
    -composite  "$WORK_DIR/${button}.png"
done

if $SUB_MENU; then
    echo
    echo "Creating the highlight and selection PNGs for the submenus"
    GEO="${GEO_ARRAY[CHAPTERS - 1]/x/,}"
    SELECT_CMD="-size "${GEO_ARRAY[CHAPTERS - 1]}+5+5" xc:none -fill none \
    +antialias -stroke '#DE7F7C' -strokewidth 4 -draw 'rectangle 0,0 $GEO'"
    HIGHLIGHT_CMD="-size "${GEO_ARRAY[CHAPTERS - 1]}+5+5" xc:none -fill none \
    +antialias -stroke '#188DF6' -strokewidth 4 -draw 'rectangle 0,0 $GEO'"
    eval convert "$SELECT_CMD" -colors 3 "$WORK_DIR/Submenu_Selectx1.png"
    eval convert "$HIGHLIGHT_CMD" -colors 3 "$WORK_DIR/Submenu_Highlightx1.png"
    for button in Select Highlight; do
        montage -background none \
        $(for ((i=0; i<CHAPTERS; i++)); do
        echo $WORK_DIR/Submenu_${button}x1.png;done) \
        -tile ${TILE_ARRAY[CHAPTERS - 1]} \
        -geometry ${GEO_ARRAY[CHAPTERS - 1]}+5+5 \
        -bordercolor none -mattecolor transparent miff:- |

        convert  -colors 3 -size 720x480 xc:none  - \
        -gravity north -geometry +0+50  \
        -composite  $WORK_DIR/Submenu_${button}.png
    done
fi

# make appropriate chapter lengths for each video
# get chapter lengths by dividing by $CHAPTERS, then getting running totals
for i in ${!NEW_LENGTH[@]}; do
  CHAPT_INTERVALS=( ${CHAPT_INTERVALS[@]} $(( ${NEW_LENGTH[i]} / $CHAPTERS)) )
done

# and format in HH:MM:SS
for len in ${CHAPT_INTERVALS[@]}; do
    L=( ${L[@]} $(for ((i=1; i<CHAPTERS; i++)) ; do echo "$len";done) )
    chapt_intervals=$(running_total <<< ${L[@]})
    chapters="$(for c in $chapt_intervals; do echo $(format_seconds $c); done)"
    chapters="00:00:00.000 $chapters"
    CHAPTS=$(for i in $chapters; do echo -n $i,;done|sed 's/,$//')
    CHAPT_ARRAY=( ${CHAPT_ARRAY[@]} $CHAPTS )
    unset L chapt_intervals cmd
done
# debug chapters
for i in ${!VID_ARRAY[@]}; do
    echo -e "Chapters for "${VID_ARRAY[i]}" are: \n${CHAPT_ARRAY[i++]}\n"
done
# make xml files, and run dvdauthor and spumux
if $MENU_FADE; then
    . animenu-fade-routine
    END_TIME=$(format_seconds $THUMBS_FADE_OUT_END_TIME)
    END=" end=\"$END_TIME\""
    START=$(format_seconds $THUMBS_FADE_IN_START_TIME)
    PAUSE_TIME="6"
    POST="<post> jump cell 1; </post>"
    MAIN_POST="        <post> jump cell 1; </post>"
else
    PAUSE_TIME="inf"
    unset END
    START="00:00:00.0"
fi

(
    cat <<EOF
<subpictures>
   <stream>
     <spu force="yes" start="$START"$END
          highlight="$WORK_DIR/Highlight.png"
          select="$WORK_DIR/Select.png"
          autooutline="infer"
          autoorder="rows"/>
   </stream>
 </subpictures>
EOF
)  > "$SPUMUX_XML"
# make submenu spumux.xml
if $SUB_MENU; then
(
    cat <<EOF
<subpictures>
   <stream>
     <spu force="yes" start="00:00:00.0"
          highlight="$WORK_DIR/Submenu_Highlight.png"
          select="$WORK_DIR/Submenu_Select.png"
          autooutline="infer"
          autoorder="rows"/>
   </stream>
 </subpictures>
EOF
) > "$SUBMENU_SPUMUX_XML"
fi
if $SUB_MENU; then
    JUMP=menu
    POST="        <post> jump cell 1; </post>"
    if $ANI_SUB_MENU; then
        PAUSE=" pause=\"5\""
    else
        PAUSE=" pause=\"inf\""
        unset POST
    fi
else
    JUMP=title
fi
if [ $TARGET = svcd ]; then
:
else
# make dvdauthor.xml
(
    cat <<EOF
<?xml version="1.0" encoding="utf-8"?>
<dvdauthor dest="$OUT_DIR" jumppad="1">
  <vmgm>
    <menus>
      <pgc>
        <post>jump titleset 1 menu;</post>
      </pgc>
    </menus>
  </vmgm>
  <titleset>
    <menus>
      <pgc>
$(for ((i=1; i<=$V_ARRAY_TOTAL; i++)); do
    if $SUB_MENU; then
        JUMP_INC=$(($i + 1))
    else
        JUMP_INC=$i
    fi
    echo -e "        <button name=\"$i\">jump $JUMP $JUMP_INC;</button>"
done)
        <vob file="$MENU_FILE" pause="$PAUSE_TIME"/>
$MAIN_POST
      </pgc>
$(if $SUB_MENU; then
    echo -ne "      <pgc>\n"
        for ((Y=1; Y<=$V_ARRAY_TOTAL; Y++)); do
            for ((i=1; i<=CHAPTERS; i++)); do
                echo -e "        <button name=\"$i\">jump title $Y chapter $i;</button>"
            done
            echo -e "        <vob file=\"$WORK_DIR/Menu$Y.mpg\"$PAUSE/>"
echo "$POST"
            echo "      </pgc>"
            echo "      <pgc>"
        done | sed '$d'
fi)    
    </menus>
    <titles>
$(for i in ${!VID_ARRAY[@]}; do
    echo -e "      <pgc>"
    echo -ne "        <vob file=\"${VID_ARRAY[i]}\""
    echo -e  " chapters=\""${CHAPT_ARRAY[i]}"\"/>"
    echo -e "        <post>call vmgm menu 1;</post>"
    echo -e "      </pgc>"
done)
    </titles>
  </titleset>
</dvdauthor> 
EOF
) |sed '/^$/d' >> "$DVDAUTHOR_XML"
fi
##############################################################################
#                            Animenu stuff                                   #
##############################################################################

# do submenu 1st for debug purposes
if $SUB_MENU; then
    echo $SEPARATOR
    echo "Building submenus"
    echo $SEPARATOR
    echo "Creating images for each chapter"
    for i in ${!VID_ARRAY[@]}; do
        echo
        echo "Creating a transparent title PNG"
        convert -font "$TITLE_FONT" -pointsize $TITLE_FONT_SIZE -size 620x \
        -gravity Center caption:"\"${TITLES[i]}\"" -negate \( +clone -blur 0x8 \
        -shade 110x45 -normalize $GRADIENT -fx 'v.p{g*v.w,0}' \) +matte +swap \
        -compose CopyOpacity -composite  \
        \( +clone -fx A +matte -blur 0x2 -shade 0x90 -normalize \
        -blur 0x2 -negate -evaluate multiply .4 -negate +clone \
        -compose Multiply -composite \) -matte -compose In  -composite miff:- |
        convert -trim +repage - -blur 0.4x0.4 $WORK_DIR/title${i}_txt.png

        # which is harmless as they get removed, but needs to be tweaked         
        if $ANI_SUB_MENU; then
            JPEG2YUV_OPTS=(-n $ANI_SUBMENU_FRAMES)
            PICS_IN=($WORK_DIR/animenu/%0d.$SM_IMG_FMT)
            PICS_OUT=($WORK_DIR/animenu/chapt)
            CUT_TIME=340

        else  # not animated submenu
            JPEG2YUV_OPTS=(-n 1 -l 60)
            PICS_IN=($WORK_DIR/submenu.$SM_IMG_FMT)
            PICS_OUT=($WORK_DIR/chapt)
            CUT_TIME=1
        fi    

        counts=$((${CHAPT_INTERVALS[i]} * 30))
        CUT=( 0 $(running_total <<<  $(for ((a=0; a<CHAPTERS ; a++)); \
        do echo -n "$counts ";done)) )
        for c in ${!CUT[@]}; do
            cmd[c]=$((${CUT[c]}))-$((${CUT[c]} + CUT_TIME))
        done
        key=$((${#cmd[@]} - 1))
        unset cmd[key]
        CMD=${cmd[@]}
        TCODE_CMD=(transcode -q 0 -i "${VID_ARRAY[i]}" -o "${PICS_OUT[@]}" \
        -f $FRAME_RATE -Z ${GEO_ARRAY[CHAPTERS - 1]},fast -J cut="$CMD" -y $SM_IMG_FMT,null)
        printf "%s\n\n" "$LINE" "$LINE" >> $ANIMENU_LOG
        echo "Creating chapter images for "${VID_ARRAY[i]}""

        echo "Running  "${TCODE_CMD[@]}"" >> $ANIMENU_LOG
        echo "Running  "${TCODE_CMD[@]}""
        if "${TCODE_CMD[@]}" >> $ANIMENU_LOG.tmp 2>&1; then
            cleanlog 1
        else
            cleanlog 1
            OUTPUT="There was a problem creating images from the video.\n \
            Please see the output of $ANIMENU_LOG"
            SORRY_MSG=$OUTPUT
            sorry_msg
            exit 1
        fi
        unset TCODE_CMD

        if $ANI_SUB_MENU; then
            # FIXME make sure $CHAPTERS number of images got created
            # move 340 images to each subdir:  $WORK_DIR/animenu/{0,1,2,3,etc}
            for ((a=0; a<CHAPTERS; a++)); do
                pics=( $(find $WORK_DIR/animenu/ -maxdepth 1 -name chapt\*.$SM_IMG_FMT|
                head -n 340) )
                for f in ${pics[@]}; do
                    mv $f $WORK_DIR/animenu/$a
                done
            done
            for ((a=0; a<CHAPTERS; a++)); do
                find $WORK_DIR/animenu/$a/ -name chapt\*.$SM_IMG_FMT|head -n 20|xargs rm
                find $WORK_DIR/animenu/$a/ -name chapt\*.$SM_IMG_FMT|tail -n 20|xargs rm
            done
            echo
            echo "Making montage images for  "${VID_ARRAY[i]}""

            o=1; sp="/-|-\|";  echo -n ' '
            for ((a=1; a<300; a++)); do
                echo -en "\b${sp:o++%${#sp}:1}"
                for ((b=0; b<CHAPTERS; b++)); do
                    IMGS=( "${IMGS[@]}" $(find $WORK_DIR/animenu/$b \
                    -name \*.$SM_IMG_FMT|head -n $a|sed  -n -e "$a p") )
                done
                IM_CMD=(montage ${IMGS[@]} -tile ${TILE_ARRAY[CHAPTERS - 1]} \
                -geometry ${GEO_ARRAY[CHAPTERS - 1]}+5+5 -bordercolor '#161514' \
                -mattecolor '#161514' -background '#161514' miff:-)
                IM_CMD2=(convert $WORK_DIR/submenu_template.jpg \
                $WORK_DIR/title${i}_txt.png  -gravity south \
                -geometry +0+55 -composite -  -gravity north -geometry +0+50 \
                -composite $WORK_DIR/animenu/$a.$SM_IMG_FMT)
 
                "${IM_CMD[@]}" | "${IM_CMD2[@]}"
                unset IMGS
            done

            unset IM_CMD IM_CMD2 d f PIC
 
        else # not $ANI_SUB_MENU

            echo
            echo "Making montage images for  "${VID_ARRAY[i]}""
            # just use $CHAPTERS number of images
            imgs=( $(find $WORK_DIR -name chapt000\*.$SM_IMG_FMT|head -n $CHAPTERS) )
            # create frames for the chapter thumbs
            for PIC in "${imgs[@]}"; do
                echo -en "\b${sp:o++%${#sp}:1}"
                convert -background '#141614' -frame 5x5 \
                -bordercolor none -mattecolor "#444744" "$PIC" miff:- |
                convert -resize "${GEO_ARRAY[CHAPTERS - 1]}"! - "$PIC"
            done
            IM_CMD=(montage "${imgs[@]}" -tile ${TILE_ARRAY[CHAPTERS -1]} -geometry \
            ${GEO_ARRAY[CHAPTERS - 1]}+5+5 -background '#141614' miff:-)
            IM_CMD2=(convert $WORK_DIR/submenu_template.jpg \
            $WORK_DIR/title${i}_txt.png  -gravity south -geometry +0+55 \
            -composite - -gravity north -geometry +0+50 -composite \
            $WORK_DIR/submenu.$SM_IMG_FMT)
            echo "Running "${IM_CMD[@]}" | "${IM_CMD2[@]}""
            "${IM_CMD[@]}" | "${IM_CMD2[@]}"
        fi

        echo
        echo "Converting chapter montages of "${VID_ARRAY[i]}" to m2v video format"
        IMG_STREAM_CMD1=(jpeg2yuv -v 0 -f $FRAME_RATE -I p \
        "${JPEG2YUV_OPTS[@]}" -L 1 -b 1  -j "${PICS_IN[@]}")
        ENC_CMD1=(ffmpeg   -f yuv4mpegpipe -i - -r $FRAME_RATE -s $VIDSIZE \
        -tvstd $TV_STANDARD $FFMPEG_OPTS -y $WORK_DIR/menu$i.m2v)
        echo "Running "${IMG_STREAM_CMD1[@]}" | "${ENC_CMD1[@]}""
        if "${IMG_STREAM_CMD1[@]}" | "${ENC_CMD1[@]}" >> $ANIMENU_LOG.tmp 2>&1; then
            cleanlog 3
        else
            cleanlog 3
            sorry_msg
            exit 1
        fi
        rm -f $WORK_DIR/animenu/*.$IMG_FMT
    done    
    unset ENC_CMD1
    for ((s=0; s<=FILES; s++)); do
        # create audio background for either animated or plain submenus
        echo
        echo "Creating an audio background"
        echo "Working on submenu audio from "${VID_ARRAY[s]}""
        TIME=`vid_length $WORK_DIR/menu$s.m2v`
        OUT_PUT="background audio"
        if "$SUBMENU_AUDIO"; then
            if [ ${SM_AUDIO[s]} = none ]; then
                BGAUDIO_CMD=(ffmpeg -f s16le -i /dev/zero -t $TIME \
                $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT)
            else
            # make seperate wavs for each supplied audio bg for each submenu 
            BGAUDIO_CMD=(ffmpeg -i ${SM_AUDIO[s]} -ar 48000 -ac 2 -acodec pcm_s16le -y \
            $WORK_DIR/menu$s.wav)
            BGAUDIO_CMD2=(ffmpeg -i $WORK_DIR/menu$s.wav \
            $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT)
            fi
        else
            BGAUDIO_CMD=(ffmpeg -f s16le -i /dev/zero -t $TIME \
            $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT)
        fi
        echo "Running "${BGAUDIO_CMD[@]}"" >> "$ANIMENU_LOG.tmp" 2>&1
        cleanlog 1
        if "${BGAUDIO_CMD[@]}" >> "$ANIMENU_LOG.tmp" 2>&1; then
            cleanlog 3
        else
            cleanlog 3
            sorry_msg
            exit 1
        fi
        if "$SUBMENU_AUDIO" && [ ! ${SM_AUDIO[s]} = none ]; then
            echo "Running "${BGAUDIO_CMD2[@]}"" >> "$ANIMENU_LOG.tmp" 2>&1
            cleanlog 1
            if "${BGAUDIO_CMD2[@]}" >> "$ANIMENU_LOG.tmp" 2>&1; then
                cleanlog 3
            else
                cleanlog 3
                sorry_msg
                exit 1
            fi
            unset TIME
        fi
        echo
        echo "Multiplexing video and audio together"
        S=$((s + 1))
        MPLEX_CMD=(mplex -V -f $MPLEX_FORMAT -b 230 -o $WORK_DIR/menu$S.mpg \
        $WORK_DIR/menu$s.$AUDIO_EXT $WORK_DIR/menu$s.m2v)
        echo -e "\nRunning: $MPLEX_CMD\n" >> $ANIMENU_LOG.tmp
        cleanlog 1
        printf "%s\n\n" "$LINE" "$LINE" >> $ANIMENU_LOG
        if "${MPLEX_CMD[@]}" >> $ANIMENU_LOG.tmp 2>&1; then
            cleanlog 1
        else
            cleanlog 1
            sorry_msg
            exit 1
        fi
    done
fi

##############################################################################
#                      Work on main menu                                     #
##############################################################################
echo $SEPARATOR
echo "Building main menu"
echo $SEPARATOR
echo
echo "Adding title to images and resizing"
if $FEATHER; then
    FILL="#161514"
else
    FILL="#C6C6C6"
fi
for ((i=0; i<=FILES; i++)); do
    PICS=( "${PICS[@]}" \
    $(find $WORK_DIR/pics/$i -maxdepth 1 -name \*[1-9]\*.$IMG_FMT) )
    echo "Working on images from ${VID_ARRAY[i]}"
    o=1; sp="/-|-\|";  echo -n ' '

    for pic in "${PICS[@]}"; do
        echo -en "\b${sp:o++%${#sp}:1}"
        IM_CMD0=(composite -compose CopyOpacity $THUMB_MASK +matte \
        "$pic")
        IM_CMD1=(convert -trim +repage -)
        IM_CMD2=(montage -  -geometry +4+4 -compose Copy -background none \
        -fill "$FILL" -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE -title "${TITLES[i]}")

        IM_CMD2b=(convert -resize $INTRO_SIZE! -)
        IM_CMD2c=(composite -gravity center -compose DstOver $WORK_DIR/feather_mask2.png -) 
        
        IM_CMD3=(montage -geometry +4+4 -background '#161514' \
        -fill '#C6C6C6' -pointsize $THUMB_FONTSIZE -title "${TITLES[i]}" "$pic")
        IM_CMD4=(convert -background '#161514' -frame 5x5 \
        -bordercolor none -mattecolor "#444744" -)
        IM_CMD5=(convert -resize $INTRO_SIZE! - $pic)
        if $FEATHER; then
#            "${IM_CMD0[@]}" miff:- | "${IM_CMD2[@]}" miff:- | "${IM_CMD1[@]}" miff:- |
            "${IM_CMD0[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
            "${IM_CMD2b[@]}" miff:- |"${IM_CMD2c[@]}" miff:- |
            "${IM_CMD1[@]}" miff:- | "${IM_CMD5[@]}"
        else
            "${IM_CMD3[@]}" miff:- | "${IM_CMD4[@]}" miff:- | "${IM_CMD5[@]}"
        fi
        unset PICS IM_CMD0 IM_CMD1 IM_CMD2 IM_CMD3 IM_CMD4 IM_CMD5
    done

    # make sure all animated thumbs finish at the same time 
    if ! $STATIC; then
        IMAGES=( "${IMAGES[@]}" \
        $(find $WORK_DIR/pics/$i -maxdepth 1 -name \*[1-9]\*.$IMG_FMT) )
        last_pic=${#IMAGES[@]}
        next_pic=$(($last_pic + 1))
        if [ $last_pic -lt $MAX_ANI_LENGTH ]; then
            for ((l=next_pic; l<=MAX_ANI_LENGTH; l++)); do
                cp $WORK_DIR/pics/$i/${last_pic}.$IMG_FMT $WORK_DIR/pics/$i/$l.$IMG_FMT
            done
        fi
        unset IMAGES PICS last_pic next_pic
   fi
done

if [ -n "$ANI_BG" ]; then
    # extract images from the provided video
    echo "ANI_BG is $ANI_BG"
    FFMPEG_CMD=(ffmpeg -i "$ANI_BG" $SEEK -vframes $FRAMES \
    -s "$VIDSIZE" "$WORK_DIR/bg/%d.jpg")
    printf "%s\n\n" "$LINE" "$LINE" >> $ANIMENU_LOG
    echo -e "\nRunning: ${FFMPEG_CMD[@]}\n" | fold -bs >> $ANIMENU_LOG
    if "${FFMPEG_CMD[@]}" >> $ANIMENU_LOG.tmp 2>&1; then
        cleanlog 3
    else
        cleanlog 3
        OUTPUT="the images from the background video"
        sorry_msg
        exit 1
    fi
fi
unset FFMPEG_CMD
if "$MENU_FADE" && ! "$STATIC"; then
    echo
    echo "making final montages and compositing onto background with title"
    if [ -z "$ANI_BG" ]; then
        for ((frame=0; frame<=ANI_MENU_END_FRAME; frame++)); do
            # copy template for fade out beginning and end frames
            cp $WORK_DIR/pics/template.jpg $WORK_DIR/bg/$(($frame + 1)).jpg
        done
    fi      
    for ((frame=0; frame<=BACKGROUND_FADE_IN_END_FRAME; frame++)); do
        D=`get_bg_opacity`
        composite -dissolve $D $WORK_DIR/bg/$(($frame + 1)).jpg $WORK_DIR/black.jpg \
        $WORK_DIR/bg/$(($frame + 1)).jpg
    done
    for ((frame=BACKGROUND_FADE_OUT_START_FRAME; frame<=BACKGROUND_FADE_OUT_END_FRAME; frame++)); do
        D=`get_bg_opacity`
        composite -dissolve $D $WORK_DIR/bg/$(($frame + 1)).jpg $WORK_DIR/black.jpg \
        $WORK_DIR/bg/$(($frame + 1)).jpg
    done

    o=1; sp="/-|-\|";  echo -n ' '  # initialize spinner
    for ((frame=0; frame<ANI_MENU_END_FRAME; frame++)); do
        # set dissolve vars from animenu-fade-routine functions
        BC=$(get_title_opacity)
        B=$(awk -F ':' '{print $1'}<<<$BC)
        C=$(awk -F ':' '{print $2'}<<<$BC)
        S=$(get_thumb_opacity)

        echo -en "\b${sp:o++%${#sp}:1}" # start spinner

        ANI_PICS=( $(find $WORK_DIR/pics/*[0-9]* -maxdepth 1 -name $((frame + 1)).$IMG_FMT) )
        BG_PIC=$(find $WORK_DIR/bg -name $(($frame + 1)).jpg)
        # create the montage from the images in each video dir
        MONTAGE_CMD1=(montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[FILES]} \
        -geometry ${GEO_ARRAY[FILES]}+5+5 -background none)
        #  dissolve the finished montages onto the background
        MONTAGE_CMD2=(composite -dissolve $S -gravity north \
        -geometry +0+50 - $WORK_DIR/bg/$(($frame + 1)).jpg -background none)
        # if MIST is called for, this dissolves the mist onto the background
        MONTAGE_CMD3=(composite -dissolve $B -gravity south -geometry +0+45 \
        $WORK_DIR/white.png -)
        # finally, we dissolve the title onto the MIST (or plain background)
        MONTAGE_CMD4=(composite -dissolve $C -gravity south -geometry +0+55 \
        $WORK_DIR/title_txt.png - -background none $WORK_DIR/animenu/$(($frame + 1)).jpg)
        # pipe all of above commands if using MIST
        if $MIST; then
            # debug echo only
#            echo "Running "${MONTAGE_CMD1[@]}" miff:- | "${MONTAGE_CMD2[@]}" miff:- |"
#            echo  ""${MONTAGE_CMD3[@]}" miff:- | "${MONTAGE_CMD4[@]}""
            "${MONTAGE_CMD1[@]}" miff:- | "${MONTAGE_CMD2[@]}" miff:- |
            "${MONTAGE_CMD3[@]}" miff:- | "${MONTAGE_CMD4[@]}"
        else  # no mist: pipe all commands but the mist command
             "${MONTAGE_CMD1[@]}" miff:- | "${MONTAGE_CMD2[@]}" miff:- |
            "${MONTAGE_CMD4[@]}"
        fi
    done
# copy a few black frames to make sure end frame is really "black"
    for ((i=ANI_MENU_END_FRAME; i<ANI_MENU_END_FRAME+6; i++)); do
        cp $WORK_DIR/black.jpg $WORK_DIR/animenu/$i.jpg
    done
else # Don't do menu fade
    if $TRANSPARENT; then
         o=1; sp="/-|-\|";  echo -n ' '  # initialize spinner
         for (( count=1; count<=$MAX_ANI_LENGTH; count++)); do
            echo -en "\b${sp:o++%${#sp}:1}"
            ANI_PICS=$(find $WORK_DIR/pics/*[0-9]* -maxdepth 1 -name $count.$IMG_FMT)
            IM_CMD1=(montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[FILES]} \
            -geometry ${GEO_ARRAY[FILES]}+5+5 -background none miff:-)
            IM_CMD2=(composite -dissolve $DISSOLVE \
            -gravity north -geometry +0+50 - \
            $WORK_DIR/pics/template.jpg -background none miff:-)
            IM_CMD3=(composite -dissolve 30 -gravity south -geometry +0+45 \
            $WORK_DIR/white.png - miff:-)
            IM_CMD4=(convert - $WORK_DIR/title_txt.png  \
            -gravity south -geometry +0+55 -composite \
            $WORK_DIR/animenu/$count.jpg )
            if $MIST; then
                "${IM_CMD1[@]}" | "${IM_CMD2[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
            else
                "${IM_CMD1[@]}" | "${IM_CMD2[@]}" | "${IM_CMD4[@]}"
            fi
            rm -f ${ANI_PICS[@]}
        done
    else # Not transparent
        echo
        echo "making final montages and compositing onto background with title"
        o=1; sp="/-|-\|";  echo -n ' '  # initialize spinner
        for (( count=1; count <=FRAMES; count++)); do
            echo -en "\b${sp:o++%${#sp}:1}"
            ANI_PICS=$(find $WORK_DIR/pics/*[0-9]* -maxdepth 1 -name $count.$IMG_FMT)

            # make final montages and composite onto grey background with title
            IM_CMD0=(montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[FILES]} \
            -geometry ${GEO_ARRAY[FILES]}+5+5 -background none miff:-)
            IM_CMD1=(convert $WORK_DIR/pics/template.jpg \
            -  -gravity north -geometry +0+50 -composite miff:-)
            IM_CMD2=(convert $WORK_DIR/bg/$count.jpg \
            -  -gravity north -geometry +0+50 -composite miff:-)
            IM_CMD3=(composite -dissolve 30 -gravity south -geometry +0+45 \
            $WORK_DIR/white.png - miff:-)
            IM_CMD4=(convert - $WORK_DIR/title_txt.png  \
            -gravity south -geometry +0+55 -composite \
            $WORK_DIR/animenu/$count.jpg )
            if $MIST && ! $STATIC; then
                "${IM_CMD0[@]}" | "${IM_CMD2[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
            elif "$MIST" && "$STATIC"; then
                "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
            elif ! "$MIST" && "$STATIC"; then
                "${IM_CMD0[@]}" | "${IM_CMD1[@]}" |  "${IM_CMD4[@]}"   
            else
                "${IM_CMD0[@]}" | "${IM_CMD2[@]}" | "${IM_CMD4[@]}"
            fi
            rm -f ${ANI_PICS[@]}
        done
    fi    
fi

echo
echo "Converting images to video stream and encoding to DVD-compliant format"
# convert images to video stream and encode to dvd compliant m2v
if $STATIC; then
    JPEG2YUV_OPTS=(-n 1 -l 60)
    PICS_IN="$WORK_DIR/animenu/1.jpg"
else  # animated menu
    if $MENU_FADE; then
        JPEG2YUV_OPTS="-n $((ANI_MENU_END_FRAME + 6))"
    else
        JPEG2YUV_OPTS="-n $ANI_FRAMES"
    fi
    PICS_IN="$WORK_DIR/animenu/%d.jpg"
fi
ENC_CMD1=(jpeg2yuv -v 0 -f $FRAME_RATE -I p "${JPEG2YUV_OPTS[@]}" -L 1 -b1 \
-j "$PICS_IN")
ENC_CMD2=(ffmpeg   -f yuv4mpegpipe -i - -an -r $FRAME_RATE -s $VIDSIZE \
-tvstd $TV_STANDARD $FFMPEG_OPTS -y $WORK_DIR/intro.m2v)
printf "%s\n\n" "$LINE" "$LINE" >> $ANIMENU_LOG
echo "Running "${ENC_CMD1[@]}" | "${ENC_CMD2[@]}""
if "${ENC_CMD1[@]}" | "${ENC_CMD2[@]}" >> $ANIMENU_LOG.tmp 2>&1; then
    cleanlog 3
else
    cleanlog 3
    sorry_msg
    exit 1
fi
echo
echo "Cleaning up montage images"
rm -fr $WORK_DIR/animenu/*.jpg

# create audio background for the main menu
OUTPUT="main menu background audio"
TIME=`vid_length "$WORK_DIR/intro.m2v"`

if [ -z "$BG_AUDIO" ]; then # if no audio supplied, then use silence
    cat /dev/zero | nice -n 0 sox -t raw -c 2 -r 48000 -w \
    -s - $WORK_DIR/intro.wav  trim 0 $TIME
else # convert the supplied background audio to wav then dvd/svcd format
    BGAUDIO_CMD=(ffmpeg -i "$BG_AUDIO" -ar 48000 -ac 2 -acodec pcm_s16le -y \
    -t $TIME $WORK_DIR/intro.wav)
    if "${BGAUDIO_CMD[@]}" >> $ANIMENU_LOG.tmp 2>&1; then
        cleanlog 3
    else
        cleanlog 3
        sorry_msg
        exit 1
    fi
fi

unset BGAUDIO_CMD
if $AUDIO_FADE; then
    echo -e "Running:
    sox $WORK_DIR/intro.wav \
    $WORK_DIR/intro-processed.wav fade t 0 $TIME $FADE"

    sox $WORK_DIR/intro.wav \
    $WORK_DIR/intro-processed.wav fade t 0 $TIME $FADE
    rm $WORK_DIR/intro.wav
    mv $WORK_DIR/intro-processed.wav $WORK_DIR/intro.wav
fi

unset TIME

# convert to proper audio format
BGAUDIO_CMD=(ffmpeg -i $WORK_DIR/intro.wav \
$AUDIO_OPTS -y $WORK_DIR/intro.$AUDIO_EXT)
if "${BGAUDIO_CMD[@]}" >> $ANIMENU_LOG.tmp 2>&1; then
    cleanlog 3
    else
    cleanlog 3
    sorry_msg
    exit 1
fi
unset BGAUDIO_CMD

echo
echo "Multiplexing main menu audio and video together"
# mplex main menu audio and video together
INTRO_MPLEX_CMD="mplex -V -f $MPLEX_FORMAT -b 230 -o $WORK_DIR/intro.mpg \
$WORK_DIR/intro.$AUDIO_EXT $WORK_DIR/intro.m2v"
echo -e "\nRunning: $INTRO_MPLEX_CMD\n" >> $ANIMENU_LOG.tmp 
cleanlog 1
printf "%s\n\n" "$LINE" "$LINE" >> $ANIMENU_LOG
if ${INTRO_MPLEX_CMD[@]} >> $ANIMENU_LOG.tmp 2>&1; then
    cleanlog 1
else
    cleanlog 1
    sorry_msg
    exit 1
fi

echo
echo "Running spumux to create the main menu"
spumux "$SPUMUX_XML" < $WORK_DIR/intro.mpg > "$MENU_FILE"
if test -f "$MENU_FILE"; then
    echo "Menu file $MENU_FILE created"
else
    echo "Menu file $MENU_FILE is missing!"
fi

if $SUB_MENU; then
    echo "Creating submenus"
    for i in $(find $WORK_DIR/ -name menu[0-9]\*.mpg); do
#        spumux "$SUBMENU_SPUMUX_XML" < $i > ${i/menu/Menu}
        spumux "$SUBMENU_SPUMUX_XML" < $i > $(echo $i|sed 's/\(.*\)menu/\1Menu/')
    done
fi

echo "Running dvdauthor to create the DVD filesystem"
dvdauthor -x "$DVDAUTHOR_XML"

SCRIPT_END_TIME=`date +%s`
SCRIPT_TOT_TIME=`expr $SCRIPT_END_TIME \- $SCRIPT_START_TIME`
HHMMSS=`format_time $SCRIPT_TOT_TIME`

cleanup
echo $SEPARATOR
echo "animenu took $HHMMSS to finish on $CPU_MODEL $CPU_SPEED mhz"
echo $SEPARATOR
echo "Your new DVD should be in $OUT_DIR"
echo
echo "Thanks for using animenu."

