#!/bin/bash
ME="[animenu]:"
. tovid-init

###############################################################################
# an example script to test montage method of dvd menu animation              #
#                                                                             #
#                                                                             #
# by Robert Sohn <grepper@gmail.com> (grepper on irc.freenode.net)            #
#                                                                             #
# usage: montage_animenu.sh <mpeg-2 file1> <mpeg-2 file2> "title1" "title2".. #
#                                                                             #
###############################################################################

SCRIPT_NAME=`cat << EOF
--------------------------------
animenu
A script to generate animated DVD/(S)VCD menus
Part of the tovid suite, version $TOVID_VERSION
$BUILD_OPTIONS
$TOVID_HOME_PAGE
--------------------------------
EOF`

USAGE=`cat << EOF
Usage: animenu -files File1.mpg File2.mpg ... -titles "Title 1" "Title 2" ...

The number of -files and -titles must be equal.

Options:

-submenus         Create a submenu with chapters for each video. 
-ani-submenus     Create an animated submenu with chapters for each video
-menu-title       Title for the root menu - may be longer than thumbnail labels
-framefont        Font to use for titles: use for example either: "Arial" , or
                  "/full/path/to/arial.ttf" (default: imagemagick default font)
-framefont-size   Font size for main menu - best to -preview if you use this.
-menu-bg          Menu background image - pick on of correct aspect ration: ie.
                  it should still look good when resize to 720x480 (pal: 720x576)
-ani-menu-bg      Menu background video - again, needs to be resize to 720x480 or
                  720x576, so pick one of appropriate aspect ratio/resolution
-menu-fade        Fade the menu into the provided background image
                  Do not use this for dark backgrounds like the default gray/black
-transparency     The amount of transparency for the menu (0 -> 100):
                  Lower values are more transparent, ie. less visable menu.. 
                  Use keyword:  none   , for no transparency
                  (only needed with -menu-fade or -menu-bg)
-menu-audio       An audio file for the main menu background
-menu-audio-fade  Number of sec to fade given menu audio out (default: no fade)
-submenu-audio #  (not implemented yet) List of files for submenu backgrounds:
                  must equal the number of chapters (default: 6 chapters)
-chapters         The number of submenu chapters for each video (default: 6)
-preview          display a preview of the menu with selected options and exit
-seek             For main menu only - seek to N seconds before generating jpegs
EOF`

# Print script name, usage notes, and optional error message, then exit.
# Args: $@ == text string containing error message
usage_error ()
{
    printf "%s\n" "$USAGE"
    printf "%s\n" "$SEPARATOR"
    printf "*** %s\n" "$@"
    exit 1
}

WORK_DIR=$HOME/tmp/BVC
BVC_LOG=$WORK_DIR/BVC.log
MAX_ANI_LENGTH=600
TARGET=DVD
LINE=$(for ((i=1; i<=79; i++));do echo -n =;done)
VID_SIZE_OPT=720x480
VMGM_TITLE="My Video Collection"
SPUMUX_XML=$WORK_DIR/spumux.xml
SUBMENU_SPUMUX_XML=$WORK_DIR/submenu_spumux.xml
DVDAUTHOR_XML=$WORK_DIR/dvdauthor.xml
GRADIENT="$WORK_DIR/aqua_gradient.png"
SUB_MENU="false" 
ANI_SUB_MENU="false"
CHAPTERS=6
FRAME_FONT=""
BG_AUDIO=""
SM_AUDIO=""
AUDIO_FADE="false"
DISSOLVE=100
MENU_FADE="false"
TRANSPARENT="false"
PREVIEW="false"
PAUSE_TIME=6
BLACKEN="true"

SCRIPT_START_TIME=`date +%s`

##############################################################################
#                                 Functions                                  #
##############################################################################

function cleanlog()
# process $BVC_LOG.tmp variously - eg. ffmpeg's output is ugly without this
{
    FOLD="fold -bs"
    NO_CR="tr -d '\r'"
    RELINE="{s/$SED_VAR/\n$SED_VAR/g}"
    TMP_LOG="$BVC_LOG.tmp"
    NOSPACE="tr -s ' '"

    case "$1" in
        1 )
            $FOLD $TMP_LOG >> $BVC_LOG
            echo >> $BVC_LOG
            ;;
        2 )
            $NO_CR < $TMP_LOG | $FOLD >> $BVC_LOG
            echo >> $BVC_LOG
            ;;
        3 )
            $NO_CR < $TMP_LOG | sed $RELINE | $FOLD >> $BVC_LOG
            echo >> $BVC_LOG
            ;;
        4 )
            $NOSPACE < $TMP_LOG | $FOLD >> $BVC_LOG
            ;;
    esac
    rm -f $BVC_LOG.tmp
}

function sorry_msg()
{
    echo -e "Oops . . .Something went wrong.\nThere was a problem \
creating the $OUTPUT. \
\nPlease check the log at $BVC_LOG"
}

function vid_length()
{
mencoder "$1" -quiet -ovc copy -oac pcm -o /dev/null |
awk '/Video stream/ {print $10}'
}

function cleanup()
{
    # does nothing atm
    exit 1
}

function running_total ()
{
    awk '{
for (i=1; i<=NF; i++) if (s=s+$i) printf("%s ",s);printf ("\n")}'
}

function format_seconds()
{
awk '{
hr=($1/3600); hd=(sprintf("%02d", hr))
mr=((hr-hd)*60); md=(sprintf("%02d", mr))
s=((mr-md)*60); sd=(sprintf("%02d", s))
t=(sprintf("%02d:%02d:%06.3f" ,hd,md,s)); print t}' <<< $1
}


##############################################################################
#                          	End of functions                                 #
##############################################################################

trap cleanup 0 2 15

###############################################################################
#       Process arguments to the script, set up VARS and WORK_DIR             #
###############################################################################

# ***********************************
# EXECUTION BEGINS HERE
# ***********************************

echo $"$SCRIPT_NAME"

while test $# -gt 0; do
    DO_SHIFT=:
    case "$1" in
        "-files" )
            shift
            # Hackish list-parsing
            while test $# -gt 0 && test ${1:0:1} != "-"; do
                VIDS=( "${VIDS[@]}" "$1" )
                shift
            done
            # Don't skip past the next argument
            if test $# -gt 0 && test ${1:0:1} = "-"; then DO_SHIFT=false; fi
            ;;
        "-titles" )
            shift
            # Hackish list-parsing
            while test $# -gt 0 && test ${1:0:1} != "-"; do
                TITLES=( "${TITLES[@]}" "$1" )
                shift
            done
            # Don't skip past the next argument
            if test $# -gt 0 && test ${1:0:1} = "-"; then DO_SHIFT=false; fi
            ;;
        "-menu-bg" )
            shift
            BG_PIC="$(abspath "$1")"
            BLACKEN="false"
            ;;
        "-menu-fade" )
            MENU_FADE="true"
            ;;
        "-ani-menu-bg" )
            shift
            ANI_BG="$(abspath "$1")"
            ;;
        "-transparency" )
            shift
            if [ $1 = "none" ]; then
                TRANSPARENT="false"
            else
                TRANSPARENT="true"
                DISSOLVE="$1"
            fi
            ;;
        "-submenu-audio" )
            shift
            # Hackish list-parsing
            while test $# -gt 0 && test ${1:0:1} != "-"; do
                SM_AUDIO=( "${SM_AUDIO[@]}" "$1" )
                shift
            done
            # Don't skip past the next argument
            if test $# -gt 0 && test ${1:0:1} = "-"; then DO_SHIFT=false; fi
            ;;
        "-chapters" )
            shift
            CHAPTERS="$1"
            ;;
        "-menu-audio" )
            shift
            BG_AUDIO="$(abspath "$1")"
            ;;
        "-menu-audio-fade" )
            shift
            FADE="$1"
            AUDIO_FADE="true"
            ;;
        "-submenus" )
            SUB_MENU="true"
            ;;
        "-ani-submenus" )
            ANI_SUB_MENU="true"
            SUB_MENU="true"
            ;;
        "-menu-title" )
            shift
            VMGM_TITLE="$1"
            ;;
        "-framefont" )
            shift
            FRAME_FONT="$1" #FIXME should use abspath if ends with an extension .*
            ;;
        "-framefont-size" )
            shift
            TITLE_FONT_SIZE="$1"
            ;;
        "-preview" )
            PREVIEW="true"
            ;;
        "-seek" )
            shift
            SEEK="$1"
            SEEK="-ss $SEEK"
            ;;
    esac
    $DO_SHIFT && shift
done
# Make sure equal, nonzero number of titles and files were provided
if test ${#VIDS[@]} -eq 0 || test ${#TITLES[@]} -eq 0; then
    usage_error "Please provide at least one file and one title."
elif test ${#VIDS[@]} -ne ${#TITLES[@]}; then
    usage_error "Please give the same number of files as titles."
fi

# create a user's tmp dir if it doesn't exist
# if it exists, move it to a new name
if [ -d $WORK_DIR ]; then
    mv  $WORK_DIR $WORK_DIR-`date "+%s"`
    echo
    echo -e "Moving $WORK_DIR to $WORK_DIR-`date "+%s"`"
    mkdir -pv $WORK_DIR
    else
    mkdir -pv  $WORK_DIR
fi

# Try to find a default font that is available
if [ -z "$FRAME_FONT" ]; then
    if convert -size 50x20 xc:none -font Helvetica -gravity Center \
    -draw "text 0,0 'test'" $WORK_DIR/font.png; then
        FRAME_FONT="Helvetica"
    elif convert -size 200x100 xc:none -font helvetica -gravity Center \
    -draw "text 0,0 'test'" $WORK_DIR/font.png; then
        FRAME_FONT="helvetica"
    fi
fi
rm -f $WORK_DIR/font.png

for i in "${VIDS[@]}"; do
    VID_ARRAY=( "${VID_ARRAY[@]}" "$(abspath "$i")" )
done

# do everything in $WORK_DIR
cd $WORK_DIR


# make sure titles have no more than 12 characters
for ((i=0; i<${#TITLES[@]}; i++)); do
    val=${#TITLES[i]}
    [ -z "$MAX_VAL" ] || ((val > MAX_VAL)) && MAX_VAL=$val && key=$i
done

if [ $MAX_VAL -gt 14 ]; then
    echo -e "Sorry, the maximum number of characters you can use for a title is 14"
    echo -e "The title \"${TITLES[key]}\" is too long"
    exit 1
fi

SVCD_VID_SIZE_OPT="480x480"
DVD_VID_SIZE_OPT="720x480"
DVD_AUDIO_EXT=ac3
SVCD_AUDIO_EXT=mp2
DVD_SAMPLERATE="48000"
SVCD_SAMPLERATE="44100"
DVD_AUDIO_OPTS="-ab 224 -ar 48000 -ac 2 -acodec $DVD_AUDIO_EXT"
SVCD_AUDIO_OPTS="-ab 224 -ar 44100 -ac 2 -acodec $SVCD_AUDIO_EXT"
SVCD_FFMPEG_TARGET="ntsc-svcd"
DVD_FFMPEG_TARGET="ntsc-dvd"
SVCD_FFMPEG_OPTS="-b 2200 -minrate 2200 -maxrate 2200 -bufsize 230 -aspect 4:3"
DVD_FFMPEG_OPTS="-b 8000  -maxrate 9000 -bufsize 230  -aspect 4:3"
SVCD_INTRO_SIZE="240x240"
DVD_INTRO_SIZE="360x240"
SVCD_MPLEX_FORMAT=4
DVD_MPLEX_FORMAT=8
SVCD_TITLE_FONT_SIZE=32
DVD_TITLE_FONT_SIZE=42
# PTSIZE=(30 36 42 42 42 42 48 48 48 48 48 48 54 54 54 54 54 54 54 54 \
# 54 54 54 54 54 54 54 54 54 54)
DVD_GEO_ARRAY=(360x240 270x180 192x128 192x128 180x120 180x120 120x80 120x80 \
144x96 120x80 120x80 120x80 96x64 96x64 96x64 96x64 96x64 96x64 96x64 96x64 \
72x48 72x48 72x48 72x48 72x48 72x48 72x48 72x48 72x48 72x48)
SVCD_GEO_ARRAY=(240x240 180x180 120x120 120x120 120x120 120x120 96x96 96x96 \
96x96 80x80 80x80 80x80 64x64 64x64 64x64 64x64 64x64 64x64 64x64 64x64 \
48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48)
TILE_ARRAY=(1x1 2x1 2x2 2x2 3x2 3x2 3x3 3x3 3x3 4x3 4x3 4x3 4x4 4x4 4x4
4x4 5x4 5x4 5x4 5x4 5x5 5x5 5x5 5x5 5x5 6x5 6x5 6x5 6x5 6x5)

V_ARRAY_TOTAL=${#VID_ARRAY[@]}
A_ARRAY_TOTAL=${#TITLES[@]}
FILES=$(($V_ARRAY_TOTAL - 1))

# set up our log file
PATTERN=$(for ((i=1; i<=79; i++)); do echo -n \*; done)
printf "%s\n%s\n%s\n\n\n" "$PATTERN" \
"tovid suite's animenu - log for `date`" \
"$PATTERN" >> $BVC_LOG

# create_dirs
echo
echo "Creating pics directories..."
for ((i=0; i<=FILES; i++)) ; do mkdir -pv  $WORK_DIR/pics/$i; done
mkdir -v $WORK_DIR/animenu
if [ $ANI_SUB_MENU = true ]; then
    for ((i=0; i<CHAPTERS; i++)); do
        mkdir -v $WORK_DIR/animenu/$i
    done
fi

echo
echo -e "Videos to be processed"
for vid in "${VID_ARRAY[@]}"; do echo "$vid";done
echo  
if  [ $TARGET = "DVD" ]; then
    VID_SIZE_OPT=$DVD_VID_SIZE_OPT
    AUDIO_OPTS=$DVD_AUDIO_OPTS
    SAMPLERATE=$DVD_SAMPLERATE
    AUDIO_EXT=$DVD_AUDIO_EXT
    FFMPEG_TARGET=$DVD_FFMPEG_TARGET
    INTRO_SIZE=$DVD_INTRO_SIZE
    FFMPEG_OPTS=$DVD_FFMPEG_OPTS
    MPLEX_FORMAT=$DVD_MPLEX_FORMAT
    GEO_ARRAY=("${DVD_GEO_ARRAY[@]}")
    if [ -z $TITLE_FONT_SIZE ]; then
        TITLE_FONT_SIZE=$DVD_TITLE_FONT_SIZE
    else
        TITLE_FONT_SIZE=$TITLE_FONT_SIZE
    fi
fi
###############################################################################
#      if preview is selected, generate a basic preview of the main menu      #
###############################################################################
if [ $PREVIEW = "true" ]; then
    if [ -z "$BG_PIC" ]; then
    echo
    echo "Creating a black background"
        BG_PIC="$WORK_DIR/pics/template.jpg"
        convert  -resize $VID_SIZE_OPT! xc:"#161514" "$BG_PIC"
    else
        convert -resize $VID_SIZE_OPT! "$BG_PIC" "$WORK_DIR/pics/template.jpg"
    fi

    convert -size 1x512 gradient: -rotate 90 +matte \
    -fx '3.5u^3 - 5.05u^2 + 2.05u + 0.3' \
    -size 512x1 xc:"#08447B" -compose Overlay -composite "$GRADIENT"
    echo "Creating a transparant png with the title on it"

    convert -font "$FRAME_FONT" -pointsize $TITLE_FONT_SIZE -size 620x \
    -gravity Center caption:"\"$VMGM_TITLE\""  -negate  \( +clone -blur 0x8 \
    -shade 110x45 -normalize \
    $GRADIENT  -fx 'v.p{g*v.w,0}' \)  +matte +swap \
    -compose CopyOpacity -composite  \
    \( +clone -fx A +matte -blur 0x2 -shade 0x90 -normalize -blur 0x2 -negate \
    -evaluate multiply .4 -negate +clone  -compose Multiply -composite \) \
    -matte  -compose In  -composite $WORK_DIR/intro_txt.png

    for ((i=0; i<=FILES; i++)) ; do
        ffmpeg -i "${VID_ARRAY[$i]}" $SEEK -vframes 1 -s 360x240 $WORK_DIR/${i}-preview%d.jpg
    done
    JPGS=( "${JPGS[@]}" \
    $(find $WORK_DIR/ -maxdepth 1 -name '*preview*.jpg') )
    for i in "${!JPGS[@]}"; do
        montage "${JPGS[i]}" -geometry +4+4 -bordercolor none -compose Copy  -background none \
        -fill '#C6C6C6' -pointsize 22 -title "${TITLES[i]}"  $jpg miff:- |
        convert -background none -frame 8x8 \
        -bordercolor none -mattecolor "#444744" - miff:- |
        convert -resize $INTRO_SIZE! - "${JPGS[i]}"
    done
    if [ $TRANSPARENT = "false" ]; then
        montage ${JPGS[@]} -tile ${TILE_ARRAY[FILES]} \
        -geometry ${GEO_ARRAY[FILES]}+5+5 -background none miff:- |
        convert $WORK_DIR/pics/template.jpg \
        $WORK_DIR/intro_txt.png  -gravity south -geometry +0+55 -composite \
        -  -gravity north -geometry +0+55 -composite \
        $WORK_DIR/example.jpg
        display $WORK_DIR/example.jpg
        echo
        echo -e "If you are happy with your preview, please proceed" 
        echo "without the -preview option"
        exit 1
    elif [ $TRANSPARENT = "true" ]; then
        montage ${JPGS[@]} -tile ${TILE_ARRAY[FILES]} \
        -geometry ${GEO_ARRAY[FILES]}+5+5 -background none miff:- |
        composite -dissolve $DISSOLVE \
        -gravity north -geometry +0+55 - \
        $WORK_DIR/pics/template.jpg -background none miff:- |
        convert - $WORK_DIR/intro_txt.png  \
        -gravity south -geometry +0+55 -composite \
        $WORK_DIR/example.jpg
        display $WORK_DIR/example.jpg
        echo
        echo -e "If you are happy with your preview, please proceed" 
        echo "without the -preview option"
        exit 1 
    fi
fi

###############################################################################
#             get information about videos and store in an array              #
###############################################################################

for i in ${!VID_ARRAY[@]}; do
    mencoder_stats=( "${mencoder_stats[@]}" \
    "$(mencoder -quiet "${VID_ARRAY[i]}" -oac pcm -ovc copy -o /dev/null)" )
done
echo
echo $SEPARATOR
echo
# put in the log file in case anyone is interested
for i in ${!VID_ARRAY[@]}; do
    VCODEC="$(awk '/VIDEO:/ {gsub(/\[|\]/, ""); print $2}' \
    <<< "${mencoder_stats[i]}")"
    V_BR="$(awk '/Video stream:/{print $3}'<<<"${mencoder_stats[i]}")"
    ACODEC="$(awk  '/Selected audio codec/ {gsub(/\[|\]/, ""); print $4}' \
    <<< "${mencoder_stats[0]}")"
    A_BR="$(awk  '/AUDIO:/ {print $7}' <<< "${mencoder_stats[i]}")"
    if [ -z "$A_BR" ]; then
        A_BR="No audio found"
    fi
    V_LENGTH="$(awk '/Video stream:/{print $10}'<<<"${mencoder_stats[i]}")"
    FPS="$(awk '/VIDEO:/ {print $6}' <<<"${mencoder_stats[i]}")"
    printf "%s\n\n" "$LINE" "$LINE" >> $BVC_LOG
    echo -e "Stats for" "${VID_ARRAY[i]}" "\n" \
    "video codec:   " \
    "$VCODEC" "\n" \
    "video bitrate: " "$V_BR" "kbps" "\n" \
    "framerate:     " "$FPS" "fps" "\n" \
    "audio codec:   " \
    "$ACODEC" "\n" \
    "audio bitrate: " \
    "$A_BR" " kbps" "\n" \
    "video length:  " \
    "$V_LENGTH" " seconds" "\n" |tee -a $BVC_LOG
done
echo
echo $SEPARATOR

for i in ${!mencoder_stats[@]}; do
    VID_LEN=( ${VID_LEN[@]}  "$(awk '/Video stream:/{print $10}' \
    <<<"${mencoder_stats[i]}")" )
done

for i in ${!VID_LEN[@]}; do
    NEW_LENGTH=( ${NEW_LENGTH[@]}   ${VID_LEN[i]%.*} )
done
for val in ${NEW_LENGTH[@]}; do
    [ -z "$MAX_VAL" ] || ((val > MAX_VAL)) && MAX_VAL=$val
done

MAX_VAL_FRAMES="$(($MAX_VAL * 30))"
if [ $MAX_VAL_FRAMES -lt $MAX_ANI_LENGTH ]; then
    MAX_ANI_LENGTH=$MAX_VAL_FRAMES
fi

ANI_FRAMES=$MAX_ANI_LENGTH

###############################################################################
#                           End of info block                                 #
###############################################################################

###############################################################################
#                       work on the clip title images                         #
###############################################################################

# create the pics for background image and move to proper pics/ dir
echo
echo "Creating JPEGs from each video for the main menu"
for ((i=0; i<=FILES; i++)) ; do
#    CREATE_JPG_CMD=(transcode -q 0 -i ${VID_ARRAY[i]} \
#    -c 90-$(($MAX_ANI_LENGTH + 90))
#    -o $WORK_DIR/pics/$i/pic -f 29.970  -j 72,72 -Z "$INTRO_SIZE" -y jpg,null)

    CREATE_JPG_CMD=(ffmpeg -i "${VID_ARRAY[$i]}"  $SEEK -vframes $ANI_FRAMES \
    -s "$INTRO_SIZE" "$WORK_DIR/pics/$i/%d.jpg")
    printf "%s\n\n" "$LINE" "$LINE" >> $BVC_LOG
    echo -e "\nRunning: ${CREATE_JPG_CMD[@]}\n" | fold -bs >> $BVC_LOG

    SED_VAR="frame="
    if "${CREATE_JPG_CMD[@]}" >> $BVC_LOG.tmp 2>&1;then
        cleanlog 3
    else
        cleanlog 3
        OUTPUT="There was a problem creating jpegs from the video.\n \
        Please see the output of $BVC_LOG"
        SORRY_MSG=$OUTPUT
        sorry_msg
        exit 1
    fi

done
# extract jpegs from the provided background video
    if [ -z "$BG_PIC" ]; then
        echo
        echo "Creating a black background"
        BG_PIC="$WORK_DIR/pics/template.jpg"
        convert  -size $VID_SIZE_OPT xc:"#161514" "$BG_PIC"
        cp "$BG_PIC" "$WORK_DIR/submenu_template.jpg"
    else
        convert -resize $VID_SIZE_OPT! "$BG_PIC" "$WORK_DIR/pics/template.jpg"
        convert  -size $VID_SIZE_OPT xc:"#161514" "$WORK_DIR/submenu_template.jpg"
    fi
sleep 20
echo
echo "Creating a gradient image for fancy titling"
convert -size 1x512 gradient: -rotate 90 +matte \
-fx '3.5u^3 - 5.05u^2 + 2.05u + 0.3' \
-size 512x1 xc:"#08447B" -compose Overlay -composite "$GRADIENT"


##############################################################################
#                     spumux and dvdauthor stuff                             #
##############################################################################
echo
echo "Creating the highlight and selection PNGs for the main menu"
GEO="${GEO_ARRAY[FILES]/x/,}"
SELECT_CMD="-size "${GEO_ARRAY[FILES]}+5+5" xc:none -fill none +antialias \
-stroke '#DE7F7C' -strokewidth 4 -draw 'rectangle 0,0 $GEO'"
HIGHLIGHT_CMD="-size "${GEO_ARRAY[FILES]}+5+5" xc:none -fill none +antialias \
-stroke '#188DF6' -strokewidth 4 -draw 'rectangle 0,0 $GEO'"
eval convert "$SELECT_CMD" -colors 3 "$WORK_DIR/Selectx1.png"
eval convert "$HIGHLIGHT_CMD" -colors 3 "$WORK_DIR/Highlightx1.png"

for button in Select Highlight; do
    montage -background none \
    $(for ((i=0; i<=FILES; i++)); do echo $WORK_DIR/${button}x1.png;done) \
    -tile ${TILE_ARRAY[FILES]} -geometry ${GEO_ARRAY[FILES]}+5+5 \
    -bordercolor none -mattecolor transparent miff:- |
    convert  -colors 3 -size 720x480 xc:none  - -gravity north -geometry +0+55  \
    -composite  "$WORK_DIR/${button}.png"
done

if [ $SUB_MENU = "true" ]; then
    echo
    echo "Creating the highlight and selection PNGs for the submenus"
    GEO="${GEO_ARRAY[CHAPTERS - 1]/x/,}"
    SELECT_CMD="-size "${GEO_ARRAY[CHAPTERS - 1]}+5+5" xc:none -fill none +antialias \
    -stroke '#DE7F7C' -strokewidth 4 -draw 'rectangle 0,0 $GEO'"
    HIGHLIGHT_CMD="-size "${GEO_ARRAY[CHAPTERS - 1]}+5+5" xc:none -fill none \
    +antialias -stroke '#188DF6' -strokewidth 4 -draw 'rectangle 0,0 $GEO'"
    eval convert "$SELECT_CMD" -colors 3 "$WORK_DIR/Submenu_Selectx1.png"
    eval convert "$HIGHLIGHT_CMD" -colors 3 "$WORK_DIR/Submenu_Highlightx1.png"
    for button in Select Highlight; do
        montage -background none \
        $(for ((i=0; i<CHAPTERS; i++)); do
        echo $WORK_DIR/Submenu_${button}x1.png;done) \
        -tile ${TILE_ARRAY[CHAPTERS - 1]} \
        -geometry ${GEO_ARRAY[CHAPTERS - 1]}+5+5 \
        -bordercolor none -mattecolor transparent miff:- |

        convert  -colors 3 -size 720x480 xc:none  - \
        -gravity north -geometry +0+55  \
        -composite  $WORK_DIR/Submenu_${button}.png
    done
fi

# make appropriate chapter lengths for each video
# get chapter lengths by dividing by $CHAPTERS, then getting running totals
for i in ${!NEW_LENGTH[@]}; do
  CHAPT_INTERVALS=( ${CHAPT_INTERVALS[@]} $(( ${NEW_LENGTH[i]} / $CHAPTERS)) )
done

# and format in HH:MM:SS
for len in ${CHAPT_INTERVALS[@]}; do
    Y=( ${Y[@]} $(for ((i=1; i<CHAPTERS; i++)) ; do echo "$len";done) )
    chapt_intervals=$(running_total <<< ${Y[@]})
    chapters="$(for c in $chapt_intervals; do echo $(format_seconds $c); done)"
    chapters="00:00:00.000 $chapters"
    CHAPTS=$(for i in $chapters; do echo -n $i,;done|sed 's/,$//')
    CHAPT_ARRAY=( ${CHAPT_ARRAY[@]} $CHAPTS )
    unset Y chapt_intervals cmd
done
# debug chapters
for i in ${!VID_ARRAY[@]}; do
    echo -e "Chapters for "${VID_ARRAY[i]}" are: \n${CHAPT_ARRAY[i++]}\n"
done
# make xml files, and run dvdauthor and spumux
if [ $MENU_FADE = "true" ]; then
    END_TIME=$((ANI_FRAMES / 30))
    END_TIME=$((END_TIME - 3))
    END_TIME=$(format_seconds $END_TIME)
    END=" end=\"$END_TIME\""
    START="00:00:03.0"
    PAUSE_TIME="6"
    POST="<post> jump cell 1; </post>"
    MAIN_POST="        <post> jump cell 1; </post>"
elif [ $MENU_FADE = "false" ]; then
    PAUSE_TIME="inf"
    unset END
    START="00:00:00.0"
fi

(
    cat <<EOF
<subpictures>
   <stream>
     <spu force="yes" start="$START"$END
          highlight="$WORK_DIR/Highlight.png"
          select="$WORK_DIR/Select.png"
          autooutline="infer"
          autoorder="rows"/>
   </stream>
 </subpictures>
EOF
)  > "$SPUMUX_XML"
# make submenu spumux.xml
if [ $SUB_MENU = "true" ]; then
(
    cat <<EOF
<subpictures>
   <stream>
     <spu force="yes" start="00:00:00.0"
          highlight="$WORK_DIR/Submenu_Highlight.png"
          select="$WORK_DIR/Submenu_Select.png"
          autooutline="infer"
          autoorder="rows"/>
   </stream>
 </subpictures>
EOF
) > "$SUBMENU_SPUMUX_XML"
fi
if [ $SUB_MENU = "true" ]; then
    JUMP=menu
    POST="        <post> jump cell 1; </post>"
    if [ $ANI_SUB_MENU = "false" ]; then
        PAUSE=" pause=\"inf\""
        unset POST
    elif [ $ANI_SUB_MENU = "true" ]; then
        PAUSE=" pause=\"5\""
    fi
else
    JUMP=title
fi
# make dvdauthor.xml
(
    cat <<EOF
<?xml version="1.0" encoding="utf-8"?>
<dvdauthor dest="$WORK_DIR/DVD" jumppad="1">
  <vmgm>
    <menus>
      <pgc>
        <post>jump titleset 1 menu;</post>
      </pgc>
    </menus>
  </vmgm>
  <titleset>
    <menus>
      <pgc>
$(for ((i=1; i<=$V_ARRAY_TOTAL; i++)); do
    if [ $SUB_MENU = "true" ]; then
        JUMP_INC=$(($i + 1))
    else
        JUMP_INC=$i
    fi
    echo -e "        <button name=\"$i\">jump $JUMP $JUMP_INC;</button>"
done)
        <vob file="$WORK_DIR/menu.mpg" pause="$PAUSE_TIME"/>
$MAIN_POST
      </pgc>
$(if [ $SUB_MENU = "true" ]; then
    echo -ne "      <pgc>\n"
        for ((Y=1; Y<=$V_ARRAY_TOTAL; Y++)); do
            for ((i=1; i<=CHAPTERS; i++)); do
                echo -e "        <button name=\"$i\">jump title $Y chapter $i;</button>"
            done
            echo -e "        <vob file=\"$WORK_DIR/Menu$Y.mpg\"$PAUSE/>"
echo "$POST"
            echo "      </pgc>"
            echo "      <pgc>"
        done | sed '$d'
fi)    
    </menus>
    <titles>
$(for i in ${!VID_ARRAY[@]}; do
    echo -e "      <pgc>"
    echo -ne "        <vob file=\"${VID_ARRAY[i]}\""
    echo -e  " chapters=\""${CHAPT_ARRAY[i]}"\"/>"
    echo -e "        <post>call vmgm menu 1;</post>"
    echo -e "      </pgc>"
done)
    </titles>
  </titleset>
</dvdauthor> 
EOF
) |sed '/^$/d' >> "$DVDAUTHOR_XML"

##############################################################################
#                            Animenu stuff                                   #
##############################################################################

# do submenu 1st for debug purposes
if [ $SUB_MENU = true ]; then
    if [ $ANI_SUB_MENU = "true" ]; then
        echo $SEPARATOR
        echo "Building submenus"
        echo $SEPARATOR
        echo "Creating JPEGs for each chapter"

        for i in ${!VID_ARRAY[@]}; do
            echo
            echo "Creating a transparent title PNG"
            convert -font "$FRAME_FONT" -pointsize $TITLE_FONT_SIZE -size 620x \
            -gravity Center caption:"\"${TITLES[i]}\""   -negate  \( +clone -blur 0x8 \
            -shade 110x45 -normalize $GRADIENT  -fx 'v.p{g*v.w,0}' \)  +matte +swap \
            -compose CopyOpacity -composite  \
            \( +clone -fx A +matte -blur 0x2 -shade 0x90 -normalize -blur 0x2 -negate \
            -evaluate multiply .4 -negate +clone  -compose Multiply -composite \) \
            -matte  -compose In  -composite $WORK_DIR/intro_txt.png

            #FIXME the below commands are creating a bunch of extra frames
            # which is harmless as they get removed, but needs to be tweaked         
            counts=$((${CHAPT_INTERVALS[i]} * 30))
            CUT=( 0 $(running_total <<<  $(for ((a=0; a<=CHAPTERS ; a++)); do echo -n "$counts ";done)) )
            for c in ${!CUT[@]}; do
                cmd[c]=$((${CUT[c]}))-$((${CUT[c]} + 340))
            done
            key=$((${#cmd[@]} - 1))
            unset cmd[key]
            CMD=${cmd[@]}
            echo -e "\nRunning: "
            echo -e "transcode -q 0 -i "${VID_ARRAY[i]}"" 
            echo -e "-o $WORK_DIR/animenu/chapt -f 29.970 "
            echo -e "-J cut=\"$CMD\"  -y jpg,null\n"

            TCODE_CMD=(transcode -q 0 -i "${VID_ARRAY[i]}" \
            -o $WORK_DIR/animenu/chapt -f 29.970  -J cut="$CMD" -y jpg,null)
             printf "%s\n\n" "$LINE" "$LINE" >> $BVC_LOG
            if "${TCODE_CMD[@]}" 2>&1 >> $BVC_LOG.tmp; then
                cleanlog 1
            else
                cleanlog 1
                OUTPUT="There was a problem creating jpegs from the video.\n \
                Please see the output of $BVC_LOG"
                SORRY_MSG=$OUTPUT
                sorry_msg
                exit 1
            fi
            unset TCODE_CMD

            echo
            # FIXME make sure $CHAPTERS number of jpegs got created
            jpegs=$(find $WORK_DIR/animenu -name chapt000\*.jpg)

#            Disabled frames for now - takes too long - (use montage -border TODO)
            # move 340 jpegs to each subdir:  $WORK_DIR/animenu/{0,1,2,3,etc}
            for ((a=0; a<CHAPTERS; a++)); do
                pics=( $(find $WORK_DIR/animenu/  -maxdepth 1 -name chapt\*.jpg|head -n 340) )
                for f in ${pics[@]}; do
                    mv $f $WORK_DIR/animenu/$a
                done
            done
            for ((a=0; a<CHAPTERS; a++)); do
                find $WORK_DIR/animenu/$a/ -name chapt\*.jpg|head -n 20|xargs rm
                find $WORK_DIR/animenu/$a/ -name chapt\*.jpg|tail -n 20|xargs rm
                # a debug echo for now
                echo -n "Frame count in $WORK_DIR/animenu/$a is: "
                echo "$(ls -l $WORK_DIR/animenu/$a/*.jpg|wc -l) frames"
            done
                echo
                echo "Making montage images for  "${VID_ARRAY[i]}""
            
            for ((a=1; a<300; a++)); do
                for ((b=0; b<CHAPTERS; b++)); do
                    JPEGS=( "${JPEGS[@]}" $(find $WORK_DIR/animenu/$b -name \*.jpg|head -n $a|sed  -n -e "$a p") )
                done
                IM_CMD=(montage ${JPEGS[@]} -tile ${TILE_ARRAY[CHAPTERS - 1]} \
                -geometry ${GEO_ARRAY[CHAPTERS - 1]}+5+5 -bordercolor '#161514' \
                -mattecolor '#161514' -background '#161514' miff:-)
                IM_CMD2=(convert $WORK_DIR/submenu_template.jpg \
                $WORK_DIR/animenu/intro_txt.png  -gravity south \
                -geometry +0+55 -composite -  -gravity north -geometry +0+55 \
                -composite $WORK_DIR/animenu/$a.jpg)
                
                "${IM_CMD[@]}" | "${IM_CMD2[@]}"
                unset JPEGS
            done
                
                unset IM_CMD IM_CMD2 d f PIC
                # FIXME
                echo
                echo "Converting chapter montages of $i to m2v video format"

                jpeg2yuv -v 0 -f 29.970 -I p -n 300 -L 1 -b1 \
                -j $WORK_DIR/animenu/%0d.jpg |
                ffmpeg   -f yuv4mpegpipe -i - -r 29.970 -s $VID_SIZE_OPT \
                -tvstd ntsc $FFMPEG_OPTS -y $WORK_DIR/menu$i.m2v
                rm -f $WORK_DIR/animenu/chapt*.jpg
                rm -f $WORK_DIR/animenu/[0-9]*.jpg
        done    
                
        
    
    elif [ ! $ANI_SUB_MENU = "true" ]; then
        echo $SEPARATOR
        echo "Building submenus"
        echo $SEPARATOR
        echo "Creating JPEGs for each chapter"
        for i in ${!VID_ARRAY[@]}; do
            counts=$((${CHAPT_INTERVALS[i]} * 30))
            SKIP=( 0 $(running_total <<<  $(for ((a=0; a<7;a++)); do echo -n "$counts ";done)) )
            for c in ${!SKIP[@]}; do cmd[c]=$((${SKIP[c]} + 1))-${SKIP[c+1]};done
            key=$((${#cmd[@]} - 1))
            unset cmd[key]
            CMD=${cmd[@]}
            transcode -i "${VID_ARRAY[i]}" -o chapt -f 29.970 -J skip="$CMD" -y jpg,null

            echo
            echo "Creating a transparent title PNG"
            convert -font "$FRAME_FONT" -pointsize $TITLE_FONT_SIZE -size 620x \
            -gravity Center caption:"\"${TITLES[i]}\""  -negate  \( +clone -blur 0x8 \
            -shade 110x45 -normalize $GRADIENT  -fx 'v.p{g*v.w,0}' \)  +matte +swap \
            -compose CopyOpacity -composite  \
            \( +clone -fx A +matte -blur 0x2 -shade 0x90 -normalize -blur 0x2 -negate \
            -evaluate multiply .4 -negate +clone  -compose Multiply -composite \) \
            -matte  -compose In  -composite $WORK_DIR/intro_txt.png

            # FIXME make sure $CHAPTERS number of jpegs got created
            # just use $CHAPTERS number of jpegs
            jpegs=$(find . -name chapt000\*.jpg|head -n $CHAPTERS)
            # create frames for the chapter thumbs
            for PIC in $jpegs; do
                convert -background '#141614' -frame 8x8 \
                -bordercolor none -mattecolor "#444744" $PIC $PIC
            done
            IM_CMD=(montage $jpegs -tile ${TILE_ARRAY[CHAPTERS -1]} \
            -geometry ${GEO_ARRAY[CHAPTERS - 1]}+5+5 -background '#141614' miff:-)
            IM_CMD2=(convert $WORK_DIR/submenu_template.jpg \
            $WORK_DIR/animenu/intro_txt.png  -gravity south -geometry +0+55 -composite \
            -  -gravity north -geometry +0+55 -composite \
            $WORK_DIR/submenu.jpg)
            "${IM_CMD[@]}" | "${IM_CMD2[@]}"

            rm -f $WORK_DIR/chapt*000*.jpg

            echo
            echo "Converting JPEGs to m2v video format"
            jpeg2yuv -v 0 -f 29.970 -I p -n 1 -l 60 -L 1 -b1 \
            -j $WORK_DIR/submenu.jpg |
            ffmpeg   -f yuv4mpegpipe -i - -r 29.970 -s $VID_SIZE_OPT \
            -tvstd ntsc $FFMPEG_OPTS -y $WORK_DIR/menu$i.m2v
            rm -f $WORK_DIR/animenu/*
        done
    fi
    
    # create silence for either animated or plain submenus
    for ((s=0; s<=FILES; s++)); do
        echo
        echo "Creating a silent audio background"
        TIME=`vid_length $WORK_DIR/menu$s.m2v`
        ffmpeg -f s16le -i /dev/zero -t $TIME \
        $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT
        unset TIME
#        command to use in for loop when SM_AUDIO is implemented
#        ffmpeg -i ${SM_AUDIO[s]} -ar 48000 -ac 2 -acodec pcm_s16le -y \
#        -t 20 $WORK_DIR/menu$s.wav
#        ffmpeg -i $WORK_DIR/menu$s.wav \
#        $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT
#        fi
        echo
        echo "Multiplexing video and audio together"
        S=$((s + 1))
        mplex -V -f $MPLEX_FORMAT -b 230 -o $WORK_DIR/menu$S.mpg \
        $WORK_DIR/menu$s.$AUDIO_EXT $WORK_DIR/menu$s.m2v

    done
fi

##############################################################################
#                      Work on main menu                                     #
##############################################################################
echo $SEPARATOR
echo "Building main menu"
echo $SEPARATOR
echo
echo "Creating a transparant png with the title on it"
convert -font "$FRAME_FONT" -pointsize $TITLE_FONT_SIZE -size 620x \
-gravity Center caption:"\"$VMGM_TITLE\""  -negate  \( +clone -blur 0x8 \
-shade 110x45 -normalize \
$GRADIENT  -fx 'v.p{g*v.w,0}' \)  +matte +swap \
-compose CopyOpacity -composite  \
\( +clone -fx A +matte -blur 0x2 -shade 0x90 -normalize -blur 0x2 -negate \
-evaluate multiply .4 -negate +clone  -compose Multiply -composite \) \
-matte  -compose In  -composite $WORK_DIR/intro_txt.png

echo
echo "Adding title to JPEGs and resizing"
for ((i=0; i<=FILES; i++)); do
    JPGS=( "${JPGS[@]}" \
    $(find $WORK_DIR/pics/$i -maxdepth 1 -name '*[1-9]*.jpg') )

    for jpg in "${JPGS[@]}"; do
        montage -geometry +4+4 -background '#161514' \
        -fill '#C6C6C6' -pointsize 22 -title "${TITLES[i]}"  $jpg miff:- |
        convert -background '#161514' -frame 8x8 \
        -bordercolor none -mattecolor "#444744" - miff:- |
        convert -resize $INTRO_SIZE! - $jpg
    done

    # make sure all animated thumbs finish at the same time 
    last_jpg="$((${#JPGS[@]} - 1))"
    next_jpg=$(($last_jpg + 1))
    if [ $last_jpg -ge $MAX_ANI_LENGTH ]; then
        :
    else
        for ((l=$next_jpg; l<=$MAX_ANI_LENGTH; l++)); do
            cp $WORK_DIR/pics/$i/$last_jpg.jpg $WORK_DIR/pics/$i/000$l.jpg
        done
    fi
    unset JPGS last_jpg next_jpg
done

if [ ! $MENU_FADE = "true" ]; then
    if [ $TRANSPARENT = "false" ]; then
        echo
        echo "making final montages and compositing onto background with title"
        for (( count=1; count <= $MAX_ANI_LENGTH; count++)); do
            ANI_PICS=$(find $WORK_DIR/pics/*[0-9]* -maxdepth 1 -name $count.jpg)

            # make final montages and composite onto grey background with title
            IM_CMD=(montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[FILES]} \
            -geometry ${GEO_ARRAY[FILES]}+5+5 -background none miff:-)
            IM_CMD2=(convert $WORK_DIR/pics/template.jpg \
            $WORK_DIR/intro_txt.png  -gravity south -geometry +0+55 -composite \
            -  -gravity north -geometry +0+55 -composite \
            $WORK_DIR/animenu/$count.jpg)

            "${IM_CMD[@]}" | "${IM_CMD2[@]}"
            rm -f rm -f ${ANI_PICS[@]}
        done
    elif  [ $TRANSPARENT = "true" ]; then
         for (( count=1; count <= $MAX_ANI_LENGTH; count++)); do
            ANI_PICS=$(find $WORK_DIR/pics/*[0-9]* -maxdepth 1 -name $count.jpg)
            # dissovle the images to transparency N provided by user FIXME
            IM_CMD=(montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[FILES]} \
            -geometry ${GEO_ARRAY[FILES]}+5+5 -background none miff:-)
            IM_CMD2=(composite -dissolve $DISSOLVE \
            -gravity north -geometry +0+55 - \
            $WORK_DIR/pics/template.jpg -background none miff:-)
            IM_CMD3=(convert - $WORK_DIR/intro_txt.png  \
            -gravity south -geometry +0+55 -composite \
            $WORK_DIR/animenu/$count.jpg )
            "${IM_CMD[@]}" | "${IM_CMD2[@]}" | "${IM_CMD3[@]}"
            rm -f rm -f ${ANI_PICS[@]}
        done
    fi    
elif [ $MENU_FADE = "true" ]; then
    echo
    echo "making final montages and compositing onto background with title"
#    convert $WORK_DIR/pics/template.jpg \
#    $WORK_DIR/intro_txt.png  -gravity south -geometry +0+55 -composite \
#    $WORK_DIR/pics/template.jpg

    # thanks to graycat on #bash (irc.freenode.net) for syntax of loop 
    for ((count=1; count<=ANI_FRAMES; count++)); do
        S=$(( (count<DISSOLVE) ? count : ((count>ANI_FRAMES-DISSOLVE) ? ANI_FRAMES-count : DISSOLVE) ));
        ANI_PICS=( $(find $WORK_DIR/pics/*[0-9]* -maxdepth 1 -name $count.jpg) )

        montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[FILES]} \
        -geometry ${GEO_ARRAY[FILES]}+5+5 -background none miff:- |

        composite -dissolve $S -gravity north -geometry +0+55 - \
        $WORK_DIR/pics/template.jpg -background none miff:- |
        composite -dissolve $S -gravity south -geometry +0+55 \
        $WORK_DIR/intro_txt.png - -background none $WORK_DIR/animenu/$count.jpg
    done
    # make last few frames *really* "black" if using default background
    if [ $BLACKEN = "true" ]; then 
        for ((j=$((ANI_FRAMES - 4)); j<=ANI_FRAMES; j++)); do
            BLACK_FRAMES=( "${BLACK_FRAMES[@]}"  \
            $(find $WORK_DIR/animenu -maxdepth 1 -name $j.jpg) )
        done
        for pic in "${BLACK_FRAMES[@]}"; do
            rm -f "$pic"
            convert -size 720x480 xc:"#161514" "$pic"
        done
    fi
fi

echo
echo "converting JPEGS to video stream and encoding to dvd complient m2v video"
# convert jpegs to video stream and encode to dvd complient m2v
ENC_CMD1=(jpeg2yuv -v 0 -f 29.970 -I p -n $MAX_ANI_LENGTH -L 1 -b1 \
-j $WORK_DIR/animenu/%0d.jpg)
ENC_CMD2=(ffmpeg   -f yuv4mpegpipe -i - -an -r 29.970 -s $VID_SIZE_OPT \
-tvstd ntsc $FFMPEG_OPTS -y $WORK_DIR/intro.m2v)
printf "%s\n\n" "$LINE" "$LINE" >> $BVC_LOG
if "${ENC_CMD1[@]}" | "${ENC_CMD2[@]}" >> $BVC_LOG.tmp 2>&1; then
    cleanlog 3
else
    cleanlog 3
    sorry_msg
    exit 1
fi

echo
echo "Cleaning up montage JPEGs"
#rm -fr $WORK_DIR/animenu/*.jpg


# create silence for the main menu
TIME=`vid_length "$WORK_DIR/intro.m2v"`
echo -e "TIME IS $TIME"
if [ -z "$BG_AUDIO" ]; then
    cat /dev/zero | nice -n 0 sox -t raw -c 2 -r 48000 -w \
    -s - $WORK_DIR/intro.wav  trim 0 $TIME
else
    echo -e "BG_AUDIO is $BG_AUDIO"
    ffmpeg -i "$BG_AUDIO" -ar 48000 -ac 2 -acodec pcm_s16le -y \
    -t 20 $WORK_DIR/intro.wav
    if [ $AUDIO_FADE = "true" ]; then
        echo -e "Running:
        sox $WORK_DIR/intro.wav \
        $WORK_DIR/intro-processed.wav fade t 0 $TIME $FADE"
        
        sox $WORK_DIR/intro.wav \
        $WORK_DIR/intro-processed.wav fade t 0 $TIME $FADE
        rm $WORK_DIR/intro.wav
        mv $WORK_DIR/intro-processed.wav $WORK_DIR/intro.wav
    fi
fi
unset TIME

# convert to proper audio format
ffmpeg -i $WORK_DIR/intro.wav \
$AUDIO_OPTS -y $WORK_DIR/intro.$AUDIO_EXT

echo
echo "Multiplexing main menu audio and video together"
# mplex main menu audio and video together
INTRO_MPLEX_CMD="mplex -V -f $MPLEX_FORMAT -b 230 -o $WORK_DIR/intro.mpg \
$WORK_DIR/intro.$AUDIO_EXT $WORK_DIR/intro.m2v"
echo -e "\nRunning: $INTRO_MPLEX_CMD\n" >> $BVC_LOG.tmp 
cleanlog 1
printf "%s\n\n" "$LINE" "$LINE" >> $BVC_LOG
if ${INTRO_MPLEX_CMD[@]} >> $BVC_LOG.tmp 2>&1; then
    cleanlog 1
else
    cleanlog 1
    sorry_msg
    exit 1
fi

##############################################################################
#                       Run spumux and dvdauthor and pray                    #
##############################################################################

echo
echo "Running spumux and dvdauthor to create the final DVD structure"
spumux "$SPUMUX_XML" < $WORK_DIR/intro.mpg > $WORK_DIR/menu.mpg
if [ $SUB_MENU = "true" ]; then
    for i in $(find $WORK_DIR/ -name menu[0-9]\*.mpg); do
        spumux "$SUBMENU_SPUMUX_XML" < $i > ${i/menu/Menu}
    done
fi
dvdauthor -x "$DVDAUTHOR_XML"

SCRIPT_END_TIME=`date +%s`
SCRIPT_TOT_TIME=`expr $SCRIPT_END_TIME \- $SCRIPT_START_TIME`
HHMMSS=`format_time $SCRIPT_TOT_TIME`

echo "animenu took $HHMMSS to finish on $CPU_MODEL $CPU_SPEED mhz"
echo
echo "Your new DVD is ready to burn at $WORK_DIR/DVD."
echo "Thanks for using animenu."

