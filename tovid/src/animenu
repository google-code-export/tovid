#!/bin/bash
ME="[animenu]:"
. tovid-init

# animenu
# Part of the tovid suite
# =======================
# A bash script for generating a DVD with animated thumbnail menus
# from a collection of MPEG video files.
#
# Project homepage: http://www.tovid.org
#
#
# Copyright (C) 2005 tovid.org <http://www.tovid.org>
# 
# This program is free software; you can redistribute it and/or 
# modify it under the terms of the GNU General Public License 
# as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later 
# version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. Or see:
#
#           http://www.gnu.org/licenses/gpl.txt


# Mostly written by Robert Sohn:
#     <grepper@gmail.com>
#     grepper on irc.freenode.net

SCRIPT_NAME=`cat << EOF
--------------------------------
animenu
Generate a DVD filesystem with animated thumbnail menus
Part of the tovid suite, version $TOVID_VERSION
$BUILD_OPTIONS
$TOVID_HOME_PAGE
--------------------------------
EOF`

USAGE=`cat << EOF
Usage:
    animenu [OPTIONS] \
      -files File1.mpg File2.mpg ... \
      -titles "Title 1" "Title 2" ... \
      -out OUT_PREFIX

Input files must be MPEG, and the number of -files and -titles must be equal. 

Options:

-keepfiles        Keep all intermediate/temporary files (helps with debugging)
-submenus         Create a submenu with chapters for each video. 
-ani-submenus     Create an animated submenu with chapters for each video
-menu-length      The desired animated main menu length in seconds
-submenu-length   The disired animated submenu length in seconds
-menu-title       Title for the root menu - may be longer than thumbnail labels
-menu-font        Font to use for titles: use for example either: "Arial" , or
                  "/full/path/to/arial.ttf" (default: imagemagick default font)
-menu-fontsize   Font size for main menu - best to -preview if you use this.
-thumb-font       Font to use for thumb titles in main menu. See -menu-font.
-menu-bg          Menu background image - pick on of correct aspect ration: ie.
                  it should still look good when resize to 720x480 (pal: 720x576)
-ani-menu-bg      Menu background video - again, needs to be resize to 720x480 or
                  720x576, so pick one of appropriate aspect ratio/resolution
-menu-fade        Fade the menu into the provided background image
                  Do not use this for dark backgrounds like the default gray/black
-transparency     The amount of transparency for the menu (0 -> 100):
                  Lower values are more transparent, ie. less visable menu.. 
                  Use keyword:  none   , for no transparency
                  (only needed with -menu-fade or -menu-bg)
-menu-audio       An audio file for the main menu background
-menu-audio-fade  Number of sec to fade given menu audio out (default: no fade)
-submenu-audio #  (not implemented yet) List of files for submenu backgrounds:
                  must equal the number of chapters (default: 6 chapters)
-chapters         The number of submenu chapters for each video (default: 6)
-preview          display a preview of the menu with selected options and exit
-seek             For main menu only - seek to N seconds before generating jpegs
EOF`

# Print script name, usage notes, and optional error message, then exit.
# Args: $@ == text string containing error message
usage_error ()
{
    printf "%s\n" "$USAGE"
    printf "%s\n" "$SEPARATOR"
    printf "*** %s\n" "$@"
    exit 1
}

WORK_DIR=`abspath "animenu-work"`
ANIMENU_LOG="`pwd`/animenu.log"
OUT_PREFIX=""
ANI_MENU_LENGTH=20
MAX_ANI_LENGTH=""
FRAME_RATE=29.970  # when -ntsc and -pal options added put in body in if block
TARGET=DVD
LINE=$(for ((i=1; i<=79; i++));do echo -n =;done)
VID_SIZE_OPT=720x480
VMGM_TITLE="My Video Collection"
SPUMUX_XML="$WORK_DIR/spumux.xml"
SUBMENU_SPUMUX_XML="$WORK_DIR/submenu_spumux.xml"
DVDAUTHOR_XML="$WORK_DIR/dvdauthor.xml"
GRADIENT="$WORK_DIR/aqua_gradient.png"
SUB_MENU=false
ANI_SUB_MENU=false
CHAPTERS=6
TITLE_FONT=""
THUMB_FONT=""
BG_AUDIO=""
BG_PIC=""
SM_AUDIO=""
AUDIO_FADE=false
DISSOLVE=100
MENU_FADE=false
TRANSPARENT=false
PREVIEW=false
PAUSE_TIME=6
BLACKEN=:
MIST=false
KEEP_FILES=false

SCRIPT_START_TIME=`date +%s`

##############################################################################
#                                 Functions                                  #
##############################################################################

function cleanlog()
# process $ANIMENU_LOG.tmp variously - eg. ffmpeg's output is ugly without this
{
    FOLD="fold -bs"
    NO_CR="tr -d '\r'"
    RELINE="{s/$SED_VAR/\n$SED_VAR/g}"
    TMP_LOG="$ANIMENU_LOG.tmp"
    NOSPACE="tr -s ' '"

    case "$1" in
        1 )
            $FOLD $TMP_LOG >> $ANIMENU_LOG
            echo >> $ANIMENU_LOG
            ;;
        2 )
            $NO_CR < $TMP_LOG | $FOLD >> $ANIMENU_LOG
            echo >> $ANIMENU_LOG
            ;;
        3 )
            $NO_CR < $TMP_LOG | sed $RELINE | $FOLD >> $ANIMENU_LOG
            echo >> $ANIMENU_LOG
            ;;
        4 )
            $NOSPACE < $TMP_LOG | $FOLD >> $ANIMENU_LOG
            ;;
    esac
    rm -f $ANIMENU_LOG.tmp
}

function sorry_msg()
{
    echo -e "Oops . . .Something went wrong."
    echo "There was a problem creating the $OUTPUT."
    echo "Please check the log at $ANIMENU_LOG"
}

function vid_length()
{
    mencoder "$1" -quiet -ovc copy -oac pcm -o /dev/null |
    awk '/Video stream/ {print $10}'
}

function cleanup()
{
    if $KEEPFILES; then
        echo "Keeping temporary files in $WORK_DIR"
    else
        rm -rf "$WORK_DIR"
    fi
}

function running_total ()
{
    awk '{
    for (i=1; i<=NF; i++) if (s=s+$i) printf("%s ",s);printf ("\n")}'
}

function format_seconds()
{
    awk '{
    hr=($1/3600); hd=(sprintf("%02d", hr))
    mr=((hr-hd)*60); md=(sprintf("%02d", mr))
    s=((mr-md)*60); sd=(sprintf("%02d", s))
    t=(sprintf("%02d:%02d:%06.3f" ,hd,md,s)); print t}' <<< $1
}


##############################################################################
#                          	End of functions                                 #
##############################################################################

trap cleanup 2 15

###############################################################################
#       Process arguments to the script, set up VARS and WORK_DIR             #
###############################################################################

# ***********************************
# EXECUTION BEGINS HERE
# ***********************************

echo $"$SCRIPT_NAME"

while test $# -gt 0; do
    DO_SHIFT=:
    case "$1" in
        "-files" )
            shift
            # Hackish list-parsing
            while test $# -gt 0 && test ${1:0:1} != "-"; do
                VIDS=( "${VIDS[@]}" "$1" )
                shift
            done
            # Don't skip past the next argument
            if test $# -gt 0 && test ${1:0:1} = "-"; then DO_SHIFT=false; fi
            ;;
        "-titles" )
            shift
            # Hackish list-parsing
            while test $# -gt 0 && test ${1:0:1} != "-"; do
                TITLES=( "${TITLES[@]}" "$1" )
                shift
            done
            # Don't skip past the next argument
            if test $# -gt 0 && test ${1:0:1} = "-"; then DO_SHIFT=false; fi
            ;;
        "-out" )
            shift
            OUT_PREFIX="$1"
            ;;
        "-keepfiles" )
            KEEP_FILES=:
            ;;
        "-menu-length" )
            shift
            ANI_MENU_LENGTH="$1"
            ;;
        "-submenu-length" )
            shift
            SUBMENU_LENGTH="$1"
            ;;
        "-menu-bg" )
            shift
            BG_PIC=`abspath "$1"`
            BLACKEN=false
            MIST=: 
            ;;
        "-menu-fade" )
            MENU_FADE=:
            ;;
        "-ani-menu-bg" )
            shift
            ANI_BG=`abspath "$1"`
            ;;
        "-transparency" )
            shift
            if [ $1 = "none" ]; then
                TRANSPARENT=false
            else
                TRANSPARENT=:
                DISSOLVE="$1"
            fi
            ;;
        "-submenu-audio" )
            shift
            # Hackish list-parsing
            while test $# -gt 0 && test ${1:0:1} != "-"; do
                SM_AUDIO=( "${SM_AUDIO[@]}" "$1" )
                shift
            done
            # Don't skip past the next argument
            if test $# -gt 0 && test ${1:0:1} = "-"; then DO_SHIFT=false; fi
            ;;
        "-chapters" )
            shift
            CHAPTERS="$1"
            ;;
        "-menu-audio" )
            shift
            BG_AUDIO=`abspath "$1"`
            ;;
        "-menu-audio-fade" )
            shift
            FADE="$1"
            AUDIO_FADE=:
            ;;
        "-submenus" )
            SUB_MENU=:
            ;;
        "-ani-submenus" )
            ANI_SUB_MENU=:
            SUB_MENU=:
            ;;
        "-menu-title" )
            shift
            VMGM_TITLE="$1"
            ;;
        "-menu-font" )
            shift
            # If there's a filename extension, find the absolute path
            if echo "$1" | grep -q '\...*$'; then
                TITLE_FONT=`abspath "$1"`
            else
                TITLE_FONT="$1"
            fi
            ;;
        "-menu-fontsize" )
            shift
            TITLE_FONT_SIZE="$1"
            ;;
        "-thumb-font" )
            shift
            # If there's a filename extension, find the absolute path
            if echo "$1" | grep -q '\...*$'; then
                THUMB_FONT=`abspath "$1"`
            else
                THUMB_FONT="$1"
            fi
            ;;
        "-preview" )
            PREVIEW=:
            ;;
        "-seek" )
            shift
            SEEK="$1"
            SEEK="-ss $SEEK"
            ;;
    esac
    $DO_SHIFT && shift
done
# Make sure equal, nonzero number of titles and files were provided
if test ${#VIDS[@]} -eq 0 || test ${#TITLES[@]} -eq 0; then
    usage_error "Please provide at least one file and one title."
elif test ${#VIDS[@]} -ne ${#TITLES[@]}; then
    usage_error "Please give the same number of files as titles."
fi

# Error if -out was not provided
if test -z "$OUT_PREFIX"; then
    usage_error "Please provide an output name with -out"
fi
OUT_DIR=`abspath $OUT_PREFIX`
MENU_FILE="animenu.mpg"

# If output directory already exists, print a message and exit
if test -d "$OUT_DIR"; then
    echo "Output directory \"$OUT_DIR\" already exists."
    echo "Please use a different -out name, or (re)move the existing directory."
    exit 0
fi
# Clean out any existing WORK_DIR
if test -d "$WORK_DIR"; then
    echo "Removing existing files in \"$WORK_DIR\""
    rm -rf "$WORK_DIR"
fi
mkdir -pv "$WORK_DIR"

# Try to find a default font that is available
if [ -z "$TITLE_FONT" ]; then
    if convert -size 50x20 xc:none -font Helvetica -gravity Center \
    -draw "text 0,0 'test'" $WORK_DIR/font.png; then
        TITLE_FONT="Helvetica"
    elif convert -size 200x100 xc:none -font helvetica -gravity Center \
    -draw "text 0,0 'test'" $WORK_DIR/font.png; then
        TITLE_FONT="helvetica"
    fi
fi
rm -f "$WORK_DIR/font.png"

for i in "${VIDS[@]}"; do
    VID_ARRAY=( "${VID_ARRAY[@]}" `abspath "$i"` )
done

# do everything in $WORK_DIR
cd $WORK_DIR


# make sure titles have no more than 12 characters
for ((i=0; i<${#TITLES[@]}; i++)); do
    val=${#TITLES[i]}
    [ -z "$MAX_VAL" ] || ((val > MAX_VAL)) && MAX_VAL=$val && key=$i
done

if [ $MAX_VAL -gt 14 ]; then
    echo -e "Sorry, maximum number of characters you can use for a title is 14"
    echo -e "The title \"${TITLES[key]}\" is too long"
    exit 1
fi

SVCD_VID_SIZE_OPT="480x480"
DVD_VID_SIZE_OPT="720x480"
DVD_AUDIO_EXT=ac3
SVCD_AUDIO_EXT=mp2
DVD_SAMPLERATE="48000"
SVCD_SAMPLERATE="44100"
DVD_AUDIO_OPTS="-ab 224 -ar 48000 -ac 2 -acodec $DVD_AUDIO_EXT"
SVCD_AUDIO_OPTS="-ab 224 -ar 44100 -ac 2 -acodec $SVCD_AUDIO_EXT"
SVCD_FFMPEG_TARGET="ntsc-svcd"
DVD_FFMPEG_TARGET="ntsc-dvd"
SVCD_FFMPEG_OPTS="-b 2200 -minrate 2200 -maxrate 2200 -bufsize 230 -aspect 4:3"
DVD_FFMPEG_OPTS="-b 8000  -maxrate 9000 -bufsize 230  -aspect 4:3"
SVCD_INTRO_SIZE="240x240"
DVD_INTRO_SIZE="360x240"
SVCD_MPLEX_FORMAT=4
DVD_MPLEX_FORMAT=8
SVCD_TITLE_FONT_SIZE=32
DVD_TITLE_FONT_SIZE=42
# PTSIZE=(30 36 42 42 42 42 48 48 48 48 48 48 54 54 54 54 54 54 54 54 \
# 54 54 54 54 54 54 54 54 54 54)
DVD_GEO_ARRAY=(360x240 270x180 210x140 210x140 192x128 192x128 144x96 144x96 \
144x96 120x80 120x80 120x80 96x64 96x64 96x64 96x64 96x64 96x64 96x64 96x64 \
72x48 72x48 72x48 72x48 72x48 72x48 72x48 72x48 72x48 72x48)
SVCD_GEO_ARRAY=(240x240 180x180 120x120 120x120 120x120 120x120 96x96 96x96 \
96x96 80x80 80x80 80x80 64x64 64x64 64x64 64x64 64x64 64x64 64x64 64x64 \
48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48)
TILE_ARRAY=(1x1 2x1 2x2 2x2 3x2 3x2 3x3 3x3 3x3 4x3 4x3 4x3 4x4 4x4 4x4
4x4 5x4 5x4 5x4 5x4 5x5 5x5 5x5 5x5 5x5 6x5 6x5 6x5 6x5 6x5)

V_ARRAY_TOTAL=${#VID_ARRAY[@]}
A_ARRAY_TOTAL=${#TITLES[@]}
FILES=$(($V_ARRAY_TOTAL - 1))

# set up our log file
PATTERN=$(for ((i=1; i<=79; i++)); do echo -n \*; done)
printf "%s\n%s\n%s\n\n\n" "$PATTERN" \
"tovid suite's animenu - log for `date`" \
"$PATTERN" >> $ANIMENU_LOG

# create_dirs
echo
echo "Creating pics directories..."
for ((i=0; i<=FILES; i++));
do
    mkdir -pv "$WORK_DIR/pics/$i"
done
if $MENU_FADE; then mkdir -v $WORK_DIR/bg; fi
mkdir -v "$WORK_DIR/animenu"
if $ANI_SUB_MENU; then
    for ((i=0; i<CHAPTERS; i++)); do
        mkdir -v "$WORK_DIR/animenu/$i"
    done
fi

echo
echo -e "Videos to be processed"
for vid in "${VID_ARRAY[@]}"; do echo "$vid";done
echo  
if  [ $TARGET = "DVD" ]; then
    VID_SIZE_OPT=$DVD_VID_SIZE_OPT
    AUDIO_OPTS=$DVD_AUDIO_OPTS
    SAMPLERATE=$DVD_SAMPLERATE
    AUDIO_EXT=$DVD_AUDIO_EXT
    FFMPEG_TARGET=$DVD_FFMPEG_TARGET
    INTRO_SIZE=$DVD_INTRO_SIZE
    FFMPEG_OPTS=$DVD_FFMPEG_OPTS
    MPLEX_FORMAT=$DVD_MPLEX_FORMAT
    GEO_ARRAY=("${DVD_GEO_ARRAY[@]}")
    if [ -z $TITLE_FONT_SIZE ]; then
        TITLE_FONT_SIZE=$DVD_TITLE_FONT_SIZE
    else
        TITLE_FONT_SIZE=$TITLE_FONT_SIZE
    fi
fi
###############################################################################
#     generate title_txt png, and template.jpg needed for all operations       #
###############################################################################

if [ -z "$BG_PIC" ]; then
    echo
    echo "Creating a black background"
    BG_PIC="$WORK_DIR/pics/template.jpg"
    convert  -resize $VID_SIZE_OPT! xc:"#161514" "$BG_PIC"
else
    convert -resize $VID_SIZE_OPT! "$BG_PIC" "$WORK_DIR/pics/template.jpg"
fi

if $MIST; then
    convert -size $VID_SIZE_OPT xc:"#161514" "$WORK_DIR/black.jpg"
fi

convert -size 1x512 gradient: -rotate 90 +matte \
-fx '3.5u^3 - 5.05u^2 + 2.05u + 0.3' \
-size 512x1 xc:"#08447B" -compose Overlay -composite "$GRADIENT"
echo "Creating a transparent png with the title on it"

convert -font "$TITLE_FONT" -pointsize $TITLE_FONT_SIZE -size 620x \
-gravity Center caption:"\"$VMGM_TITLE\""  -negate  \( +clone \
-shade 110x45 -normalize \
$GRADIENT  -fx 'v.p{g*v.w,0}' \)  +matte +swap \
-compose CopyOpacity -composite  \
\( +clone -fx A +matte -shade 0x90 -normalize -negate \
-evaluate multiply .4 -negate +clone  -compose Multiply -composite \) \
-matte  -compose In  -composite miff:- |
 convert -trim +repage - -blur 0.4x0.4 $WORK_DIR/title_txt.png

if $MIST; then
    # make a white png for misted background effect, only for user's bg
    Y=$(identify $WORK_DIR/title_txt.png |awk '{print $3}'|cut -dx -f1)
    X=$(identify $WORK_DIR/title_txt.png |awk '{print $3}'|cut -dx -f2)
    # add 10 pixels to width and height compared to title text png
    Y=$((Y + 10))
    X=$((X + 10))
    DIM=${Y}x${X}
    convert -size $DIM xc:"#EBEBEB" $WORK_DIR/white.png
    unset X Y
fi

###############################################################################
#      if preview is selected, generate a basic preview of the main menu      #
###############################################################################

if $PREVIEW; then
    if $MIST; then
        # overlay white.png onto the background
        composite -dissolve 30 -gravity south -geometry +0+50 \
        $WORK_DIR/white.png $WORK_DIR/pics/template.jpg \
        $WORK_DIR/pics/template.jpg
    fi
    # generate JPEGS for montage and title and resize them
    for ((i=0; i<=FILES; i++)) ; do
        ffmpeg -i "${VID_ARRAY[$i]}" $SEEK -vframes 1 \
        -s 360x240 $WORK_DIR/${i}-preview%d.jpg
    done
    JPGS=( "${JPGS[@]}" \
    $(find $WORK_DIR/ -maxdepth 1 -name '*preview*.jpg') )
    for i in "${!JPGS[@]}"; do
        # **if horizontal lines in frames, try montage "${JPGS[i]}" -blur 0x.3**
        # using a mask just on the frame portion would be even better
        # www.cit.gu.edu.au/~anthony/info/graphics/imagemagick.hints 1/4 down
        montage "${JPGS[i]}" -geometry +4+4 -bordercolor none -compose Copy  \
        -background none -fill '#C6C6C6' -font "$THUMB_FONT" -pointsize 22 \
        -title "${TITLES[i]}"  $jpg miff:- |
        convert -background none -frame 8x8 \
        -bordercolor none -mattecolor "#444744" - miff:- |
        convert -resize $INTRO_SIZE! - "${JPGS[i]}"
    done
    if $TRANSPARENT; then
        montage ${JPGS[@]} -blur 0x.3 -tile ${TILE_ARRAY[FILES]} \
        -geometry ${GEO_ARRAY[FILES]}+5+5 -background none miff:- |
        composite -dissolve $DISSOLVE \
        -gravity north -geometry +0+55 - \
        $WORK_DIR/pics/template.jpg -background none miff:- |
        convert - $WORK_DIR/title_txt.png  \
        -gravity south -geometry +0+55 -composite \
        $WORK_DIR/example.jpg
        display $WORK_DIR/example.jpg
        echo
        echo -e "If you are happy with your preview, please proceed" 
        echo "without the -preview option"
        exit 0 
    else # Not transparent
        montage ${JPGS[@]} -tile ${TILE_ARRAY[FILES]} \
        -geometry ${GEO_ARRAY[FILES]}+5+5 -background none miff:- |
        convert $WORK_DIR/pics/template.jpg \
        $WORK_DIR/title_txt.png  -gravity south -geometry +0+55 -composite \
        -  -gravity north -geometry +0+55 -composite \
        $WORK_DIR/example.jpg
        display $WORK_DIR/example.jpg
        echo
        echo -e "If you are happy with your preview, please proceed" 
        echo "without the -preview option"
        exit 0
    fi
fi

###############################################################################
#             get information about videos and store in an array              #
###############################################################################

for i in ${!VID_ARRAY[@]}; do
    mencoder_stats=( "${mencoder_stats[@]}" \
    "$(mencoder -quiet "${VID_ARRAY[i]}" -oac pcm -ovc copy -o /dev/null)" )
done
echo
echo $SEPARATOR
echo
# put in the log file in case anyone is interested
for i in ${!VID_ARRAY[@]}; do
    VCODEC="$(awk '/VIDEO:/ {gsub(/\[|\]/, ""); print $2}' \
    <<< "${mencoder_stats[i]}")"
    V_BR="$(awk '/Video stream:/{print $3}'<<<"${mencoder_stats[i]}")"
    ACODEC="$(awk  '/Selected audio codec/ {gsub(/\[|\]/, ""); print $4}' \
    <<< "${mencoder_stats[0]}")"
    A_BR="$(awk  '/AUDIO:/ {print $7}' <<< "${mencoder_stats[i]}")"
    if [ -z "$A_BR" ]; then
        A_BR="No audio found"
    fi
    V_LENGTH="$(awk '/Video stream:/{print $10}'<<<"${mencoder_stats[i]}")"
    FPS="$(awk '/VIDEO:/ {print $6}' <<<"${mencoder_stats[i]}")"
    printf "%s\n\n" "$LINE" "$LINE" >> $ANIMENU_LOG
    echo -e "Stats for" "${VID_ARRAY[i]}" "\n" \
    "video codec:   " \
    "$VCODEC" "\n" \
    "video bitrate: " "$V_BR" "kbps" "\n" \
    "framerate:     " "$FPS" "fps" "\n" \
    "audio codec:   " \
    "$ACODEC" "\n" \
    "audio bitrate: " \
    "$A_BR" " kbps" "\n" \
    "video length:  " \
    "$V_LENGTH" " seconds" "\n" |tee -a $ANIMENU_LOG
done
echo
echo $SEPARATOR

for i in ${!mencoder_stats[@]}; do
    VID_LEN=( ${VID_LEN[@]}  "$(awk '/Video stream:/{print $10}' \
    <<<"${mencoder_stats[i]}")" )
done

for i in ${!VID_LEN[@]}; do
    NEW_LENGTH=( ${NEW_LENGTH[@]}   ${VID_LEN[i]%.*} )
done
# find out longest video and shortest video 
for ((i=0; i<${#NEW_LENGTH[@]}; i++)); do
    val=${NEW_LENGTH[i]}
    [ -z "$MAX_VAL" ] || ((val > MAX_VAL)) && MAX_VAL=$val && max_key=$i
    if $ANI_SUB_MENU; then 
        [ -z "$MIN_VAL" ]  || ((val < MIN_VAL)) && MIN_VAL=$val && min_key=$i
    fi
done
# if shortest is less than 340 frames * $CHAPTERS then no animated submenu
if $ANI_SUB_MENU && [ $MIN_VAL -lt $(((340 * CHAPTERS) / 30)) ]; then
    echo -n "Sorry, the shortest length video must be greater than "
    echo "$(((340 * CHAPTERS) / 30)) seconds"
    echo "to use animated submenus."
    echo "${VID_ARRAY[min_key]} is only $MIN_VAL seconds long"
    exit 1
fi 
# allow animated menus of length of longest video
MAX_ANI_LENGTH=$(awk -v fr=$FRAME_RATE -v al=$ANI_MENU_LENGTH 'BEGIN { printf("%d\n", (fr*al)); }')
MAX_VAL_FRAMES="$(($MAX_VAL * 30))"
if [ $MAX_VAL_FRAMES -lt $MAX_ANI_LENGTH ]; then
    MAX_ANI_LENGTH=$MAX_VAL_FRAMES
fi

ANI_FRAMES=$MAX_ANI_LENGTH

###############################################################################
#                           End of info block                                 #
###############################################################################

###############################################################################
#                       work on the clip title images                         #
###############################################################################

# create the pics for background image and move to proper pics/ dir
echo
echo "Creating JPEGs from each video for the main menu"
for ((i=0; i<=FILES; i++)) ; do
#    CREATE_JPG_CMD=(transcode -q 0 -i ${VID_ARRAY[i]} \
#    -c 90-$(($MAX_ANI_LENGTH + 90))
#    -o $WORK_DIR/pics/$i/pic -f 29.970  -j 72,72 -Z "$INTRO_SIZE" -y jpg,null)

    CREATE_JPG_CMD=(ffmpeg -i "${VID_ARRAY[$i]}"  $SEEK -vframes $ANI_FRAMES \
    -s "$INTRO_SIZE" "$WORK_DIR/pics/$i/%d.jpg")
    printf "%s\n\n" "$LINE" "$LINE" >> $ANIMENU_LOG
    echo -e "\nRunning: ${CREATE_JPG_CMD[@]}\n" | fold -bs >> $ANIMENU_LOG

    SED_VAR="frame="
    if "${CREATE_JPG_CMD[@]}" >> $ANIMENU_LOG.tmp 2>&1;then
        cleanlog 3
    else
        cleanlog 3
        OUTPUT="There was a problem creating jpegs from the video.\n \
        Please see the output of $ANIMENU_LOG"
        SORRY_MSG=$OUTPUT
        sorry_msg
        exit 1
    fi

done
# extract jpegs from the provided background video
    if [ -z "$BG_PIC" ]; then
        echo
        echo "Creating a black background"
        BG_PIC="$WORK_DIR/pics/template.jpg"
        convert  -size $VID_SIZE_OPT xc:"#161514" "$BG_PIC"
        cp "$BG_PIC" "$WORK_DIR/submenu_template.jpg"
    else
        convert -resize $VID_SIZE_OPT! "$BG_PIC" "$WORK_DIR/pics/template.jpg"
        convert -size $VID_SIZE_OPT xc:"#161514" "$WORK_DIR/submenu_template.jpg"
    fi

echo
echo "Creating a gradient image for fancy titling"
convert -size 1x512 gradient: -rotate 90 +matte \
-fx '3.5u^3 - 5.05u^2 + 2.05u + 0.3' \
-size 512x1 xc:"#08447B" -compose Overlay -composite "$GRADIENT"


##############################################################################
#                     spumux and dvdauthor stuff                             #
##############################################################################
echo
echo "Creating the highlight and selection PNGs for the main menu"
GEO="${GEO_ARRAY[FILES]/x/,}"
SELECT_CMD="-size "${GEO_ARRAY[FILES]}+5+5" xc:none -fill none +antialias \
-stroke '#DE7F7C' -strokewidth 4 -draw 'rectangle 0,0 $GEO'"
HIGHLIGHT_CMD="-size "${GEO_ARRAY[FILES]}+5+5" xc:none -fill none +antialias \
-stroke '#188DF6' -strokewidth 4 -draw 'rectangle 0,0 $GEO'"
eval convert "$SELECT_CMD" -colors 3 "$WORK_DIR/Selectx1.png"
eval convert "$HIGHLIGHT_CMD" -colors 3 "$WORK_DIR/Highlightx1.png"

for button in Select Highlight; do
    montage -background none \
    $(for ((i=0; i<=FILES; i++)); do echo $WORK_DIR/${button}x1.png;done) \
    -tile ${TILE_ARRAY[FILES]} -geometry ${GEO_ARRAY[FILES]}+5+5 \
    -bordercolor none -mattecolor transparent miff:- |
    convert  -colors 3 -size 720x480 xc:none - -gravity north -geometry +0+55 \
    -composite  "$WORK_DIR/${button}.png"
done

if $SUB_MENU; then
    echo
    echo "Creating the highlight and selection PNGs for the submenus"
    GEO="${GEO_ARRAY[CHAPTERS - 1]/x/,}"
    SELECT_CMD="-size "${GEO_ARRAY[CHAPTERS - 1]}+5+5" xc:none -fill none \
    +antialias -stroke '#DE7F7C' -strokewidth 4 -draw 'rectangle 0,0 $GEO'"
    HIGHLIGHT_CMD="-size "${GEO_ARRAY[CHAPTERS - 1]}+5+5" xc:none -fill none \
    +antialias -stroke '#188DF6' -strokewidth 4 -draw 'rectangle 0,0 $GEO'"
    eval convert "$SELECT_CMD" -colors 3 "$WORK_DIR/Submenu_Selectx1.png"
    eval convert "$HIGHLIGHT_CMD" -colors 3 "$WORK_DIR/Submenu_Highlightx1.png"
    for button in Select Highlight; do
        montage -background none \
        $(for ((i=0; i<CHAPTERS; i++)); do
        echo $WORK_DIR/Submenu_${button}x1.png;done) \
        -tile ${TILE_ARRAY[CHAPTERS - 1]} \
        -geometry ${GEO_ARRAY[CHAPTERS - 1]}+5+5 \
        -bordercolor none -mattecolor transparent miff:- |

        convert  -colors 3 -size 720x480 xc:none  - \
        -gravity north -geometry +0+55  \
        -composite  $WORK_DIR/Submenu_${button}.png
    done
fi

# make appropriate chapter lengths for each video
# get chapter lengths by dividing by $CHAPTERS, then getting running totals
for i in ${!NEW_LENGTH[@]}; do
  CHAPT_INTERVALS=( ${CHAPT_INTERVALS[@]} $(( ${NEW_LENGTH[i]} / $CHAPTERS)) )
done

# and format in HH:MM:SS
for len in ${CHAPT_INTERVALS[@]}; do
    L=( ${L[@]} $(for ((i=1; i<CHAPTERS; i++)) ; do echo "$len";done) )
    chapt_intervals=$(running_total <<< ${L[@]})
    chapters="$(for c in $chapt_intervals; do echo $(format_seconds $c); done)"
    chapters="00:00:00.000 $chapters"
    CHAPTS=$(for i in $chapters; do echo -n $i,;done|sed 's/,$//')
    CHAPT_ARRAY=( ${CHAPT_ARRAY[@]} $CHAPTS )
    unset L chapt_intervals cmd
done
# debug chapters
for i in ${!VID_ARRAY[@]}; do
    echo -e "Chapters for "${VID_ARRAY[i]}" are: \n${CHAPT_ARRAY[i++]}\n"
done
# make xml files, and run dvdauthor and spumux
if $MENU_FADE; then
    . animenu-fade-routine
    END_TIME=$(format_seconds $THUMBS_FADE_OUT_END_TIME)
    END=" end=\"$END_TIME\""
    START=$(format_seconds $THUMBS_FADE_IN_START_TIME)
    PAUSE_TIME="6"
    POST="<post> jump cell 1; </post>"
    MAIN_POST="        <post> jump cell 1; </post>"
else
    PAUSE_TIME="inf"
    unset END
    START="00:00:00.0"
fi

(
    cat <<EOF
<subpictures>
   <stream>
     <spu force="yes" start="$START"$END
          highlight="$WORK_DIR/Highlight.png"
          select="$WORK_DIR/Select.png"
          autooutline="infer"
          autoorder="rows"/>
   </stream>
 </subpictures>
EOF
)  > "$SPUMUX_XML"
# make submenu spumux.xml
if $SUB_MENU; then
(
    cat <<EOF
<subpictures>
   <stream>
     <spu force="yes" start="00:00:00.0"
          highlight="$WORK_DIR/Submenu_Highlight.png"
          select="$WORK_DIR/Submenu_Select.png"
          autooutline="infer"
          autoorder="rows"/>
   </stream>
 </subpictures>
EOF
) > "$SUBMENU_SPUMUX_XML"
fi
if $SUB_MENU; then
    JUMP=menu
    POST="        <post> jump cell 1; </post>"
    if $ANI_SUB_MENU; then
        PAUSE=" pause=\"5\""
    else
        PAUSE=" pause=\"inf\""
        unset POST
    fi
else
    JUMP=title
fi
# make dvdauthor.xml
(
    cat <<EOF
<?xml version="1.0" encoding="utf-8"?>
<dvdauthor dest="$OUT_DIR" jumppad="1">
  <vmgm>
    <menus>
      <pgc>
        <post>jump titleset 1 menu;</post>
      </pgc>
    </menus>
  </vmgm>
  <titleset>
    <menus>
      <pgc>
$(for ((i=1; i<=$V_ARRAY_TOTAL; i++)); do
    if $SUB_MENU; then
        JUMP_INC=$(($i + 1))
    else
        JUMP_INC=$i
    fi
    echo -e "        <button name=\"$i\">jump $JUMP $JUMP_INC;</button>"
done)
        <vob file="$MENU_FILE" pause="$PAUSE_TIME"/>
$MAIN_POST
      </pgc>
$(if $SUB_MENU; then
    echo -ne "      <pgc>\n"
        for ((Y=1; Y<=$V_ARRAY_TOTAL; Y++)); do
            for ((i=1; i<=CHAPTERS; i++)); do
                echo -e "        <button name=\"$i\">jump title $Y chapter $i;</button>"
            done
            echo -e "        <vob file=\"$WORK_DIR/Menu$Y.mpg\"$PAUSE/>"
echo "$POST"
            echo "      </pgc>"
            echo "      <pgc>"
        done | sed '$d'
fi)    
    </menus>
    <titles>
$(for i in ${!VID_ARRAY[@]}; do
    echo -e "      <pgc>"
    echo -ne "        <vob file=\"${VID_ARRAY[i]}\""
    echo -e  " chapters=\""${CHAPT_ARRAY[i]}"\"/>"
    echo -e "        <post>call vmgm menu 1;</post>"
    echo -e "      </pgc>"
done)
    </titles>
  </titleset>
</dvdauthor> 
EOF
) |sed '/^$/d' >> "$DVDAUTHOR_XML"

##############################################################################
#                            Animenu stuff                                   #
##############################################################################

# do submenu 1st for debug purposes
if $SUB_MENU; then
    echo $SEPARATOR
    echo "Building submenus"
    echo $SEPARATOR
    echo "Creating JPEGs for each chapter"

    for i in ${!VID_ARRAY[@]}; do
        echo
        echo "Creating a transparent title PNG"
        convert -font "$TITLE_FONT" -pointsize $TITLE_FONT_SIZE -size 620x \
        -gravity Center caption:"\"${TITLES[i]}\"" -negate \( +clone -blur 0x8 \
        -shade 110x45 -normalize $GRADIENT -fx 'v.p{g*v.w,0}' \) +matte +swap \
        -compose CopyOpacity -composite  \
        \( +clone -fx A +matte -blur 0x2 -shade 0x90 -normalize \
        -blur 0x2 -negate -evaluate multiply .4 -negate +clone \
        -compose Multiply -composite \) -matte -compose In  -composite miff:- |
        convert -trim +repage - -blur 0.4x0.4 $WORK_DIR/title${i}_txt.png

        # which is harmless as they get removed, but needs to be tweaked         
        if $ANI_SUB_MENU; then    
            SM_MPLEX_OPTS=(-n 300)
            JPEG_IN=($WORK_DIR/animenu/%0d.jpg)
            JPEG_OUT=($WORK_DIR/animenu/chapt)
            CUT_TIME=340

        else  # not animated submenu
            SM_MPLEX_OPTS=(-n 1 -l 60)
            JPEG_IN=($WORK_DIR/submenu.jpg)
            JPEG_OUT=($WORK_DIR/chapt)
            CUT_TIME=1
        fi    

        counts=$((${CHAPT_INTERVALS[i]} * 30))
        CUT=( 0 $(running_total <<<  $(for ((a=0; a<CHAPTERS ; a++)); \
        do echo -n "$counts ";done)) )
        for c in ${!CUT[@]}; do
            cmd[c]=$((${CUT[c]}))-$((${CUT[c]} + CUT_TIME))
        done
        key=$((${#cmd[@]} - 1))
        unset cmd[key]
        CMD=${cmd[@]}
        TCODE_CMD=(transcode -i "${VID_ARRAY[i]}" -o "${JPEG_OUT[@]}" \
        -f 29.970 -J cut="$CMD" -y jpg,null)
        printf "%s\n\n" "$LINE" "$LINE" >> $ANIMENU_LOG
        echo "Running  "${TCODE_CMD[@]}"" >> $ANIMENU_LOG
        echo "Running  "${TCODE_CMD[@]}""
        if "${TCODE_CMD[@]}" 2>&1 >> $ANIMENU_LOG.tmp; then
            cleanlog 1
        else
            cleanlog 1
            OUTPUT="There was a problem creating jpegs from the video.\n \
            Please see the output of $ANIMENU_LOG"
            SORRY_MSG=$OUTPUT
            sorry_msg
            exit 1
        fi
        unset TCODE_CMD

        if $ANI_SUB_MENU; then
            # FIXME make sure $CHAPTERS number of jpegs got created
            # move 340 jpegs to each subdir:  $WORK_DIR/animenu/{0,1,2,3,etc}
            for ((a=0; a<CHAPTERS; a++)); do
                pics=( $(find $WORK_DIR/animenu/ -maxdepth 1 -name chapt\*.jpg|
                head -n 340) )
                for f in ${pics[@]}; do
                    mv $f $WORK_DIR/animenu/$a
                done
            done
            for ((a=0; a<CHAPTERS; a++)); do
                find $WORK_DIR/animenu/$a/ -name chapt\*.jpg|head -n 20|xargs rm
                find $WORK_DIR/animenu/$a/ -name chapt\*.jpg|tail -n 20|xargs rm
            done
            echo
            echo "Making montage images for  "${VID_ARRAY[i]}""

            for ((a=1; a<300; a++)); do
                for ((b=0; b<CHAPTERS; b++)); do
                    JPEGS=( "${JPEGS[@]}" $(find $WORK_DIR/animenu/$b \
                    -name \*.jpg|head -n $a|sed  -n -e "$a p") )
                done
                IM_CMD=(montage ${JPEGS[@]} -tile ${TILE_ARRAY[CHAPTERS - 1]} \
                -geometry ${GEO_ARRAY[CHAPTERS - 1]}+5+5 -bordercolor '#161514' \
                -mattecolor '#161514' -background '#161514' miff:-)
                IM_CMD2=(convert $WORK_DIR/submenu_template.jpg \
                $WORK_DIR/title${i}_txt.png  -gravity south \
                -geometry +0+55 -composite -  -gravity north -geometry +0+55 \
                -composite $WORK_DIR/animenu/$a.jpg)
 
                "${IM_CMD[@]}" | "${IM_CMD2[@]}"
                unset JPEGS
            done

            unset IM_CMD IM_CMD2 d f PIC
 
        else # not $ANI_SUB_MENU
            echo $SEPARATOR
            echo "Building submenus"
            echo $SEPARATOR
            echo "Creating JPEGs for each chapter"

            # just use $CHAPTERS number of jpegs
            jpegs=$(find $WORK_DIR -name chapt000\*.jpg|head -n $CHAPTERS)
            # create frames for the chapter thumbs
            for PIC in $jpegs; do
                convert -background '#141614' -frame 8x8 \
                -bordercolor none -mattecolor "#444744" $PIC $PIC
            done
            IM_CMD=(montage $jpegs -tile ${TILE_ARRAY[CHAPTERS -1]} -geometry \
            ${GEO_ARRAY[CHAPTERS - 1]}+5+5 -background '#141614' miff:-)
            IM_CMD2=(convert $WORK_DIR/submenu_template.jpg \
            $WORK_DIR/title${i}_txt.png  -gravity south -geometry +0+55 \
            -composite - -gravity north -geometry +0+55 -composite \
            $WORK_DIR/submenu.jpg)
            "${IM_CMD[@]}" | "${IM_CMD2[@]}"
        fi

        echo
        echo "Converting chapter montages of $i to m2v video format"

        jpeg2yuv -v 0 -f 29.970 -I p "${SM_MPLEX_OPTS[@]}" -L 1 -b1 \
        -j "${JPEG_IN[@]}" |
        ffmpeg   -f yuv4mpegpipe -i - -r 29.970 -s $VID_SIZE_OPT \
        -tvstd ntsc $FFMPEG_OPTS -y $WORK_DIR/menu$i.m2v
        rm -f $WORK_DIR/animenu/*.jpg
    done    

    # create silence for either animated or plain submenus
    for ((s=0; s<=FILES; s++)); do
        echo
        echo "Creating a silent audio background"
        TIME=`vid_length $WORK_DIR/menu$s.m2v`
        ffmpeg -f s16le -i /dev/zero -t $TIME \
        $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT
        unset TIME
#        command to use in for loop when SM_AUDIO is implemented
#        ffmpeg -i ${SM_AUDIO[s]} -ar 48000 -ac 2 -acodec pcm_s16le -y \
#        -t 20 $WORK_DIR/menu$s.wav
#        ffmpeg -i $WORK_DIR/menu$s.wav \
#        $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT
#        fi
        echo
        echo "Multiplexing video and audio together"
        S=$((s + 1))
        mplex -V -f $MPLEX_FORMAT -b 230 -o $WORK_DIR/menu$S.mpg \
        $WORK_DIR/menu$s.$AUDIO_EXT $WORK_DIR/menu$s.m2v
    done
fi

##############################################################################
#                      Work on main menu                                     #
##############################################################################
echo $SEPARATOR
echo "Building main menu"
echo $SEPARATOR
echo
echo "Adding title to JPEGs and resizing"
for ((i=0; i<=FILES; i++)); do
    JPGS=( "${JPGS[@]}" \
    $(find $WORK_DIR/pics/$i -maxdepth 1 -name '*[1-9]*.jpg') )

    for jpg in "${JPGS[@]}"; do
        montage -geometry +4+4 -background '#161514' \
        -fill '#C6C6C6' -pointsize 22 -title "${TITLES[i]}"  $jpg miff:- |
        convert -background '#161514' -frame 8x8 \
        -bordercolor none -mattecolor "#444744" - miff:- |
        convert -resize $INTRO_SIZE! - $jpg
    done

    # make sure all animated thumbs finish at the same time 
    JPEGS=( "${JPEGS[@]}" \
    $(find $WORK_DIR/pics/$i -maxdepth 1 -name '*[1-9]*.jpg') )
    last_jpg=${#JPEGS[@]}
    next_jpg=$(($last_jpg + 1))
    if [ $last_jpg -lt $MAX_ANI_LENGTH ]; then
        for ((l=next_jpg; l<=MAX_ANI_LENGTH; l++)); do
            cp $WORK_DIR/pics/$i/${last_jpg}.jpg $WORK_DIR/pics/$i/$l.jpg
        done
    fi
    unset JPGS JPEGS last_jpg next_jpg
done

if $MENU_FADE; then
    echo
    echo "making final montages and compositing onto background with title"
    for ((frame=0; frame<=ANI_MENU_END_FRAME; frame++)); do
        # copy template for fade out beginning and end frames
        cp $WORK_DIR/pics/template.jpg $WORK_DIR/bg/$(($frame + 1)).jpg
    done
      
    for ((frame=0; frame<=BACKGROUND_FADE_IN_END_FRAME; frame++)); do
        D=`get_bg_opacity`
        composite -dissolve $D $WORK_DIR/bg/$(($frame + 1)).jpg $WORK_DIR/black.jpg \
        $WORK_DIR/bg/$(($frame + 1)).jpg
    done
    for ((frame=BACKGROUND_FADE_OUT_START_FRAME; frame<=BACKGROUND_FADE_OUT_END_FRAME; frame++)); do
        D=`get_bg_opacity`
        composite -dissolve $D $WORK_DIR/bg/$(($frame + 1)).jpg $WORK_DIR/black.jpg \
        $WORK_DIR/bg/$(($frame + 1)).jpg
    done

    for ((frame=0; frame<=ANI_MENU_END_FRAME; frame++)); do
        # set dissolve vars from animenu-fade-routine functions
        BC=$(get_title_opacity)
        B=$(awk -F ':' '{print $1'}<<<$BC)
        C=$(awk -F ':' '{print $2'}<<<$BC)
        S=$(get_thumb_opacity)

        ANI_PICS=( $(find $WORK_DIR/pics/*[0-9]* -maxdepth 1 -name $((frame + 1)).jpg) )
        BG_PIC=$(find $WORK_DIR/bg -name $(($frame + 1)).jpg)
        # create the montage from the JPEGS in each video dir
        MONTAGE_CMD1=(montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[FILES]} \
        -geometry ${GEO_ARRAY[FILES]}+5+5 -background none)
        #  dissolve the finished montages onto the background
        MONTAGE_CMD2=(composite -dissolve $S -gravity north \
        -geometry +0+55 - $WORK_DIR/bg/$(($frame + 1)).jpg -background none)
        # if MIST is called for, this dissolves the mist onto the background
        MONTAGE_CMD3=(composite -dissolve $B -gravity south -geometry +0+50 \
        $WORK_DIR/white.png -)
        # finally, we dissolve the title onto the MIST (or plain background)
        MONTAGE_CMD4=(composite -dissolve $C -gravity south -geometry +0+55 \
        $WORK_DIR/title_txt.png - -background none $WORK_DIR/animenu/$(($frame + 1)).jpg)
        # pipe all of above commands if using MIST
        if $MIST; then
            # debug echo only
#            echo "Running "${MONTAGE_CMD1[@]}" miff:- | "${MONTAGE_CMD2[@]}" miff:- |"
#            echo  ""${MONTAGE_CMD3[@]}" miff:- | "${MONTAGE_CMD4[@]}""
            "${MONTAGE_CMD1[@]}" miff:- | "${MONTAGE_CMD2[@]}" miff:- |
            "${MONTAGE_CMD3[@]}" miff:- | "${MONTAGE_CMD4[@]}"
        else  # no mist: pipe all commands but the mist command
             "${MONTAGE_CMD1[@]}" miff:- | "${MONTAGE_CMD2[@]}" miff:- |
            "${MONTAGE_CMD4[@]}"
        fi
    done
# copy a few black frames to make sure end frame is really "black"
for ((i=ANI_MENU_END_FRAME; i<ANI_MENU_END_FRAME+6; i++)); do
    cp $WORK_DIR/black.jpg $WORK_DIR/animenu/$i.jpg
done
else # Don't do menu fade
    if $TRANSPARENT; then
         for (( count=1; count<=$MAX_ANI_LENGTH; count++)); do
            ANI_PICS=$(find $WORK_DIR/pics/*[0-9]* -maxdepth 1 -name $count.jpg)
            IM_CMD=(montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[FILES]} \
            -geometry ${GEO_ARRAY[FILES]}+5+5 -background none miff:-)
            IM_CMD2=(composite -dissolve $DISSOLVE \
            -gravity north -geometry +0+55 - \
            $WORK_DIR/pics/template.jpg -background none miff:-)
            IM_CMD3=(convert - $WORK_DIR/title_txt.png  \
            -gravity south -geometry +0+55 -composite \
            $WORK_DIR/animenu/$count.jpg )
            "${IM_CMD[@]}" | "${IM_CMD2[@]}" | "${IM_CMD3[@]}"
            rm -f ${ANI_PICS[@]}
        done
    else # Not transparent
        echo
        echo "making final montages and compositing onto background with title"
        for (( count=1; count <= $MAX_ANI_LENGTH; count++)); do
            ANI_PICS=$(find $WORK_DIR/pics/*[0-9]* -maxdepth 1 -name $count.jpg)

            # make final montages and composite onto grey background with title
            IM_CMD=(montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[FILES]} \
            -geometry ${GEO_ARRAY[FILES]}+5+5 -background none miff:-)
            IM_CMD2=(convert $WORK_DIR/pics/template.jpg \
            $WORK_DIR/title_txt.png  -gravity south -geometry +0+55 -composite \
            -  -gravity north -geometry +0+55 -composite \
            $WORK_DIR/animenu/$count.jpg)

            "${IM_CMD[@]}" | "${IM_CMD2[@]}"
            rm -f ${ANI_PICS[@]}
        done
    fi    
fi

echo
echo "converting JPEGS to video stream & encoding to dvd complient m2v video"
# convert jpegs to video stream and encode to dvd complient m2v
if $BLACKEN; then
    offset="30" # skip 1st 30 black frames as there is no mist effect
else
    offset="1"
fi
ENC_CMD1=(jpeg2yuv -v 0 -f 29.970 -I p -L 1 -b${offset} \
-j $WORK_DIR/animenu/%0d.jpg)
ENC_CMD2=(ffmpeg   -f yuv4mpegpipe -i - -an -r 29.970 -s $VID_SIZE_OPT \
-tvstd ntsc $FFMPEG_OPTS -y $WORK_DIR/intro.m2v)
printf "%s\n\n" "$LINE" "$LINE" >> $ANIMENU_LOG
if "${ENC_CMD1[@]}" | "${ENC_CMD2[@]}" >> $ANIMENU_LOG.tmp 2>&1; then
    cleanlog 3
else
    cleanlog 3
    sorry_msg
    exit 1
fi

echo
echo "Cleaning up montage JPEGs"
rm -fr $WORK_DIR/animenu/*.jpg

# create silence for the main menu
TIME=`vid_length "$WORK_DIR/intro.m2v"`
if [ -z "$BG_AUDIO" ]; then
    cat /dev/zero | nice -n 0 sox -t raw -c 2 -r 48000 -w \
    -s - $WORK_DIR/intro.wav  trim 0 $TIME
else
    ffmpeg -i "$BG_AUDIO" -ar 48000 -ac 2 -acodec pcm_s16le -y \
    -t $TIME $WORK_DIR/intro.wav
    if $AUDIO_FADE; then
        echo -e "Running:
        sox $WORK_DIR/intro.wav \
        $WORK_DIR/intro-processed.wav fade t 0 $TIME $FADE"

        sox $WORK_DIR/intro.wav \
        $WORK_DIR/intro-processed.wav fade t 0 $TIME $FADE
        rm $WORK_DIR/intro.wav
        mv $WORK_DIR/intro-processed.wav $WORK_DIR/intro.wav
    fi
fi
unset TIME

# convert to proper audio format
ffmpeg -i $WORK_DIR/intro.wav \
$AUDIO_OPTS -y $WORK_DIR/intro.$AUDIO_EXT

echo
echo "Multiplexing main menu audio and video together"
# mplex main menu audio and video together
INTRO_MPLEX_CMD="mplex -V -f $MPLEX_FORMAT -b 230 -o $WORK_DIR/intro.mpg \
$WORK_DIR/intro.$AUDIO_EXT $WORK_DIR/intro.m2v"
echo -e "\nRunning: $INTRO_MPLEX_CMD\n" >> $ANIMENU_LOG.tmp 
cleanlog 1
printf "%s\n\n" "$LINE" "$LINE" >> $ANIMENU_LOG
if ${INTRO_MPLEX_CMD[@]} >> $ANIMENU_LOG.tmp 2>&1; then
    cleanlog 1
else
    cleanlog 1
    sorry_msg
    exit 1
fi

echo
echo "Running spumux to create the main menu"
spumux "$SPUMUX_XML" < $WORK_DIR/intro.mpg > "$MENU_FILE"
if test -f "$MENU_FILE"; then
    echo "Menu file $MENU_FILE created"
else
    echo "Menu file $MENU_FILE is missing!"
fi

if $SUB_MENU; then
    echo "Creating submenus"
    for i in $(find $WORK_DIR/ -name menu[0-9]\*.mpg); do
        spumux "$SUBMENU_SPUMUX_XML" < $i > ${i/menu/Menu}
    done
fi
echo "Running dvdauthor to create the DVD filesystem"
dvdauthor -x "$DVDAUTHOR_XML"

SCRIPT_END_TIME=`date +%s`
SCRIPT_TOT_TIME=`expr $SCRIPT_END_TIME \- $SCRIPT_START_TIME`
HHMMSS=`format_time $SCRIPT_TOT_TIME`

cleanup
echo $SEPARATOR
echo "animenu took $HHMMSS to finish on $CPU_MODEL $CPU_SPEED mhz"
echo $SEPARATOR
echo "Your new DVD should be in $OUT_DIR"
echo
echo "Thanks for using animenu."

