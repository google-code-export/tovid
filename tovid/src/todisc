#!/usr/bin/env bash
ME="[todisc]:"
. tovid-init
# todisc
# Part of the tovid suite
# =======================
# A bash script for generating a DVD with animated thumbnail menus
# from a collection of MPEG video files.
#
# Project homepage: http://www.tovid.org
#
#
# Copyright (C) 2005 tovid.org <http://www.tovid.org>
#
# This program is free software; you can redistribute it and/or
# modify it under the terms of the GNU General Public License
# as published by the Free Software Foundation; either
# version 2 of the License, or (at your option) any later
# version.
#
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
#
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. Or see:
#
#           http://www.gnu.org/licenses/gpl.txt


# Mostly written by Robert Sohn:
#     <grepper@gmail.com>
#     grepper on irc.freenode.net

SCRIPT_NAME=`cat << EOF
--------------------------------
todisc
Generate a DVD filesystem with animated thumbnail menus
Part of the tovid suite, version $TOVID_VERSION
$TOVID_HOME_PAGE
--------------------------------
EOF`

USAGE=`cat << EOF
Usage:
    todisc [OPTIONS] \\\\
      -files File1.mpg File2.mpg ... \\\\
      -titles "Title 1" "Title 2" ... \\\\
      -out OUT_PREFIX
Input files must be MPEG, and the number of -files and -titles must be equal.
See the todisc manual page ('man todisc') for additional documentation.

EOF`
# check if symlink in /tmp exists and use time stamped link if so
WORK_DIR="/tmp/todisc-work"
for link in $(find /tmp -maxdepth 1 -name todisc-work\* -type l 2>/dev/null ); do
    [ -h "$link" ] && { WORK_DIR=/tmp/todisc-work$((NUM++)); continue; }
done
CUR_DIR="$(abspath "$(pwd)")"
# make unique REAL_WORK_DIR
REAL_WORK_DIR="$CUR_DIR/todisc-work"
for dir in "$REAL_WORK_DIR"*; do
    [ -d "$dir" ] && { REAL_WORK_DIR="$(pwd)"/todisc-work$((NUM++))
    continue; }
done
LOG_FILE="$(abspath "todisc.log")"
OUT_PREFIX=""
TV_STANDARD=ntsc
ANI_MENU_LENGTH=20
ANI_SUBMENU_LENGTH=10
MAX_ANI_LENGTH=""
TARGET=dvd
FRAME_RATE=29.970  # when -ntsc and -pal options added put in body in if block
VIDSIZE=720x480
VMGM_TITLE="My Video Collection"
SPUMUX_XML="$WORK_DIR/spumux.xml"
DVDAUTHOR_XML="$WORK_DIR/dvdauthor.xml"
STATIC=false
SUB_MENU=false
ANI_SUB_MENU=false
TITLE_COLOUR="#CDC0B0"
SM_TITLE_COLOUR="#CDC0B0"
THUMB_BG_COLOUR=white
THUMB_TEXT_COLOUR=""
BUTTON_STYLE="rect"
MIST_COLOUR=white
MIST_OPACITY=60
STROKE=""
SUBMENU_STROKE="none"
BG_AUDIO=""
BG_PIC=""
BG_VIDEO=""
SHOWCASE=false
SUBMENU_AUDIO=false
SM_AUDIO_FADE=:
SM_FADE=1
AUDIO_FADE=:
OPACITY=100
MENU_FADE=false
TRANSPARENT=false
PREVIEW=:
PAUSE_TIME=10
STATIC_LOOP=false
MIST=false
FEATHER=false
BLUR=4
SUB_MENU_FEATHER=false
IMG_FMT=jpg
SM_IMG_FMT=jpg  # submenu image format
KEEP_FILES=false
THUMB_SHAPE=""
SEEK_VAL=2
FADE=1
CHAPTERS=( 6 )
TOVID_OPTS=""
CHAIN_VIDEOS=false
NOASK=false
SMALL_FONTSIZE=false
SC_FRAMESTYLE=none
THUMB_FRAME="-frame 3x3"
SC_FRAME="-frame 3x3"
SHOWCASE_VIDEO=""
THREExONE=false
PLAYALL=false
USE_MAKEMENU=false
THUMBS_3D=false
RAISE=""
CURVE_UPDATE=""
SUBTITLES=false
AUDIOLANG=false
USER_BSTYLE=false
SHOWCASE_SEEK_VAL=2
BG_SEEK=2
BG_AUDIO_SEEK=2
NO_SC_THUMB=false
NO_THUMBS=false
SC_TITLE_ALIGN=centre
THUMB_TITLE_ALIGN=center
ALIGN_OVERRIDE=false
MULTILINE_TITLE=false
SAFE_AREA=50 # undocumented: you can set this from CLI with -showcase-safe-area
SAFE_OFFSET=36
PREVIEW_SIZE=720x540
ASPECT_RATIO=4:3
ASPECT_ARG=all
WIDE_SCREEN=false
WIDESCREEN="nopanscan"
WIDESCREEN_ARG=all
TEXTMENU=false
GROUPING=false
TEXT_Y_START=50
BUTTON_GRAVITY=north
XGEO=0
YGEO=45
USER_GRAVITY=false
USER_GEO=false
USER_SPLIT=false
TITLE_GRAVITY=south
SPACER=15
SELECT_COLOUR="#DE7F7C"
HIGHLIGHT_COLOUR="#266CAE"
BG_ASYNC=""
SCRIPT_START_TIME=`date +%s`

##############################################################################
#                                 Functions                                  #
##############################################################################

# Y-echo: echo to two places at once (stdout and logfile)
# Output is preceded by the script name that produced it
# Args: $@ == any text string
# If no args are given, echo a separator bar
# Use yecho if you want output to go to the logfile
function yecho()
{
    if test $# -eq 0; then
        printf "\n%s\n\n" "$SEPARATOR"
        # If logfile exists, copy output to it (with pretty formatting)
        test -e "$LOG_FILE" && \
            printf "%s\n%s %s\n%s\n" "$ME" "$ME" "$SEPARATOR" "$ME" >> "$LOG_FILE"
    else
        echo "$@" | sed "s/    */ /g;s/^ *//"|fold -bs
        test -e "$LOG_FILE" && \
            printf "%s %s\n" "$ME" "$@" | sed "s/    */ /g;s/^ *//"|fold -bs >> "$LOG_FILE"
    fi
}

# ******************************************************************************
# Execute the given command-line string, with appropriate stream redirection
# Args: $@ == text string containing complete command-line
# Returns: Exit status of the subprocess
# To filter/prettify the subprocess output before writing it to the log file,
# set the LOG_FILTER variable before calling this function, to e.g.
#    LOG_FILTER="sed 's/\r/\r\n/g'"    # Replace LF with CR/LF
# ******************************************************************************
function cmd_exec()
{
    eval "$@" 2>&1 | ${LOG_FILTER:=cat} # >> "$LOG_FILE"
    # Return exit status
    return $?
}

# Print script name, usage notes, and optional error message, then exit.
# Args: $@ == text string(s) containing error message and help
function usage_error ()
{
    MESSAGE=( "$@" )
    printf "%s\n%s\n%s\n\n" "$USAGE" "$SEPARATOR" "***"
    for ((i=0; i<$#; i++)) ; do printf "%s" "${MESSAGE[i]}"; done |fold -bs
    printf "\n\n%s\n" "***"
    rm -rf "$REAL_WORK_DIR" "$WORK_DIR"
    exit 1
}
function titlesafe_error()
{
    echo "********* WARNING *********"
    yecho "thumb title is $1 pixels from screen edge"
    yecho "Part of the title may not be visible on your tv screen"
    yecho "Consider using a smaller -thumb-fontsize, or shortening \"${TITLES[i]}\""
    echo "****************************"
    sleep 3
}
# process $LOG_FILE.tmp variously - eg. output of ffmpeg is ugly without this
function cleanlog()
{
    SED_VAR=${SED_VAR:-"frame="}
    FOLD="fold -bs"
    NO_CR="tr -d '\r'"
    RELINE="{s/$SED_VAR/\n$SED_VAR/g}"
    TMP_LOG="$LOG_FILE.tmp"
    NOSPACE="tr -s ' '"

    case "$1" in
        1 )
            $FOLD "$TMP_LOG" >> "$LOG_FILE"
            echo >> "$LOG_FILE"
            ;;
        2 )
            $NO_CR < "$TMP_LOG" | $FOLD >> "$LOG_FILE"
            echo >> "$LOG_FILE"
            ;;
        3 )
            $NO_CR < "$TMP_LOG" | sed $RELINE | $FOLD >> "$LOG_FILE"
            echo >> "$LOG_FILE"
            ;;
        4 )
            $NOSPACE < "$TMP_LOG" | $FOLD >> "$LOG_FILE"
            ;;
    esac
    rm -f "$LOG_FILE.tmp"
}
function format_output()
{
    sed "s/    */ /g;s/^ *//"|fold -bs
}

function get_font()
{
    # If there is a filename extension, find the absolute path
    if echo "$1" | grep -q '\...*$'; then
        echo $(abspath "$1")
    # Otherwise, use the literal name
    else
        echo "$1"
    fi
    # TODO: Check for font availability?
}

# ******************************************************************************
# Print out a runtime error specified as an argument, and exit
# ******************************************************************************
function runtime_error()
{
    # Uncomment if needed later
    #killsubprocs
    echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    yecho "todisc encountered an error:"
    yecho "    $@"
    echo "Check the contents of $LOG_FILE to see what went wrong."
    echo "See the tovid website ($TOVID_HOME_PAGE) for what to do next."
    echo "Sorry for the inconvenience!"
    echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    exit 1
}

function vid_length()
{
    yecho "Running mencoder "$1" -quiet -ovc copy -oac pcm -o /dev/null | awk '/Video stream/ {print $10}'" >> "$LOG_FILE"
    mencoder "$1" -quiet -ovc copy -oac pcm -o /dev/null 2>>"$LOG_FILE" | awk '/Video stream/ {print $10}'
}

function cleanup()
{
    echo
    yecho "Cleaning up..."
    if test -e "$WORK_DIR/tc_pids"; then
        TCPIDS=$(awk -F"=" '/pid=/ {print $2}' "$WORK_DIR/tc_pids" | cut -f1 -d')'|sort|uniq)
        for i in $TCPIDS; do
            if  kill -0 $i 2> /dev/null; then kill -9 $i 2> /dev/null;fi
        done
    fi
    if kill -0 $TCODE_PID 2> /dev/null; then kill -9  $TCODE_PID  2> /dev/null; fi
    if kill -0 $(</tmp/tcode.pid)  2> /dev/null; then kill -9 $(</tmp/tcode.pid)  2> /dev/null; fi
    if kill -0 $TRANSCODE_PID 2> /dev/null; then kill -9  $TRANSCODE_PID 2> /dev/null; fi
    if kill -0 $NS_PID 2> /dev/null; then kill -9 $NS_PID 2> /dev/null; fi
    if $KEEP_FILES; then
        yecho "Keeping temporary files in $REAL_WORK_DIR"
        [[ -n $SUPPORT_VIDEOS ]] && yecho "Keeping ${SUPPORT_VIDEOS[@]}" && \
            yecho "This sliced video will not work if todisc is run with different seeks so should be deleted manually"
    else
        yecho "Removing $REAL_WORK_DIR"
        [[ -n $SUPPORT_VIDEOS ]] && yecho "Removing "${SUPPORT_VIDEOS[@]}"" && rm -f "${SUPPORT_VIDEOS[@]}"
        rm -rf "$REAL_WORK_DIR"
    fi
    echo "Removing the symlink in /tmp . . . "
    rm -fv "$WORK_DIR"
}

function running_total ()
{
    awk -v offset=$offset '{
    for (i=1; i<=NF; i++) if (s=s+$i) printf("%s ",s);printf ("\n")}'
}

function awk_total()
{
    awk '{for (i=1; i<=NF; i++) s=s+$i}; END{print s}'
}

function format_seconds()
{
    awk '{
    hr=($1/3600); hd=(sprintf("%02d", hr))
    mr=((hr-hd)*60); md=(sprintf("%02d", mr))
    s=((mr-md)*60); sd=(sprintf("%02d", s))
    t=(sprintf("%02d:%02d:%06.3f" ,hd,md,s)); print t}' <<< $1
}

function awk_math()
{
    if [ $2 = times ]; then
        OP=*
    elif [ $2 = by ]; then
        OP=/
    elif [ $2 = less ]; then
        OP=-
    elif [ $2 = plus ]; then
        OP=+
    fi
if [[ -n "$4" && "$4" = "float" ]]; then
    awk 'BEGIN { printf("'"$1"'" '$OP' "'"$3"'")"\n" ; exit  }'
else
    awk -v A=$1 -v B=$3 'BEGIN { printf("%d\n", (A '$OP' B)); }'
fi
}

function confirm_preview()
{
    yecho
    echo "If you are happy with the preview, type 'yes' to continue: "
    read input
    echo
    if [ ! -z "$input" -a "$input" = "yes" ]; then
        yecho "Preview OK, continuing."
        yecho
    else
        yecho "Preview not OK, exiting."
        echo -n "Deleting symlink in /tmp . . . "
        rm -fv "$WORK_DIR"
        if ! $KEEP_FILES; then
            echo -n "Deleting "$REAL_WORK_DIR" . . . "
            rm -fr "$REAL_WORK_DIR"
        fi
        yecho
        echo
        echo "Some configuration options to try, if things look bad:"
        echo "Color:"
        echo "    -title-color"
        echo "    -thumb-text-color"
        echo "Fonts:"
        echo "    -menu-font and -menu-fontsize"
        echo "    -thumb-font and -thumb-fontsize"
        echo "(or reduce thumb title lengths)"
        echo "If you get black frames, then look at the -seek option"
        echo "For other fine-tuning options, see 'man todisc'."
        exit 0
    fi
#    yecho
}

# Display (echo) a spinner with a message
SP=0
function spin()
{
    SPIN_CHARS=".oOo"
    SPINNER="${SPIN_CHARS:SP++%${#SPIN_CHARS}:1}"
    # Print spaces to overwrite previous line
    echo -ne "\r                                                            "
    echo -ne "\r$@ "
}

#EXPAND="expand=-6:-6,"
function get_framed_pics()
{
mplayer -ss $MPLAYER_SEEK_VAL -vo $VOUT -noconsolecontrols \
-vf ${EXPAND}rectangle=${FRAME_SIZE/x*}:${FRAME_SIZE/*x},rectangle=$(( ${FRAME_SIZE/x*} - D )):$(( ${FRAME_SIZE/*x} - D)),rectangle=$(( ${FRAME_SIZE/x*} - $((D * 2)) )):$(( ${FRAME_SIZE/*x} - $((D * 2)) )),rectangle=$(( ${FRAME_SIZE/x*} - $((D * 3)) )):$(( ${FRAME_SIZE/*x} - $((D * 3)) )) \
-ao null -zoom -x ${FRAME_SIZE/x*} -y ${FRAME_SIZE/*x}  -frames $FRAMES "$1"
}

# Create a text-only menu, using makemenu/makexml
function call_makemenu()
{
    # Assemble and run makemenu command
    MENU_OUT="${OUT_PREFIX}_menu"
    MAKEMENU="makemenu"
    for ((i=0; i<${#TITLES[@]}; i++)); do
        MAKEMENU="$MAKEMENU \"${TITLES[i]}\""
    done
    MAKEMENU="$MAKEMENU -textcolor \"$TITLE_COLOUR\""
    test -n "$BG_PIC" && MAKEMENU="$MAKEMENU -background \"$BG_PIC\""
    test -n "$MENU_FONT" && MAKEMENU="$MAKEMENU -font \"$MENU_FONT\""
    test -n "$MENU_FONTSIZE" && MAKEMENU="$MAKEMENU -fontsize \"$MENU_FONTSIZE\""
    MAKEMENU="$MAKEMENU -out $MENU_OUT"

    echo "Running the following makemenu command:"
    echo $MAKEMENU
    cmd_exec "$MAKEMENU"

    # Assemble and run makexml command
    MAKEXML="makexml -menu $MENU_OUT.mpg -out $OUT_PREFIX"
    for ((i=0; i<${#FILES[@]}; i++)); do
        MAKEXML="$MAKEXML \"${FILES[i]}\""
    done
    MAKEXML="$MAKEXML -out $OUT_PREFIX"
    echo "Running the following makexml command:"
    echo $MAKEXML
    cmd_exec "$MAKEXML"

    # Assemble and run makedvd command
    MAKEDVD="makedvd -author ${OUT_PREFIX}.xml"
    echo "Running the following makedvd command:"
    echo $MAKEDVD
    cmd_exec "$MAKEDVD"
}

function confirm_dep()
{
    if ! $(which $1 > /dev/null 2>&1); then
        yecho "The program $1 is not installed, please install it to use todisc"
        yecho "The $1 homepage is $2"
        exit 1
    fi
}

function stat_logfile()
{
     awk '/Modify/ {print $3}' <<< "$(stat "$LOG_FILE")"
}

function get_line_count()
{
awk 'END{print NR}' "$LOG_FILE"
}

function check_stall()
{
    PIDOF_TRANSCODE=$(</tmp/tcode.pid)
    newlines=$(stat_logfile)
    while ps -p $PIDOF_TRANSCODE >/dev/null; do
        # Check for transcode output every 10 seconds
        sleep 10
        age=$newage
        newage=$(stat_logfile)
        # If no new output, sleep 20s and check again
        [[ $newage = $age ]] && sleep 20 && newage=$(stat_logfile)
        # If still no new lines, send a HUP signal to transcode
        if [[ $newage == $age ]] && kill -0 $PIDOF_TRANSCODE > /dev/null 2>&1; then
            echo
            echo "*** transcode appears to be stalled ***"
            echo "*** We are going to send transcode a HUP and hope for the best ***"
            sleep 5
            $(kill -0 $PIDOF_TRANSCODE > /dev/null 2>&1) && kill -HUP $PIDOF_TRANSCODE
            echo
        fi
    done
}
function check_filetype()
{
    if [[ $(file "$1") = *image* ]]; then
#    if file "$1" |grep image; then
        TYPE=image
    elif mencoder -endpos 2 -oac pcm -ovc copy  "$1" -o /dev/null  >/dev/null 2>&1; then
        TYPE=video
    else TYPE=unknown
    fi
}

function get_stats()
{
unset IN_STATS FILES_IN
this_set=$1
if [[ $this_set = group ]]; then
    unset TOT IN_STATS FILES_IN
    TOT=${#grouping[@]} # || TOT=${#IN_FILES[@]}
    IN_STATS=( "${group_mencoder_stats[@]}" )
    FILES_IN=( "${grouping[@]}" )
    NAV=group_nav
    LENGTH=length
else
    TOT=${#IN_FILES[@]}
    IN_STATS=( "${mencoder_stats[@]}" )
    FILES_IN=( "${IN_FILES[@]}" )
    NAV=nav
fi

for ((i=0; i<TOT; i++)); do
    [[ $this_set = group ]] &&  LENGTH=${group_length[i]} || LENGTH=${length[i]}
    VCODEC="$(awk '/VIDEO:/ {gsub(/\[|\]/, ""); print $2}' \
    <<< "${IN_STATS[i]}")"
    V_BR="$(awk '/Video stream:/{print $3}'<<< "${IN_STATS[i]}")"
    ACODEC="$(awk  '/Selected audio codec/ {gsub(/\[|\]/, ""); print $4}' \
    <<< "${IN_STATS[i]}")"
    A_BR="$(awk  '/AUDIO:/ {print $7}' <<< "${IN_STATS[i]}")"
    if [ -z "$A_BR" ]; then
        A_BR="No audio found"
    fi
    if [ -e "$WORK_DIR/${NAV}${i}_log" ]; then
        V_LENGTH=$(awk_math $LENGTH by $FRAME_RATE float)
    else
        V_LENGTH=$(awk '/Video stream:/{print $10}'<<< "${IN_STATS[i]}")
    fi
    if [[ $this_set != group ]]; then
        if [[ ${V_LENGTH%.*} -lt ${SEEK_VAL[i]%.*} ]]; then
            usage_error "A seek of ${SEEK_VAL[i]} seconds is too large for ${IN_FILES[i]}. The file is only $V_LENGTH seconds long"
        fi
    fi
    FPS="$(awk ' /VIDEO/ { if ($_=="fps"); sub(/fps.*$/, ""); print $NF}' <<<"${IN_STATS[i]}")"
    yecho
    if [[ $this_set = group ]] && ((i == 0)); then
        echo; echo ". . . Grouped file stats . . ."; echo
    yecho
    fi
    [[ $this_set = group ]] && echo -e "Stats for" $(readlink "${FILES_IN[i]}") "\n" || \
    echo -e "Stats for" "${FILES_IN[i]}" "\n"
    echo -e  \
    " video codec:   " \
    "$VCODEC" "\n" \
    "video bitrate: " "$V_BR" "kbps" "\n" \
    "framerate:     " "$FPS" "fps" "\n" \
    "audio codec:   " \
    "$ACODEC" "\n" \
    "audio bitrate: " \
    "$A_BR" " kbps" "\n" \
    "video length:  " \
    "$V_LENGTH" " seconds" |tee -a "$LOG_FILE"
done
}

function check_compliance()
{
    $NOASK && NO_ASK="-noask"
    unset FILES_TO_ENCODE ENC_IN_FILES CHECK_IN_FILES
    group_set=false
    if [[ $1 = group ]]; then
        group_set=:
        unset x a
        CHECK_IN_FILES=( "${grouping[@]}" )
    else
        CHECK_IN_FILES=( "${IN_FILES[@]}" )
    fi
    for ((i=0; i<${#CHECK_IN_FILES[@]}; i++)); do
        IN_FILE="${CHECK_IN_FILES[i]}"
        $group_set && yecho "Checking "$(readlink $IN_FILE)" for compliance..."
        ! $group_set && yecho "Checking $IN_FILE for compliance..."
        # test files with idvid script
        if test "$(idvid -isformat $TARGET "$IN_FILE")" = "true" && \
           test "$(idvid -istvsys $TV_STANDARD "$IN_FILE")" = "true"; then
            ENC_IN_FILES=("${ENC_IN_FILES[@]}" "$IN_FILE")
        # Video needs to be re-encoded; use a .enc filename in ENC_IN_FILES
        else
            FILES_TO_ENCODE[i]="$IN_FILE"
            ENC_IN_FILES=("${ENC_IN_FILES[@]}" "$IN_FILE.enc.mpg")
        fi
    done
    if test "${#FILES_TO_ENCODE[@]}" -gt 0; then
        TGT_CAPS=$(echo $TARGET | tr a-z A-Z)
        TV_STND_CAPS=$(echo $TV_STANDARD | tr a-z A-Z)
        yecho
        yecho "Encode input files"
        yecho
        yecho "Some of the -files you provided are not $TV_STND_CAPS $TGT_CAPS-compliant:"
        yecho " "
        for i in "${FILES_TO_ENCODE[@]}"; do
            $group_set && this_file=$(readlink "$i") || this_file="$i"
            test -n "$this_file" && yecho " $this_file"
        done
        yecho " "
        if $NOASK; then
            echo "Converting files to $TV_STND_CAPS $TGT_CAPS-compliant format."
            echo "(This may take a long time)"
            ENCODE="yes"
        else
            yecho "I can encode them for you, but it may take a long time."
            yecho "Encoding will ensure that your disc is fully compliant;"
            yecho "you may skip this, but your disc may not be playable."
            yecho "Please type 'yes' if you want the files to be encoded:"
            read ENCODE
        fi
        if test -n "$ENCODE" && test "$ENCODE" = 'yes'; then
            yecho
            yecho "Converting files to $TGT_CAPS format with 'tovid'"
            for i in "${FILES_TO_ENCODE[@]}"; do
                $group_set && yecho "Converting $(readlink $i)" || yecho "Converting: $i"
                countdown
                $group_set && IN="$(readlink "$i")" || IN="$i"
                tovid $NO_ASK -$TV_STANDARD -$TARGET -in "$IN" -out "$IN.enc" $TOVID_OPTS
                wait
                # See if output file exists
                if ! test -f "$IN.enc.mpg"; then
                    runtime_error "Could not encode file: $i"
                fi
                yecho
            done
            # Replace IN_FILES with ENC_IN_FILES (with .enc extension)
            if $group_set; then
                for title in "${FILES_TO_ENCODE[@]}"; do
                    ln -sfv "$(readlink "${title}").enc.mpg" "$title"
                done
            else    
                 IN_FILES=("${ENC_IN_FILES[@]}")
            fi
        else
            yecho
            yecho "Not re-encoding. I will proceed with menu generation, but"
            yecho "your authored disc will not be fully $TGT_CAPS-compliant."
            yecho
        fi
    fi
}

function mk_workdir()
{
    if [[ -d "$REAL_WORK_DIR" && -z ${GROUP[@]} ]]; then
        echo "Removing existing files in \"$REAL_WORK_DIR\""
        rm -rf "$REAL_WORK_DIR"
    fi
    mkdir -pv "$REAL_WORK_DIR"
    if [[ -h "$WORK_DIR" && -z ${GROUP[@]} ]]; then
        echo -n "Removing existing symlink in /tmp . . . "
        rm -fv "$WORK_DIR"
    fi

    # link WORK_DIR to /tmp for easy solution to spaces, illegal chars bugs
    [[ -z ${GROUP[@]} ]] && ln -sfv "$REAL_WORK_DIR" "$WORK_DIR"
}

function get_group_chapters()
{
    FORMAT=false
    index=$1
    [[ -n $2 ]] && FORMAT=:
    unset chapt_len_array x len remainder t
    remainder=0
    chapter_length=$( bc <<< "scale=3; ${GROUP_TOT_LEN[index]} / ${CHAPTERS[index]}")
    GROUP_VIDEO_LENGTHS=( ${GROUP_VID_LENGTHS[index]} )

    for len in ${GROUP_VIDEO_LENGTHS[@]}; do #FIXME
        adjusted_length=$( bc <<< "scale=3; $len + $remainder" )
        num_chapters=$( bc <<< "$adjusted_length / $chapter_length" )
        if (( num_chapters > 0)); then
            chapt_len_array=( $( for ((t=0; t<num_chapters; t++)); do
            echo $chapter_length; done) )
            chapt_len_array=($(bc <<< "scale=3; $chapter_length - $remainder" ) ${chapt_len_array[@]})
            unset chapt_len_array[${#chapt_len_array[@]}-1]
            chapter_points=$( running_total <<< ${chapt_len_array[@]} )
            remainder=$( bc <<< "$adjusted_length % $chapter_length")
            group_chapters[x++]=$chapter_points
        else
            group_chapters[x++]=""
            remainder=$adjusted_length
        fi
        unset chapt_len_array t
    done
    unset remainder
    if $FORMAT; then
        for d in ${!group_chapters[@]}; do
            for number in ${group_chapters[d]}; do
                new_element="$new_element $(format_seconds $number),"
            done
            array[d]="$new_element"
            unset new_element
        done

        for e in ${!array[@]}; do
            points=$(for f in ${array[e]// /}; do echo -n $f;done)
            [[ -z ${array[e]} ]] && unset chpts[e] || chpts[e]="chapters=\"${points%,}\""
            [[ -n ${array[e]} ]] && chpts[e]=${chpts[e]#,}
            if ((e == 0)); then
                [[ -z "$points" ]] && chpts0="chapters=\"00:00:00\"" || chpts0="chapters=\"00:00:00,${points%,}\""
            fi
            chpts=${chpts[@]#,}
        done
    fi
}

function check_with_dvdauthor()
# usage ex. : for i in "${!IN_FILES[@]}; do
#    if ! check_with_dvdauthor >/dev/null 2>&1; then
#        do_something . . .
#    rm -fr "$OUT_DIR" etc etc
{
    dvdauthor -o $OUT_DIR -t "$1"
}

##############################################################################
#                          	End of functions                                 #
##############################################################################

trap 'cleanup; exit 13' TERM INT

###############################################################################
#       Process arguments to the script, set up VARS and WORK_DIR             #
###############################################################################

# ***********************************
# EXECUTION BEGINS HERE
# ***********************************

yecho $"$SCRIPT_NAME"

while test $# -gt 0; do
    DO_SHIFT=:
    case "$1" in
        "-files" )
            shift
            get_listargs "$@"
            for f in  ${!ARGS_ARRAY[@]}; do
                FILES[f]="$(abspath "${ARGS_ARRAY[f]}")"
            done
            ;;
        "-group" )
            shift
            mk_workdir
            get_listargs "$@"
            unset group groupkey grp x
            for ((i=1; i<${#ARGS_ARRAY[@]}; i++)); do
                grp[x++]="$(abspath "${ARGS_ARRAY[i]}")"
            done
            GROUP_IN_FILES=( "${GROUP_IN_FILES[@]}" "${grp[@]}" )
            group="$(for ((b=0; b<${#grp[@]}; b++)); do echo -e "${grp[b]}"; done)"
            groupkey=$(( ${ARGS_ARRAY[0]} - 1))
            GROUP[groupkey]="$group"
            # create symlinks to ease substitution later
            for c in ${!grp[@]}; do
                ln -sv "${grp[c]}" $WORK_DIR/group-$((groupkey+1))-$((c+1)).mpg
            done
            GROUPING=:
            ;;
        "-titles" )
            shift
            get_listargs "$@"
            OIFS=$IFS
            IFS=""
            TITLES=( "${ARGS_ARRAY[@]}" )
            IFS=$OIFS
            ;;
        "-submenu-titles" )
            shift
            get_listargs "$@"
            OIFS=$IFS;IFS=""
            SM_TITLES=( "${ARGS_ARRAY[@]}" )
            IFS=$OIFS
            ;;
        "-use-makemenu" )
            USE_MAKEMENU=:
            ;;
        "-out" )
            shift
            OUT_PREFIX="$1"
            ;;
        "-noask" )
            NOASK=:
            ;;
        "-keepfiles" )
            KEEP_FILES=:
            ;;
        "-dvd" )
            TARGET=dvd
            ;;
        "-svcd" )
            TARGET=svcd
            ;;
        "-ntsc" )
            TV_STANDARD=ntsc
            ;;
        "-pal" )
            TV_STANDARD=pal
            ;;
        "-aspect" )
            unset ASPECT ASPECT_ARG
            shift
            get_listargs "$@"
            ASPECT_ARGS=( ${ARGS_ARRAY[@]} )
            if [[ ${#ASPECT_ARGS[@]} -gt 0 ]]; then
                ASPECT=${ASPECT_ARGS[0]}
            fi
            if [[ ${#ASPECT_ARGS[@]} -gt 1 ]]; then
                ASPECT_ARG=${ASPECT_ARGS[1]}
            fi
            if [[ "$ASPECT_ARG" = all || "$ASPECT_ARG" = menu || -z "$ASPECT_ARG" ]]; then
                ASPECT_RATIO=$ASPECT
                M_ASPECT="aspect=\"$ASPECT\""
            fi
            if [[ "$ASPECT_ARG" = all || "$ASPECT_ARG" = video || -z "$ASPECT_ARG" ]]; then
                V_ASPECT="aspect=\"$ASPECT\""
            fi
            ;;
        "-widescreen" )
            WIDE_SCREEN=:
            unset WIDESCREEN WIDESCREEN_ARG
            shift
            get_listargs "$@"
            WIDESCREEN_ARGS=( ${ARGS_ARRAY[@]} )
            WIDE_SCREEN=:
            (( ${#WIDESCREEN_ARGS[@]} > 0)) && WIDESCREEN=${WIDESCREEN_ARGS[0]} || \
            WIDESCREEN=nopanscan; WS_ARG=all
            (( ${#WIDESCREEN_ARGS[@]} > 1)) && WS_ARG=${WIDESCREEN_ARGS[1]}
            ;;
        "-showcase-safe-area" )
            shift
            SAFE_AREA="$1"
            let SAFE_OFFSET=86-SAFE_AREA
            ;;
        "-align" )
            shift
            get_listargs "$@"
            ALIGN_ARGS=( ${ARGS_ARRAY[@]} )
            BUTTON_GRAVITY=${ALIGN_ARGS[0]}
            (( ${#ALIGN_ARGS[@]} > 1 )) && BUTTON_GEO=${ALIGN_ARGS[1]} && USER_GEO=:
            $USER_GEO && XGEO=${BUTTON_GEO/x*} && YGEO=${BUTTON_GEO/*x}
            [[ $BUTTON_GRAVITY = centre ]] && BUTTON_GRAVITY=center
            USER_GRAVITY=:
            ;;
        # Menu control options
        "-menu-length" )
            shift
            ANI_MENU_LENGTH="$1"
            ;;
        # submenu-length disabled for now
        "-submenu-length" )
            shift
            ANI_SUBMENU_LENGTH="$1"
            ;;
        "-static" )
            STATIC=:
            ;;
        "-bgimage" )
            usage_error "-bgimage This option has been removed. See: -background"
            ;;
        "-menu-fade" )
            MENU_FADE=:
            AUDIO_FADE=:
            ;;
        "-tile3x1" )
            THREExONE=:
            ;;
        "-loop" )
            shift
            PAUSE_TIME="$1"
            STATIC_LOOP=:
            ;;
        "-chain-videos" )
            shift
            get_listargs "$@"
            chains_in="${ARGS_ARRAY[@]}"
            post_play=${chains_in//,/ }
            CHAIN_VIDEOS=:
            ;;
        "-playall" )
            PLAYALL=:
            ;;
        "-bgvideo" )
            usage_error "-bgvideo This option has been removed. See: -background"
            ;;
        "-background" )
            shift
            BACKGROUND="$(abspath "$1")"
            ;;
        "-showcase-video" )
            usage_error "-showcase-video This option has been removed. See: -showcase"
            ;;
        "-showcase-image" )
            usage_error "-showcase-image This option has been removed. See: -showcase"
            ;;
        "-showcase-no-thumb" )
            usage_error "-showcase-no-thumb This option has been removed. See: -showcase"
            ;;
        "-intro" )
            shift
            INTRO_CLIP="$(abspath "$1")"
            INTRO="<vob file=\"$INTRO_CLIP\"/>"
            ;;
        "-showcase" )
            shift
            get_listargs "$@"
            unset f
            for f in  ${!ARGS_ARRAY[@]}; do
                SHOWCASE_FILE[f]="$(abspath ${ARGS_ARRAY[f]})"
            done
            SHOWCASE=:
            IMG_FMT=png
            ;;
        "-textmenu" )
            shift
            get_listargs "$@"
            arg=${ARGS_ARRAY[0]}
            [[ -n $arg ]] && SPLIT=$arg && USER_SPLIT=:
            TEXTMENU=:
            NO_THUMBS=:
            SHOWCASE=:
            IMG_FMT=png
            SC_TITLE_ALIGN=west
            ;;
        "-text-start" )
            shift
            TEXT_Y_START=$1
            ;;
        "-showcase-titles-align" )
            shift
            SC_TITLE_ALIGN="$1"
            ;;
        "-rotate" )
            shift
            ROTATE_DEGREES="$1"
            ROTATE="-rotate $ROTATE_DEGREES"
            IMG_FMT=png
            ;;
        "-wave" )
            shift
            WAVE=$1
            if [ "$WAVE" = default ]; then
                WAVE="-wave -20x556"
            else
                WAVE="-wave $1"
            fi
            ;;
        "-smallthumbs" )
            SMALLTHUMBS=:
            ;;
        "-showcase-framestyle" )
            shift
            SC_FRAMESTYLE="$1"
            ;;
        "-thumb-shape" )
            shift
            THUMB_SHAPE="$1"
            FEATHER=:
            IMG_FMT=png
            ;;
        "-button-style" )
            shift
            BUTTON_STYLE="$1"
            USER_BSTYLE=:
            ;;
        "-3dthumbs" )
            THUMBS_3D=:
            RAISE="-raise 8x8"
            THUMB_FRAME=""
            ;;
        "-blur" )
            shift
            BLUR="$1"
            ;;
        "-title-colour" | "-title-color" )
            shift
            TITLE_COLOUR="$1"
            ;;
        "-submenu-title-colour" | "-submenu-title-color" )
            shift
            SM_TITLE_COLOUR="$1"
            ;;
        "-stroke-colour" | "-stroke-color" )
            shift
            STROKE="$1"
            ;;
        "-submenu-stroke-colour" | "-submenu-stroke-color" )
            shift
            SUBMENU_STROKE="$1"
            ;;
        "-thumb-text-colour" | "-thumb-text-color" )
            shift
            THUMB_TEXT_COLOUR="$1"
            ;;
        "-highlightcolour" | "-highlightcolor" )
            shift
            HIGHLIGHT_COLOUR="$1"
            ;;
        "-selectcolour" | "-selectcolor" )
            shift
            SELECT_COLOUR="$1"
            ;;
        "-text-mist" )
            MIST=:
            ;;
        "-text-mist-opacity" )
            shift
            MIST_OPACITY="$1"
            ;;
        "-text-mist-colour" |"-text-mist-color" )
            shift
            MIST_COLOUR="$1"
            ;;
        "-thumb-mist-colour" |"-thumb-mist-color" )
            shift
            THUMB_BG_COLOUR="$1"
            ;;
        "-opacity" )
            shift
            TRANSPARENT=:
            OPACITY="$1"
            ;;
        "-chapters" )
            unset CHAPTERS
            shift
            get_listargs "$@"
            CHAPTERS="${ARGS_ARRAY[@]}"
            CHAPTERS=( ${CHAPTERS//,/ } )
            ;;
        "-subtitles" )
            shift
            SUBTITLES=:
            get_listargs "$@"
            SUBS="${ARGS_ARRAY[@]}"
            SUBS_ARRAY=( ${SUBS//,/ } )
            ;;
        "-audio-lang" )
            shift
            get_listargs "$@"
            AUDIO_LANG="${ARGS_ARRAY[@]}"
            AUDIO_LANG=( ${AUDIO_LANG//,/ } )
            AUDIOLANG=:
            ;;
        "-bgaudio" )
            shift
            BG_AUDIO="$(abspath "$1")"
            ;;
        "-menu-audio-fade" )
            shift
            FADE="$1"
            AUDIO_FADE=:
            ;;
        "-menu-audiolength" )
            shift
            MENU_AUDIOLENGTH="$1"
            ;;
        "-submenu-audio" )
            shift
            get_listargs "$@"
            for i in ${!ARGS_ARRAY[@]}; do
                if [ ${ARGS_ARRAY[i]} = "none" ]; then
                    SM_AUDIO=( "${SM_AUDIO[@]}" "${ARGS_ARRAY[i]}" )
                else
                    SM_AUDIO=( "${SM_AUDIO[@]}" "$(abspath "${ARGS_ARRAY[i]}")" )
                fi
            done
            SUBMENU_AUDIO=:
            ;;
        "-submenu-audiolength" )
            shift
            SUBMENU_AUDIOLENGTH="$1"
            ;;
        "-submenu-audio-fade" )
            shift
            SM_FADE="$1"
            SM_AUDIO_FADE=:
            ;;
        "-submenus" )
            SUB_MENU=:
            ;;
        "-ani-submenus" )
            ANI_SUB_MENU=:
            SUB_MENU=:
            ;;
        "-menu-title" )
            shift
            VMGM_TITLE="$1"
            ;;
        "-menu-font" )
            shift
            MENU_FONT="$(get_font "$1")"
            ;;
        "-menu-fontsize" )
            shift
            MENU_FONTSIZE="$1"
            ;;
        "-thumb-font" )
            shift
            THUMB_FONT="$(get_font "$1")"
            ;;
        "-thumb-fontsize" )
            shift
            THUMB_FONTSIZE="$1"
            ;;
        "-seek" )
            shift
            unset SEEK_VAL
            get_listargs "$@"
            SEEK_VAL="${ARGS_ARRAY[@]}"
            SEEK_VAL=( ${SEEK_VAL//,/ } )
            ;;
        "-showcase-seek" )
            shift
            SHOWCASE_SEEK_VAL="$1"
            ;;
        "-bgvideo-seek" )
            shift
            BG_SEEK="$1"
            ;;
        "-bgaudio-seek" )
            shift
            BG_AUDIO_SEEK="$1"
            ;;
        "-tovidopts" )
            shift
            TOVID_OPTS="$1"
            ;;
    esac
    $DO_SHIFT && shift
done

##############################################################################
#                      Sanity checks and preliminaries                       #
##############################################################################
# Make sure equal, nonzero number of titles and files were provided
if test ${#FILES[@]} -eq 0 || test ${#TITLES[@]} -eq 0; then
    usage_error "Please provide at least one file and one title."
elif test ${#FILES[@]} -ne ${#TITLES[@]}; then
    usage_error "Please give the same number of files as titles.
    You gave ${#FILES[@]} files and ${#TITLES[@]} titles"
fi
if [[ -n "$SM_TITLES" ]]; then
    if test ${#SM_TITLES[@]} -ne ${#TITLES[@]}; then
    usage_error "Please give the same number of submenu titles as titles.
    You gave ${#SM_TITLES[@]} submenu titles and ${#TITLES[@]} titles"
    fi
fi
# Make sure -out was provided
if test -n "$OUT_PREFIX"; then
    OUT_DIR="$(abspath "$OUT_PREFIX")"
    MENU_FILE="animenu.mpg"
else
    usage_error "Please provide an output name with -out"
fi
# Warn if thumb labels have more than 16 characters
if ! $SHOWCASE; then
    for ((i=0; i<${#TITLES[@]}; i++)); do
        val=${#TITLES[i]}
        [ -z "$MAX_CHARS" ] || ((val > MAX_CHARS)) && MAX_CHARS=$val && key=$i
    done
    if test ${#TITLES[@]} -gt 6 && test $MAX_CHARS -gt 16 ; then
        yecho
        yecho "WARNING! Some titles are longer than 16 characters; they may be chopped off."
        yecho
        #echo "\"${TITLES[key]}\" is too long; please use a shorter title."
        #exit 1
    fi
fi
# disallow spaces in thumb titles for text button style
if [ "$BUTTON_STYLE" = "text" ]; then
    for ((i=0; i<${#TITLES[@]}; i++)); do
        if grep "  " <<< "${TITLES[i]}" >/dev/null; then
            echo "Sorry, a maximum of one consecutive space is allowed in titles for text buttons"
            echo "\"${TITLES[i]}\" has more than one consecutive space in it"
            exit 1
        fi
    done
fi
# allow multiline titles in submenu
if [[ -n "$SM_TITLES" ]]; then
    for i in ${!SM_TITLES[@]}; do
        if [[ $(echo -e "${SM_TITLES[i]}" |wc -l) -gt 1 ]]; then
            SM_TITLES[i]="$(echo -e  "${SM_TITLES[i]}")"
        fi
    done
fi

# set a maximum # of videos
$NO_THUMBS && file_max=26 || file_max=10
if test ${#FILES[@]} -gt 30; then
    usage_error "Sorry, a maximum of 30 videos (thumbs) is supported
    You gave ${#FILES[@]} videos as input"
elif $SHOWCASE && test  ${#FILES[@]} -gt $file_max; then
    usage_error "Sorry, a maximum of 10 titles is allowed for showcase
    You gave ${#FILES[@]} videos as input"
fi

# If output directory already exists, print a message and exit
if test -e "$OUT_DIR"; then
    echo "Cleaning up created dirs"
    yecho
    echo "A file or directory named\"$OUT_DIR\" already exists."
    echo "Please use a different -out name, or (re)move the existing file or directory."
    rm -rf "$REAL_WORK_DIR"
    rm -f "$WORK_DIR"
    exit 1
fi

# Do text-only menu if requested
if $USE_MAKEMENU; then
    call_makemenu
    exit
fi

# double check sox is installed, as the consequence of not having it is ugly
confirm_dep sox "http://sox.sourceforge.net/"

yecho
yecho "Creating work directories"
yecho

# create an array of grouped files. Hopefully LC_ALL=C takes care of sort issues
if $GROUPING; then
    LC_ALL=C grouping=( $WORK_DIR/group* )
fi

# Clean out any existing WORK_DIR
# link WORK_DIR to /tmp for easy solution to spaces, illegal chars bugs
! $GROUPING && mk_workdir

# Remove any existing log file
test -f "$LOG_FILE" && rm -fv "$LOG_FILE"
# check file type of background file and assign to BG_VIDEO or BG_IMAGE
if [[ -n $BACKGROUND ]]; then
    check_filetype "$BACKGROUND"
    if [[ $TYPE = image ]]; then
        BG_PIC="$BACKGROUND"
    elif [[ $TYPE = video ]]; then
        BG_VIDEO="$BACKGROUND"
    else
        usage_error "Sorry, can not identify "$BACKGROUND""
    fi
fi
# if $SHOWCASE, find out if using SHOWCASE_VIDEO or SHOWCASE_IMG or NO_SC_THUMB
if $SHOWCASE; then
    if [[ -n ${SHOWCASE_FILE[@]} ]]; then
        check_filetype "${SHOWCASE_FILE[@]}"
        if [[ $TYPE = image ]]; then
            SHOWCASE_IMG="${SHOWCASE_FILE[@]}"
        elif [[ $TYPE = video ]]; then
            SHOWCASE_VIDEO="${SHOWCASE_FILE[@]}"
        else
            usage_error "Sorry, can not identify "${SHOWCASE_FILE[@]}""
        fi
    else
        NO_SC_THUMB=:
        SHOWCASE_IMG="dummy"
    fi
fi
if [[ $SC_FRAMESTYLE = glass ]] && [[ -z $SHOWCASE_IMG && -z $SHOWCASE_VIDEO ]]; then
    usage_error "You must use a -showcase option for '-showcase-framestyle'
    Either -showcase IMAGE, -showcase VIDEO or just '-showcase'"
fi

# disable submenus for svcd
if $SUB_MENU && [ "$TARGET" = svcd ]; then
    usage_error "Sorry, submenu disabled for svcd for now, please remove -submenu option"
fi
$SUB_MENU && $GROUPING && usage_error "Sorry, no submenus when using -group"
# allow user to only specify one audio file for all submenus
if [ ${#SM_AUDIO[@]} -eq 1 ]; then
    SM_AUDIO_FILE=${SM_AUDIO[0]}
fi
# if more than one audio file for submenu make sure they equal video #
if [[ $SM_AUDIO &&  ${#FILES[@]} -ne ${#SM_AUDIO[@]} &&  ${#SM_AUDIO[@]} -ne 1 ]]; then
    usage_error "Please give the same number of submenu audios as videos.
    You gave ${#FILES[@]} video files and ${#SM_AUDIO[@]} audio files"
fi
# Get absolute pathnames of all files
for i in "${FILES[@]}"; do
    IN_FILES=("${IN_FILES[@]}" "$(abspath "$i")")
    echo "Adding: $i"
done

V_TOTAL=${#IN_FILES[@]}
NUM_FILES=$((V_TOTAL - 1))

# switch title position when appropriate so it doesn't get covered up
[[ $BUTTON_GRAVITY = *south* ]] && TITLE_GRAVITY=north
if [[ $BUTTON_GRAVITY = *east* || $BUTTON_GRAVITY = *west* ]]; then
    ! $USER_GEO &&  XGEO=45 && YGEO=45
    ! $SHOWCASE && TITLE_GRAVITY=north
fi
! $SHOWCASE && [[ $BUTTON_GRAVITY = center ]] && TITLE_GRAVITY=north
# dvdauthor stuff
# make an array of possible vars for dvdauthor post calls
if $CHAIN_VIDEOS; then
    if [ -z "$post_play" ]; then
        for ((i=0; i<NUM_FILES; i++)); do
                POST_PLAY[i]=chain
            done
    else
        for j in $post_play; do
            if [[ $j = *-* ]]; then
                for ((i=${j/-*}; i<=${j/*-}; i++)); do
                    POST_PLAY[i-1]=chain
                done
            elif [[ $j != *[^0-9]* ]]; then
                POST_PLAY[j-1]=chain
            fi
        done
    fi
    echo
    for ((n=0; n<=NUM_FILES; n++)); do
        if [ "${POST_PLAY[n]}" = "chain" ]; then
            if [ $n -lt $NUM_FILES ]; then
                echo "video $((n+1)) will be chained with video $((n+2))"
            else
                echo "video $((n+1)) will be chained with video 1"
            fi
        fi
    done
    echo
fi
# allow user to specify one # of chapters for all videos
if [ ${#CHAPTERS[@]} -eq 1 ]; then
    for ((i=0; i<=NUM_FILES; i++)); do
        CHAPTERS[i]=${CHAPTERS[0]}
    done
fi

# if more than one value for CHAPTERS, make sure they equal video #
if [[ $SUB_MENU &&  ${#FILES[@]} -ne ${#CHAPTERS[@]} &&  ${#CHAPTERS[@]} -ne 1 ]]; then
    usage_error "Please give the same number of submenu audios as videos.
    You gave ${#FILES[@]} video files and ${#CHAPTERS[@]} chapter values"
fi
# find out longest chapter value (number of chapters)
if $SUB_MENU; then
    for ((i=0; i<${#CHAPTERS[@]}; i++)); do
        chapt_val=${CHAPTERS[i]}
        [ -z "$MAX_CHAPTERS" ] || ((chapt_val > MAX_CHAPTERS)) && MAX_CHAPTERS=$chapt_val && max_chapt_key=$i
        [ -z "$MIN_CHAPTERS" ]  || ((chapt_val < MIN_VAL)) && MIN_CHAPTERS=$chapt_val && min_chapt_key=$i
    done
fi
# do not let user use -chapters 0 (-chapters 5 0 6)
if $SUB_MENU; then
    for ((i=0; i<${#CHAPTERS[@]}; i++)); do
        if ((${CHAPTERS[i]} == 0)) && [[ -z ${GROUP[i]} ]]; then
            usage_error "Please use -chapters 1 not -chapters 0, if you do not want chapters.
            -chapters 0 is a special case for -group videos, meaning the each video is a chapter."
        fi
    done
fi
# if -bgvideo selected, but also -static, exit with error message
#if test -n "$BG_VIDEO" &&  $STATIC; then
#    usage_error "You can not use -bgvideo with a static menu"
#elif test -n "$SHOWCASE_VIDEO" && $STATIC; then
#    usage_error "You can not use -showcase-video with a static menu"
#elif [ "$SC_FRAMESTYLE" = "glass" ] && $STATIC; then
#    usage_error "You can not use -showcase-framestyle glass with a static menu"
#elif test -n "$SHOWCASE_VIDEO" && test -n "$SHOWCASE_IMG"; then
#    usage_error "You can not use -showcase-video AND -showcase-image"
#fi
# create_dirs
echo
yecho "Creating pics directories..."
for ((i=0; i<=NUM_FILES; i++)); do
    mkdir -pv "$REAL_WORK_DIR/pics/$i"
done
# textmenu is static unless there is an animated background or showcase video
if $TEXTMENU && [[ -z $SHOWCASE_VIDEO && -z $BG_VIDEO ]]; then STATIC=:; fi #FIXME
# prevent user from using mutually exclusive options
if $STATIC; then
    MENU_FADE=false
fi
if [ $FADE = 0 ]; then # in case user thinks he needs to specify 0 for fade
    AUDIO_FADE=false
elif [ $SM_AUDIO_FADE = 0 ]; then
    SM_AUDIO_FADE=false
fi
if $MENU_FADE || test -n "$BG_VIDEO"; then mkdir -v "$REAL_WORK_DIR/bg"; fi
mkdir -v "$REAL_WORK_DIR/animenu"
if $ANI_SUB_MENU; then
    for ((i=0; i<MAX_CHAPTERS; i++)); do
        mkdir -v "$REAL_WORK_DIR/animenu/$i"
    done
fi
if $SUB_MENU && ! $ANI_SUB_MENU; then
    mkdir -v "$REAL_WORK_DIR/submenu"
fi
if [[ -n "$SHOWCASE_VIDEO" ]]; then
    mkdir -v "$REAL_WORK_DIR/showcase"
fi
# if Fading menu, and no BG IMAGE OR VIDEO, fade thumbs right in after title
if $MENU_FADE && [[ -z "$BG_PIC" && -z "$BG_VIDEO" ]]; then
    THUMBS_FADE_IN_START_TIME=2.5
fi
# if more than one value for AUDIO_LANG, make sure they equal video #
if $AUDIOLANG &&  [[ ${#FILES[@]} -ne ${#AUDIO_LANG[@]} &&  ${#AUDIO_LANG[@]} -ne 1 ]]; then
    usage_error "Please give the same number of audio channels as videos.
    You gave ${#FILES[@]} video files and ${#AUDIO_LANG[@]} audio channel values"
fi
# if only one seek value, then use for all videos
if [ ${#SEEK_VAL[@]} -eq 1 ]; then
    for ((i=0; i<=NUM_FILES; i++)); do
        SEEK_VAL[i]=${SEEK_VAL[0]}
        SEEK[i]="-ss ${SEEK_VAL[i]}" # create seek value for each video
    done
fi
# make sure if more than one seek value, they equal the number of video
if [[ ${#FILES[@]} -ne ${#SEEK_VAL[@]} &&  ${#SEEK_VAL[@]} -ne 1 ]]; then
    usage_error "Please give the same number of seek times as videos, or just use one value.
    You gave ${#FILES[@]} video files and ${#SEEK_VAL[@]} seek times"
fi
#create seek value for each video
for ((i=0; i<=NUM_FILES; i++)); do
    # translate SEEK_VAL into frames for transcode
    SEEK_FRAMES[i]=$(awk_math ${SEEK_VAL[i]} times $FRAME_RATE)
done
# var for dcdemux and the navigation log
#TCDEMUX_MODE="-M 0"
echo
echo "Verifying that input files are video files"
for ((i=0; i<=NUM_FILES; i++)); do
    IN_FILE="${IN_FILES[i]}"
    if test -e "$IN_FILE"; then
        if mencoder -quiet -oac pcm -ovc copy -frames 0 -o /dev/null "$IN_FILE" &>/dev/null; then
            echo "$IN_FILE ok"
        else
            usage_error "Sorry, $IN_FILE is not a video file"
        fi
    else
        usage_error "Sorry, $IN_FILE does not exist"
    fi
done
echo
##############################################################################
# Font defaults
##############################################################################

# Menu title font size
test $TARGET = "dvd" && : ${MENU_FONTSIZE:="30"}
test $TARGET = "svcd" && : ${MENU_FONTSIZE:="26"}
# Thumbnail title font size
if test -z "$THUMB_FONTSIZE"; then
# if not -thumb-fontsize N passed, use default, based on the following:
    if $SHOWCASE; then
        if test "$NUM_FILES" -lt 2; then
            THUMB_FONTSIZE=20
        elif  test "$NUM_FILES" -eq 2; then
            THUMB_FONTSIZE=18
        elif  test "$NUM_FILES" -ge 3; then
            THUMB_FONTSIZE=16
        fi
    else
        THUMB_FONTSIZE=10
    fi
fi

# See if "Helvetica" or "helvetica" are available as default fonts
if convert -size 50x20 xc:none -font Helvetica -gravity Center \
-draw "text 0,0 'test'" "$WORK_DIR/font.png"; then
    DEFAULT_FONT="Helvetica"
elif convert -size 200x100 xc:none -font helvetica -gravity Center \
-draw "text 0,0 'test'" "$WORK_DIR/font.png"; then
    DEFAULT_FONT="helvetica"
fi
# If user did not specify fonts, use default
test -z "$MENU_FONT" && MENU_FONT=$DEFAULT_FONT
test -z "$THUMB_FONT" && THUMB_FONT=$DEFAULT_FONT
rm -f "$WORK_DIR/font.png"


# Some user feedback
yecho
yecho "Disc title: \"$VMGM_TITLE\""
yecho "  (adjust with -menu-title)"
yecho "Including the following videos:"
# do not echo all of long or multiline titles AND files
for ((i=0; i<${#TITLES[@]}; i++)); do
    if [[ ${#TITLES[i]} -gt 35 || $(echo -e "${TITLES[i]}" |wc -l) -gt 1 ]]; then
        TITLE[i]=$(sed 's/^  *//'<<<${TITLES[i]//\\n/ }) # remove spaces and \n
        TITLE[i]=${TITLE[i]:0:35} # cut down to 35 characters maximum
        # if there is a multiline title we need to align to right of thumbs
        SC_TITLE_ALIGN=east
        ALIGN_OVERRIDE=:
        if [ ${#TITLES[i]} -gt 35 ]; then
            echo "  \"${TITLE[i]}...\" (${IN_FILES[i]})" # "..." if truncated
        else
            echo "  \"${TITLE[i]}\" (${IN_FILES[i]})"
        fi
    else # echo titles "as is"
        echo "  \"${TITLES[i]}\" (${IN_FILES[i]})"
    fi
done
yecho "Current font settings: "
yecho "  -menu-font $MENU_FONT"
yecho "  -menu-fontsize $MENU_FONTSIZE"
yecho "  -thumb-font $THUMB_FONT"
yecho "  -thumb-fontsize $THUMB_FONTSIZE"
yecho "Current menu settings: "
if  ! $STATIC; then
    yecho "  -menu-length $ANI_MENU_LENGTH seconds"
fi
if $ANI_SUB_MENU; then
    yecho "  -submenu-length $ANI_SUBMENU_LENGTH seconds"
    if $SUBMENU_AUDIO; then
        yecho "  -submenu-audio-fade $SM_FADE second(s)"
    fi
fi
for ((i=0; i<=NUM_FILES; i++)); do
    echo -n "Video $((i+1)):"
    echo -n "  -seek ${SEEK_VAL[i]} second(s)"
    echo "  -chapters ${CHAPTERS[i]}"
done
if [ ! $STATIC ]; then
    yecho "  -menu-audio-fade $FADE second(s)"
fi
yecho


# TODO: Merge these globals with the ones up top
DVD_GEO_ARRAY=(320x240 272x204 192x144 192x144 184x138 184x138 136x102 136x102 \
120x90 120x90 120x90 120x90 96x72 96x72 96x72 96x72 96x72 96x72 96x72 96x72 \
80x60 80x60 80x60 80x60 80x60 80x60 80x60 80x60 80x60 80x60 60x40 40x30)
SVCD_GEO_ARRAY=(240x240 180x180 120x120 120x120 120x120 120x120 96x96 96x96 \
96x96 80x80 80x80 80x80 64x64 64x64 64x64 64x64 64x64 64x64 64x64 64x64 \
48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48)
TILE_ARRAY=(1x1 2x1 2x2 2x2 3x2 3x2 4x2 4x2 3x3 4x3 4x3 4x3 4x4 4x4 4x4 \
4x4 5x4 5x4 5x4 5x4 5x5 5x5 5x5 5x5 5x5 6x5 6x5 6x5 6x5 6x5 6x6 6x6)
SHOWCASE_THUMB_Y_ARRAY=("166" "110 240" "75 175 275" "68 148 228 308" \
"68 131 194 257 320" "75 175 275 75 175 275" "68 148 228 308 68 148 228" \
"68 148 228 308 68 148 228 308" "68 131 194 257 320 68 131 194 257" \
"68 131 194 257 320 68 131 194 257 320")
SHOWCASE_TITLES_Y_ARRAY=("144" "88 218" "54 154 254" \
"50 130 210 290" "49 112 175 238 301" "54 154 254 54 154 254" \
"50 130 210 290 50 130 210" "50 130 210 290 50 130 210 290" \
"49 112 175 238 301 49 112 175 238" \
"49 112 175 238 301 49 112 175 238 301")
SHOWCASE_THUMB_X_ARRAY=("86" "86 86" "86 86 86" "86 86 86 86" \
"86 86 86 86 86" "86 86 86 538 538 538" "86 86 86 86 554 554 554" \
"86 86 86 86 554 554 554 554" "86 86 86 86 86 574 574 574 574" \
"86 86 86 86 86 574 574 574 574 574")
SHOWCASE_THUMB_X_ARRAY=( ${SHOWCASE_THUMB_X_ARRAY[NUM_FILES]} )
SHOWCASE_THUMB_Y_ARRAY=( ${SHOWCASE_THUMB_Y_ARRAY[NUM_FILES]} )
SHOWCASE_TITLES_X_ARRAY=( ${SHOWCASE_THUMB_X_ARRAY[@]} )
SHOWCASE_TITLES_Y_ARRAY=( ${SHOWCASE_TITLES_Y_ARRAY[NUM_FILES]} )
! $USER_SPLIT && SPLIT=13 # max number of text only titles in one column (-textmenu)
if $NO_THUMBS ; then
    if [[ $NUM_FILES -gt 12 ]] && ! $USER_SPLIT; then
        SPLIT=$((V_TOTAL / 2))
        [[ $(( SPLIT * 2)) -ne $V_TOTAL ]] && let SPLIT=SPLIT+1
    fi
    for ((b=0; b<=NUM_FILES; b++)); do
        ((b < SPLIT)) && SHOWCASE_TITLES_X_ARRAY[b]=86 || SHOWCASE_TITLES_X_ARRAY[b]=360
    done
fi
if  [ $TARGET = "dvd" ]; then
    AUDIO_EXT="ac3"
    SAMPLERATE="48000"
    MPLEX_FORMAT="8"
    GEO_ARRAY=("${DVD_GEO_ARRAY[@]}")
    FFMPEG_OPTS="-b 7000k  -maxrate 8000k -bufsize 230KiB  -aspect $ASPECT_RATIO"
    SHOWCASE_SIZE=384x256
    if [ $TV_STANDARD = ntsc ]; then
        VIDSIZE="720x480"
        FRAME_RATE=29.970
    elif [ $TV_STANDARD = pal ]; then
        VIDSIZE="720x576"
        FRAME_RATE=25
    fi
elif [ $TARGET = "svcd" ]; then
    AUDIO_EXT="mp2"
    SAMPLERATE="44100"
    MPLEX_FORMAT="4"
    GEO_ARRAY=("${SVCD_GEO_ARRAY[@]}")
    FFMPEG_OPTS="-b 2200k -minrate 2200k -maxrate 2200k -bufsize 112KiB -aspect $ASPECT_RATIO"
    SHOWCASE_SIZE=256x256
    if [ $TV_STANDARD = ntsc ]; then
        VIDSIZE="480x480"
        FRAME_RATE=29.970
    elif [ $TV_STANDARD = pal ]; then
        VIDSIZE="480x576"
        FRAME_RATE=25
    fi
fi
THUMB_SIZE="${GEO_ARRAY[NUM_FILES]}"
if $SHOWCASE; then
    if [ -z ${BLUR/.*} ]; then
        BLUR=0.${BLUR/*.}
    fi
    if [ ${BLUR/.*} -ge 2 ]; then
        BLUR=2.0
    fi
    if [ $V_TOTAL -lt 3 ]; then
        THUMB_SIZE="${GEO_ARRAY[10]}"
    elif [ $V_TOTAL -eq 3 ]; then
        THUMB_SIZE="${GEO_ARRAY[13]}"
    elif [ $V_TOTAL -eq 4 ]; then
        if $SMALL_FONTSIZE; then
            THUMB_SIZE="${GEO_ARRAY[30]}"
        else
            THUMB_SIZE="${GEO_ARRAY[23]}"
        fi
    elif [ $V_TOTAL -eq 5 ]; then
        THUMB_SIZE="${GEO_ARRAY[30]}"
    elif [ $V_TOTAL -eq 6 ]; then
        THUMB_SIZE="${GEO_ARRAY[13]}"
    elif [[ $V_TOTAL -ge 7 && $V_TOTAL -le 8 ]]; then
        THUMB_SIZE="${GEO_ARRAY[23]}"
    elif [[ $V_TOTAL -ge 9 && $V_TOTAL -le 10 ]]; then
        THUMB_SIZE="${GEO_ARRAY[30]}"
    fi
fi
# some choices needed for different title alignments
if $SHOWCASE; then
    if [ $V_TOTAL -le 5 ]; then
        if [[ $SC_TITLE_ALIGN = *st ]]; then
            SHOWCASE_SIZE=288x216  # smaller to allow for titles
        else
            SHOWCASE_SIZE=384x256
        fi
        AUTOORDER="rows"       # spumux var
    else
        SHOWCASE_SIZE=288x216  # smaller showcase thumb because we have 2 rows
        AUTOORDER="columns"
        if ! $NO_SC_THUMB && ! $TEXTMENU && [[ "$SC_TITLE_ALIGN" = *st ]] && [[ -n $SHOWCASE_FILE ]]; then
            usage_error "Sorry, there is no room for the showcase thumb " \
            "if you use more than 5 videos with -showcase-titles-align east|west. " \
            "Either remove the -showcase-titles-align switch or remove the " \
            "showcase image/video by using -showcase-no-thumb. " " " \
            "Consider using -bgimage or -bgvideo instead of a showcase thumb."
        fi
    fi
else
    AUTOORDER="rows"
fi
$NO_THUMBS && LEFT_MAX=$SPLIT || LEFT_MAX=5
if [ "$SC_TITLE_ALIGN" = "west" ]; then
    THUMB_TITLE_ALIGN="west"
    for ((i=0; i<=NUM_FILES; i++)); do
        if [ $i -lt $LEFT_MAX ]; then
            SHOWCASE_THUMB_X_ARRAY[i]=$(( ${SHOWCASE_THUMB_X_ARRAY[i]} - SAFE_OFFSET ))
            SHOWCASE_TITLES_X_ARRAY[i]=$(( ${SHOWCASE_TITLES_X_ARRAY[i]} - SAFE_OFFSET ))
        fi
        if ! $NO_THUMBS && ! [[ $SHOWCASE_FILE ]]; then #FIXME
            if [ ${SHOWCASE_THUMB_X_ARRAY[i]} -gt 360 ]; then
                SHOWCASE_THUMB_X_ARRAY[i]=360
                SHOWCASE_TITLES_X_ARRAY[i]=360
            fi
        fi
    done
fi
# text-rect only for -align east
if [[ $BUTTON_STYLE = text-rect ]] && ! [[ $SC_TITLE_ALIGN = east ]] && ! $TEXTMENU; then
    yecho "***Warning*** : text-rect buttons need to be aligned east of thumbs: \
    by using: '-showcase-titles-align east'"
    if [[ -n $SHOWCASE_FILE ]]; then
        echo "However, you are using a -showcase FILE, so choosing 'text' buttons instead"
        echo "If you wish you may use instead: '-button-style rect' - in which case exit now . . ."
        BUTTON_STYLE=text
    else
        SC_TITLE_ALIGN=east
    fi
    yecho
    sleep 10
fi
if $SHOWCASE && [ "$SC_TITLE_ALIGN" = "east" ] && ! $TEXTMENU; then
    THUMB_TITLE_ALIGN="west" # align titles left to allow longer titles
    for ((i=0; i<=NUM_FILES; i++)); do
        if [ $i -lt $LEFT_MAX ] && ! $ALIGN_OVERRIDE; then
            SHOWCASE_THUMB_X_ARRAY[i]=$(( ${SHOWCASE_THUMB_X_ARRAY[i]} - SAFE_OFFSET ))
            SHOWCASE_TITLES_X_ARRAY[i]=$(( ${SHOWCASE_TITLES_X_ARRAY[i]} - SAFE_OFFSET ))
        fi
        if [ ${SHOWCASE_THUMB_X_ARRAY[i]} -gt 360 ]; then
            SHOWCASE_THUMB_X_ARRAY[i]=360
        fi
        if ! $NO_THUMBS; then
            SHOWCASE_TITLES_X_ARRAY[i]=$(( ${SHOWCASE_THUMB_X_ARRAY[i]} + ${THUMB_SIZE/x*} + 5 ))
            SHOWCASE_TITLES_Y_ARRAY[i]=$(( ${SHOWCASE_TITLES_Y_ARRAY[i]} + 18 ))
        fi
    done
fi
if $USER_GRAVITY && $SHOWCASE; then
    if [[ $BUTTON_GRAVITY = *south* ]]; then
        Y_OFFSET=$(( ( ${VIDSIZE/*x} - 50) - ( ${SHOWCASE_THUMB_Y_ARRAY[NUM_FILES]} + ${THUMB_SIZE/*x}) ))
        for ((i=0; i<=NUM_FILES; i++)); do
            SHOWCASE_THUMB_Y_ARRAY[i]=$(( ${SHOWCASE_THUMB_Y_ARRAY[i]} + Y_OFFSET ))
            SHOWCASE_TITLES_Y_ARRAY[i]=$(( ${SHOWCASE_TITLES_Y_ARRAY[i]} + Y_OFFSET ))
        done
    fi
fi

# find out the showcase thumb "-page" array for this arrangement
for ((i=0; i<=NUM_FILES; i++)); do
    SHOWCASE_THUMB_PAGES_ARRAY[i]=+${SHOWCASE_THUMB_X_ARRAY[i]}+${SHOWCASE_THUMB_Y_ARRAY[i]}
done

PATTERN=$(for ((i=1; i<=79; i++)); do echo -n \*; done)
printf "%s\n%s\n%s\n\n\n" "$PATTERN" \
"todisc from the tovid suite - log for `date`" \
"$PATTERN" >> "$LOG_FILE"

# Do everything in $WORK_DIR
echo -e "**** NOTE ****\n"
echo "Doing all work in directory $REAL_WORK_DIR"
echo "$WORK_DIR will be a symlink pointing to this directory"
echo -e "\n**************"
sleep 1
cd "$WORK_DIR"

# default of no blur if using 3D thumbs
if $THUMBS_3D; then
    BLUR=0.1
fi

# allow specifically setting the geometry for 3 videos to 1x3 page
if $THREExONE && [ $V_TOTAL -eq 3 ]; then
    TILE_ARRAY[2]=3x1
fi
# do not use frame for showcase-framestyle glass
if [[ "$SC_FRAMESTYLE" = "glass" && -n "$SHOWCASE_VIDEO" ]] ; then
    unset SC_FRAME
fi
if $SHOWCASE; then
    THUMB_BG_COLOUR="none"   # mist backgrounds look a bit funny with showcase
fi
if ! $USER_BSTYLE && $SHOWCASE; then # text is better than rect for "none" bg
    BUTTON_STYLE="text"
fi
# check if user passed a usable button shape
if [[ -n $THUMB_SHAPE ]]; then
    ! egrep -q  '^round$|^oval$|^plectrum$|^normal$' <<< "$THUMB_SHAPE"  && \
        usage_error "Please supply a usable thumb shape with -thumb-shape option. You gave \"$THUMB_SHAPE\""
fi
            
# use a suitable button style
for ((i=0; i<=NUM_FILES; i++)); do
    if test $(wc -l <<< "$(echo -e "${TITLES[i]}")") -gt 1; then
        MULTILINE_TITLE=:
        if $FEATHER && [ $THUMB_SHAPE != "normal" ]; then
            # multiline titles not suitable for text buttons
            BUTTON_STYLE="text-rect"
        elif $NO_THUMBS; then
            BUTTON_STYLE="text-rect"
        else
            [[ $BUTTON_STYLE != "text-rect" ]] && BUTTON_STYLE="rect"
        fi
    fi
done
# transparent border around text so rect spumux outline can fit
#if  $MULTILINE_TITLE && ([[ $SC_TITLE_ALIGN = "east" ]] || $NO_THUMBS); then
if [[ $BUTTON_STYLE = text-rect ]]; then
    TEXT_BORDER="-bordercolor Transparent -border 8x8"
fi
# place menu title lower if not text mist
mist_pos=45
$MIST && title_pos=65 || title_pos=50
# easier to have non transparent showcase use the transparent block
if $SHOWCASE && ! $TRANSPARENT; then TRANSPARENT=:; fi
AUDIO_OPTS="-ab 224 -ar $SAMPLERATE -ac 2 -acodec $AUDIO_EXT"
# spumux and dvdauthor vars
if $WIDE_SCREEN; then
    if [[ "$WS_ARG" = all || "$WS_ARG" = video ]]; then
        TITLES_VIDEO_TAG="<video widescreen=\"$WIDESCREEN\" $V_ASPECT/>"
        TITLES_VIDEO_TAG="$(sed 's/ \/>/\/>/' <<< ${TITLES_VIDEO_TAG})"
    fi
    if [[ "$WS_ARG" = all || "$WS_ARG" = menu ]]; then
        MENU_VIDEO_TAG="<video widescreen=\"$WIDESCREEN\" $M_ASPECT/>"
        MENU_VIDEO_TAG="$(sed 's/ \/>/\/>/' <<< ${MENU_VIDEO_TAG})"
    fi
    if [ ${#WIDESCREEN_ARGS[@]} -lt 1 ]; then
        MENU_VIDEO_TAG="<video widescreen=\"$WIDESCREEN\" $M_ASPECT/>"
        MENU_VIDEO_TAG="$(sed 's/ \/>/\/>/' <<< ${MENU_VIDEO_TAG})"
        TITLES_VIDEO_TAG="<video widescreen=\"$WIDESCREEN\" $V_ASPECT/>"
        TITLES_VIDEO_TAG="$(sed 's/ \/>/\/>/' <<< ${TITLES_VIDEO_TAG})"
    fi
fi
if [[ -n "$V_ASPECT" || -n "$M_ASPECT" ]] &&  ! $WIDE_SCREEN; then
    TITLES_VIDEO_TAG="<video $V_ASPECT/>"
    MENU_VIDEO_TAG="<video $M_ASPECT/>"
fi
if [[ -n "$M_ASPECT" ]] && [[ "$WS_ARG" = video ]]; then
        MENU_VIDEO_TAG="<video $M_ASPECT/>"
        MENU_VIDEO_TAG="$(sed 's/ \/>/\/>/' <<< ${MENU_VIDEO_TAG})"
elif [[ -n "$V_ASPECT" ]] && [[ "$WS_ARG" = menu ]]; then
        TITLES_VIDEO_TAG="<video $V_ASPECT/>"
        TITLES_VIDEO_TAG="$(sed 's/ \/>/\/>/' <<< ${TITLES_VIDEO_TAG})"
fi
START="00:00:00.0"
if $PLAYALL; then
    PLAYALL_PRE="g4=0;"
fi

if $AUDIOLANG; then
    # if only one -audio-lang value, then use for all videos
        for ((i=0; i<=NUM_FILES; i++)); do
            if [ ${#AUDIO_LANG[@]} -eq 1 ]; then
                AUDIO_PRE[i]="audio=${AUDIO_LANG[0]};"
            else
                AUDIO_PRE[i]="audio=${AUDIO_LANG[i]};"
            fi
        done
    for ((i=0; i<=NUM_FILES; i++)); do # create audio tag for dvdauthor
        VOB_PRE[i]="        <pre> ${AUDIO_PRE[i]} </pre>"
    done
fi
$PLAYALL && MAIN_PRE="        <pre> $PLAYALL_PRE  </pre>"
MAIN_POST="        <post> jump cell 1; </post>"
if $MENU_FADE; then
    . todisc-fade-routine
    END_TIME=$(format_seconds $THUMBS_FADE_OUT_END_TIME)
    END=" end=\"$END_TIME\""
    START=$(format_seconds $THUMBS_FADE_IN_START_TIME)
    POST="<post> jump cell 1; </post>"
fi
if $STATIC; then
    if ! $STATIC_LOOP; then
        VMGM_PAUSE_TIME="inf"
    else
        VMGM_PAUSE_TIME=$PAUSE_TIME
    fi
else
    VMGM_PAUSE_TIME=$PAUSE_TIME
fi
# pausing a faded menu gives a long a period of unselectable thumbs so we use 0
$MENU_FADE && VMGM_PAUSE_TIME=0
if [ "$PAUSE_TIME" = "inf" ]; then
    unset MAIN_POST
fi
###############################################################################
#     generate title_txt png, and template.png needed for all operations       #
###############################################################################

if [ -z "$BG_PIC" ]; then
    echo
    echo "Creating a black background"
    BG_PIC="$WORK_DIR/pics/template.png"
    convert  -resize $VIDSIZE! xc:"#161514" "$BG_PIC"
else
    convert -resize $VIDSIZE! "$BG_PIC" "$WORK_DIR/pics/template.png"
fi
if $MENU_FADE; then
    cp "$WORK_DIR/pics/template.png" "$WORK_DIR/pics/template.bk.png"
fi

if $MENU_FADE || $FEATHER; then
    convert -size $VIDSIZE xc:"#161514" "$WORK_DIR/black.jpg"
fi
DIMY=$(cut -f1 -dx <<< $THUMB_SIZE)
DIMX=$(cut -f2 -dx <<< $THUMB_SIZE)
DIMY1=$((DIMY / 20))
DIMX1=$((DIMX / 20))
DIMY2=$((DIMY - DIMY1))
DIMX2=$((DIMX - DIMY1))
DIMY3=$(($DIMY2 / 2))
DIMX3=$(($DIMX2 / 2))
DIMY4=$((DIMY / 2))
DIMX4=$((DIMX / 2))
DIMY5=$((DIMY / 3))
DIMX5=$((DIMX4 / 3))
BLUR_CMD=(convert - -blur 0x$BLUR -channel RGBA +matte miff:-)
if $THUMBS_3D && $SHOWCASE && [ "$THUMB_SHAPE" = "normal" ]; then
    MASK_DIM="0,0 $DIMY,$DIMX"
    BLUR_CMD=(convert - miff:-)
else
    MASK_DIM="$DIMY1,$DIMY1 $DIMY2,$DIMX2"
fi

if [[ -n "$THUMB_SHAPE" ]]; then
    # make a mask for the mist if called for
    convert -size $THUMB_SIZE xc:none -fill  "$THUMB_BG_COLOUR" -stroke none \
    -draw "rectangle $DIMY1,$DIMY1 $DIMY2,$DIMX2" "$WORK_DIR/feather_orig.png"
    convert "$WORK_DIR/feather_orig.png" -channel RGBA \
    -blur 0x60 "$WORK_DIR/feather_mask2.png"
fi
if [ -z "$THUMB_TEXT_COLOUR" ]; then
    if $FEATHER && ! $SHOWCASE &&  [ $THUMB_BG_COLOUR != none ]; then
        THUMB_TEXT_COLOUR="#161514" # dark font for misted backgrounds
    else
        THUMB_TEXT_COLOUR="#C6C6C6"
    fi
fi
if test "$THUMB_SHAPE" = "normal"; then
    THUMB_MASK="$WORK_DIR/feather_mask.png"
    yecho "Creating normal mask with the following command:"
    MASK_CMD="convert -size $THUMB_SIZE xc:black -fill white \
    -draw \"Rectangle $MASK_DIM\" \
    +matte -compose CopyOpacity miff:- | \
    convert - -bordercolor none -border 8x8 miff:- |
    ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | \
    convert -resize $THUMB_SIZE! - $THUMB_MASK"
    # TODO (if desired): move this 'sed' line to a separate function for
    # cleaning up excess spaces in a multi-line command.
    #    sed 's/    */ /g'|sed -e "s/^ *//"

elif test "$THUMB_SHAPE" = "oval"; then
    THUMB_MASK="$WORK_DIR/oval_mask.png"
    yecho "Creating oval mask with the following command:"
    MASK_CMD="convert -size $THUMB_SIZE xc:black -fill white \
    -draw \"RoundRectangle $DIMY1,$DIMY1 $DIMY2,$DIMX2, $DIMY3,$DIMX3\" \
    +matte -compose CopyOpacity miff:- | \
    convert - -bordercolor none -border 6x6 miff:- |
    ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | \
    convert -resize $THUMB_SIZE! - $THUMB_MASK"
    MASK_HILITE_CMD="convert -size $THUMB_SIZE xc:none \
    -draw \"RoundRectangle $DIMY1,$DIMY1 $DIMY2,$DIMX2, $DIMY3,$DIMX3\" \
    -negate  -channel A -gaussian 0x8 $WORK_DIR/oval_highlight.png"

elif test "$THUMB_SHAPE" = "egg"; then
    THUMB_MASK="$WORK_DIR/egg_mask.png"
    yecho "Creating egg-shaped mask with the following command:"
    MASK_CMD="convert -size $THUMB_SIZE xc:black -fill white \
    -draw \"circle $DIMY4,$DIMX4 $DIMY5,$DIMX5\" \
    +matte -compose CopyOpacity miff:- | \
    ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | \
    convert -resize $THUMB_SIZE! - $THUMB_MASK"

elif test "$THUMB_SHAPE" = "plectrum"; then
    THUMB_MASK="$WORK_DIR/plectrum_mask.png"
    yecho "Creating plectrum-shaped mask with the following command:"
    MASK_CMD="convert -size 200x200 xc:none -fill white \
    -draw 'circle 100,100 150,150' miff:- |
    convert -background none -wave -50x456 - miff:- |
    convert - -bordercolor none -border 3x3 -trim +repage miff:- |
    convert - -bordercolor none -border 18x18 miff:- |
    ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} | ${BLUR_CMD[@]} |
    convert -resize $THUMB_SIZE! - $THUMB_MASK"
fi

# Print and execute the thumb-shape mask command
yecho "$MASK_CMD"
cmd_exec "$MASK_CMD"
yecho "Creating a title image"
if [[ -z "$BG_PIC" && -z "$BG_VIDEO" ]]; then
    STROKE=none
elif [ -z "$STROKE" ]; then
    STROKE=gray
fi

# make a title image
#! [[ -z ${STR// /} || -z $STR ]] && TRIM_CMD="-trim +repage -blur 0x0.4 "
TRIM_CMD="-trim +repage -blur 0x0.4"
TITLE_CMD=(convert  -size 620x100 xc:none -font "$MENU_FONT"  -pointsize $MENU_FONTSIZE \
-fill black -stroke black -gravity center  -annotate +0+0 "$VMGM_TITLE"
-fill "$TITLE_COLOUR" -stroke "$STROKE" -strokewidth 1 -annotate +1+1 "$VMGM_TITLE")
TITLE_CMD1=(convert - $TRIM_CMD  "$WORK_DIR/title_txt.png")

echo "Running "${TITLE_CMD[@]}" miff:- |
"${TITLE_CMD1[@]}"" | format_output|tee -a "$LOG_FILE"
"${TITLE_CMD[@]}" miff:- | "${TITLE_CMD1[@]}" 2>/dev/null

# make thumb titles if $SHOWCASE
if $SHOWCASE; then
    for ((i=0; i<=NUM_FILES; i++)); do
        unset ts_dim j
        THUMB_TITLE_CMD=(convert  -size 620x300 xc:none \
        -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE \
        -fill black -stroke black -gravity $THUMB_TITLE_ALIGN  \
        -annotate +0+0 "${TITLES[i]}" \
        -fill $THUMB_TEXT_COLOUR  -stroke "$STROKE" -strokewidth 1 \
        -annotate +1+1 "${TITLES[i]}")
        TT_CMD1=(convert - -trim +repage $TEXT_BORDER "$WORK_DIR/thumb_title${i}.png")
        echo "Running "${THUMB_TITLE_CMD[@]}" miff:- | "${TT_CMD1[@]}"" \
        |fold -bs >> "$LOG_FILE"
        "${THUMB_TITLE_CMD[@]}" miff:- | "${TT_CMD1[@]}" 2> /dev/null

        # find out dimension of the thumb title png
        TT_DIM=( ${TT_DIM[@]} $(identify "$WORK_DIR/thumb_title${i}.png"|awk '{print $3}') )
        # get widest png for use later for alignment use
        val=${TT_DIM[i]/x*}
        [ -z "$MAX_LEN" ] || ((val > MAX_LEN)) && MAX_LEN=$val
        # get just X demension to help determine final title pos below
        tt_dim=${TT_DIM[i]/x*}
        # thumb pos plus 1/2 (X dim) of thumbsize, less 1/2 (X dim) of title size
        if [ "$SC_TITLE_ALIGN" = "centre" ]; then
            f=$(( ${THUMB_SIZE/x*} / 2 ))
            j=$(( (f + ${SHOWCASE_THUMB_X_ARRAY[i]}) - (tt_dim / 2) ))
            k=( ${k[@]} "$j" )
            l=$((j + tt_dim))
            if [ $j -lt 48 ]; then
                off_left=$j
                titlesafe_error $off_left
            elif [ $l -gt 672 ]; then
                off_right=$((720 - l))
                titlesafe_error $off_right
            fi
        fi
    done
    if $NO_THUMBS; then
#        for ((i=0; i<${#TT_DIM[@]}; i++)); do
#            val=${TT_DIM[i]#*x}
#            [ -z "$MAX_VAL" ] || ((val > MAX_VAL)) && MAX_VAL=$val && max_key=$i
#        done
#    offsets=$(for ((i=0; i<${#SHOWCASE_TITLES_Y_ARRAY[@]}; i++)); do echo $(($MAX_VAL + 15)); done)
        # text-rect can get along with a small space between titles for spumux
        [[ $BUTTON_STYLE = text-rect ]] && spacer=10 || spacer=15
        # get an array of title Y positions
        offsets1=$(for ((c=0; c<NUM_FILES; c++)); do
        ((c < (LEFT_MAX-1))) && echo $(( ${TT_DIM[c]#*x} + spacer )); done)
        if [[ $NUM_FILES -ge $SPLIT ]]; then
            offsets2=$(for ((d=0; d<=NUM_FILES; d++)); do
            ((d >= LEFT_MAX)) && echo $(( ${TT_DIM[d]#*x} + spacer )); done)
            [[ $offsets2 ]] && offsets2="$TEXT_Y_START $offsets2"
            tt_dim2=$(running_total <<< $offsets2)
        fi
        offsets1="$TEXT_Y_START $offsets1"
        tt_dim1=$(running_total <<< $offsets1)
        tt_dim="$tt_dim1 $tt_dim2"
        unset SHOWCASE_TITLES_Y_ARRAY
        SHOWCASE_TITLES_Y_ARRAY=( $tt_dim1 $tt_dim2 )
        # get the y position of the last title in 1st column (tt_dim1)
        last_title_col1=$(wc -w <<< "$tt_dim1")
        last_title_col1_ydim=${SHOWCASE_TITLES_Y_ARRAY[last_title_col1-1]/*x}
        # add the y dimension of the last title size to the above y position
        SW_CORNER=$(( ${TT_DIM[last_title_col1-1]/*x} + $last_title_col1_ydim ))
        avail_palette1=$(( ( ${VIDSIZE/*x} - 50 ) - $SW_CORNER ))
        # if there are 2 columns, get same data for column 2
        if [[ -n $tt_dim2 ]]; then
            last_title_col2=$NUM_FILES
            last_title_col2_ydim=${SHOWCASE_TITLES_Y_ARRAY[last_title_col2]/*x}
            SE_CORNER=$(( ${TT_DIM[last_title_col2]/*x} + $last_title_col2_ydim ))
            avail_palette2=$(( ( ${VIDSIZE/*x} - 50 ) - $SE_CORNER ))
        fi
        # availible space is lowest value of 2 *palette* vars ( if 2 columns)
        if [[ -n $tt_dim2 ]] && ((SE_CORNER > SW_CORNER)); then
            avail_palette=$avail_palette2
        else
            avail_palette=$avail_palette1
        fi
        # get the height of each column for -align centre
        if [[ $BUTTON_GRAVITY = centre || $BUTTON_GRAVITY = east || $BUTTON_GRAVITY = west ]]; then
            WEST_PALETTE=$(( SW_CORNER - TEXT_Y_START))
            EAST_PALETTE=$((SE_CORNER - TEXT_Y_START))
            ((WEST_PALETTE > EAST_PALETTE)) && PALETTE=$WEST_PALETTE || PALETTE=$EAST_PALETTE
            CANVAS=$(( ${VIDSIZE/*x} - 100 ))
            NEW_TEXT_Y_START=$(( ((CANVAS - PALETTE) / 2) + 50 ))
            TEXT_Y_START_OFFSET=$((NEW_TEXT_Y_START - TEXT_Y_START))
        fi
        # add the available palette to each title position for south alignment
        if [[ $BUTTON_GRAVITY = *south* ]] && ((avail_palette > 0)); then
            for ((d=0; d<=NUM_FILES; d++)); do
                SHOWCASE_TITLES_Y_ARRAY[d]=$(( ${SHOWCASE_TITLES_Y_ARRAY[d]} + $avail_palette ))
            done
        elif  [[ $BUTTON_GRAVITY = centre || $BUTTON_GRAVITY = east || $BUTTON_GRAVITY = west ]]; then
            for ((d=0; d<=NUM_FILES; d++)); do
                SHOWCASE_TITLES_Y_ARRAY[d]=$(( ${SHOWCASE_TITLES_Y_ARRAY[d]} + $TEXT_Y_START_OFFSET ))
            done
        fi
        if [[ $BUTTON_GRAVITY = *east* ]]; then
            east_offset=$(( ( ${VIDSIZE/x*} - 50 ) - MAX_LEN ))
            for ((d=0; d<=NUM_FILES; d++)); do
                if ((${#SHOWCASE_TITLES_X_ARRAY[@]} <= SPLIT)) ; then
                    SHOWCASE_TITLES_X_ARRAY[d]=$east_offset
                else
                    if [ ${SHOWCASE_TITLES_X_ARRAY[d]} -ge 360 ]; then
                        SHOWCASE_TITLES_X_ARRAY[d]=$east_offset
                    fi
                fi
            done
        fi
        unset MAX_VAL val max_key
    fi
    # make array of SHOWCASE_PAGES for thumbs and THUMBTITLES_ARRAY for titles
    # use preset values unless doing centre align for titles
    for ((i=0; i<=NUM_FILES; i++)); do
        if [ "$SC_TITLE_ALIGN" != "centre" ]; then
            SHOWCASE_TITLES_ARRAY[i]=+${SHOWCASE_TITLES_X_ARRAY[i]}+${SHOWCASE_TITLES_Y_ARRAY[i]}
        else
            SHOWCASE_TITLES_ARRAY[i]=+${k[i]}+${SHOWCASE_TITLES_Y_ARRAY[i]}
        fi

        SHOWCASE_THUMB_PAGES[i]="-page ${SHOWCASE_THUMB_PAGES_ARRAY[i]}"
        THUMBTITLES_ARRAY[i]="-page ${SHOWCASE_TITLES_ARRAY[i]}"
    done
fi
# make a PLAYALL button if called for
if $PLAYALL; then
    PLAYALL_BTN_CMD=(convert -size 100x100 xc:none \
    -font "$MENU_FONT" -pointsize 20 \
    -fill black -stroke black -gravity center  \
    -annotate +0+0 "Play All" \
    -fill "$TITLE_COLOUR" -stroke "$STROKE" -strokewidth 1 \
    -annotate +1+1 "Play All")
    TRIM_CMD=(convert - -background none -rotate -30 -trim +repage "$WORK_DIR/PLAYALL.png")
    "${PLAYALL_BTN_CMD[@]}" miff:- | "${TRIM_CMD[@]}"|fold -bs >> "$LOG_FILE"
    ADD_PLAYALL="$WORK_DIR/PLAYALL.png -gravity SouthEast -geometry +55+55 -composite"
fi

if $MIST; then
    echo
    echo "Making a white or colored png for the misted title background"
    echo
    # make a white or coloured png for misted background effect, only for user bg
    X=$(identify "$WORK_DIR/title_txt.png" |awk '{print $3}'|cut -dx -f1)
    Y=$(identify "$WORK_DIR/title_txt.png" |awk '{print $3}'|cut -dx -f2)
    # add 10 pixels to width and height compared to title text png
    y=$((Y + 40))
    x=$((X + 40))
    newX=$(($X + 30))
    newY=$(($Y + 30))
    DIM=${x}x${y}
    convert -size $DIM xc:none -fill $MIST_COLOUR -stroke none \
    -draw "rectangle 10,10 $newX,$newY" "$WORK_DIR/white_orig.png"
    convert $WORK_DIR/white_orig.png -channel RGBA -blur 0x4 "$WORK_DIR/white.png"
    unset X Y x y
fi

###############################################################################
#      generate a basic preview of the main menu                              #
###############################################################################
# generate images for montage and title and resize them
if [[ -n "$BG_VIDEO" ]]; then
    echo "Getting background video images from $BG_VIDEO"
    FFMPEG_CMD=(ffmpeg -i "$BG_VIDEO" -s $VIDSIZE -ss $BG_SEEK -vframes 1 \
    -vcodec png -an  -f rawvideo -y "$WORK_DIR/pics/template.png")
    echo -e "\nRunning: "${FFMPEG_CMD[@]}"\n" | fold -bs >> "$LOG_FILE"
    SED_VAR="frame="
    if "${FFMPEG_CMD[@]}" >> "$LOG_FILE.tmp" 2>&1;then
        cleanlog 3
    else
        cleanlog 3
        runtime_error "Problem creating images from the video."
        exit 1
    fi
fi
if $SHOWCASE && ! $NO_SC_THUMB; then
    if [[ -n "$SHOWCASE_VIDEO" ]]; then
        echo "Getting video images from $SHOWCASE_VIDEO"
        if [[ "$SC_FRAMESTYLE" = "glass" && -n "$SHOWCASE_VIDEO" ]]; then
            D=2
            OUTDIR="$WORK_DIR/showcase"
            OUT="$WORK_DIR/showcase_img.png"
            VOUT="png:z=7"; FRAMES=30
            FRAME_SIZE=$SHOWCASE_SIZE
            MPLAYER_SEEK_VAL=$SHOWCASE_SEEK_VAL
            echo "Using mplayer to get framed images from the showcase video"
            echo "Running: mplayer -ss $MPLAYER_SEEK_VAL -vo $VOUT \
            -vf expand=-5:-5,rectangle=384:256,rectangle=382:254,rectangle=380:252,rectangle=378:250 \
            -ao null -zoom -x 384 -y 256  -ss 0:0:05 -frames $FRAMES "$SHOWCASE_VIDEO"" |
            format_output | tee -a "$LOG_FILE"
            echo
            get_framed_pics "$SHOWCASE_VIDEO" >> "$LOG_FILE" 2>&1

            mv -v "$WORK_DIR"/00000025.png "$OUT"
            rm -f "$WORK_DIR"/00000*.png
            convert "$WORK_DIR/showcase_img.png" \
            -background none $ROTATE $WAVE miff:-|
            convert - -resize $SHOWCASE_SIZE! "$WORK_DIR/showcase_img.png"
        elif [ "$SC_FRAMESTYLE" = "none" ]; then
            FFMPEG_CMD=(ffmpeg -i "$SHOWCASE_VIDEO" -ss $SHOWCASE_SEEK_VAL \
            -s $SHOWCASE_SIZE  -vframes 1 -vcodec png -an -f rawvideo -y \
            "$WORK_DIR/showcase_img.png")
            echo -e "\nRunning: "${FFMPEG_CMD[@]}"\n" | fold -bs >> "$LOG_FILE"
            SED_VAR="frame="
            if "${FFMPEG_CMD[@]}" >> "$LOG_FILE.tmp" 2>&1;then
                cleanlog 3
            else
                cleanlog 3
                runtime_error "Problem creating images from the video."
                exit 1
            fi
            echo "Running convert "$WORK_DIR/showcase_img.png" -mattecolor gray"
            echo "$SC_FRAME "$WORK_DIR/showcase_img.jpg"" |format_output
            convert "$WORK_DIR/showcase_img.png" -mattecolor gray $SC_FRAME miff:- |
            convert -background none $ROTATE $WAVE - miff:-|
            convert - -resize $SHOWCASE_SIZE! "$WORK_DIR/showcase_img.png"
        fi
    elif [[ -n "$SHOWCASE_IMG" ]]; then
        echo "Running convert -resize $SHOWCASE_SIZE! "$SHOWCASE_IMG" miff:- | \
        convert -background none $ROTATE $WAVE -bordercolor Transparent -border 8x8 - miff:- | \
        convert - -trim +repage -resize $SHOWCASE_SIZE! "$WORK_DIR/showcase_img.jpg"" |format_output
        convert "$SHOWCASE_IMG" -resize $SHOWCASE_SIZE! -mattecolor gray $SC_FRAME miff:- |
        convert - -background none -bordercolor Transparent -border 8x8 $ROTATE $WAVE miff:- |
        convert - -trim +repage -resize $SHOWCASE_SIZE! "$WORK_DIR/showcase_img.png"
    fi
fi
# transcode makes it harder to switch between PNG and JPEG for output
if [ $IMG_FMT = "jpg" ]; then
    EXPORT="-y jpg,null"
elif [ $IMG_FMT = "png" ]; then
    EXPORT="-y im -F png"
fi

# create the preview images
if ! $NO_THUMBS; then
    for ((i=0; i<=NUM_FILES; i++)) ; do
        # use a nav_seek file if long seek
        if [ ${SEEK_VAL[i]} -gt 450 ]; then
            NAVSEEK[i]="--nav_seek "$WORK_DIR/nav${i}_log""
            NAVSEEK_CMD=(nice tcdemux  $TCDEMUX_MODE -f $FRAME_RATE -W -i "${IN_FILES[i]}")
            run_navseek()
            {
                yecho "Running "${NAVSEEK_CMD[@]}" > "$WORK_DIR/nav${i}_log""
               "${NAVSEEK_CMD[@]}"  2>> "$WORK_DIR/tc_pids" > "$WORK_DIR/nav${i}_log"
            }

            run_navseek &
            NS_PID="$!"
            if [[ -n "$NS_PID" ]]; then
                while ps -p $NS_PID >/dev/null; do
                    sleep .5 # spinner interval
                    spin "Creating a nav_seek log for "${IN_FILES[i]}": $SPINNER"
                done
            fi
            length=( ${length[@]} $(( $(awk  '{ field = $2 }; END{ print field }'  "$WORK_DIR/nav${i}_log") + 1)) )
        fi
        if ! $NOASK; then
            echo
            echo "[$i of $NUM_FILES] Seeking to ${SEEK_VAL[i]} seconds in ${IN_FILES[i]}"
        fi

        TRANSCODE_CMD=(transcode -q 1 --write_pid /tmp/tcode.pid -i "${IN_FILES[i]}" \
        -c ${SEEK_FRAMES[i]}-$((${SEEK_FRAMES[i]} + 1)) ${NAVSEEK[i]} \
        -o $WORK_DIR/pics/$i/ -f 29.970  -Z $THUMB_SIZE $EXPORT)
        FFMPEG_CMD=(ffmpeg -i "${IN_FILES[i]}" -an -ss ${SEEK_VAL[i]} -vframes 1 \
        -s $THUMB_SIZE $WORK_DIR/pics/$i/%06d.$IMG_FMT)
        if $NOASK; then
            CMD=( "${FFMPEG_CMD[@]}" )
        else
            CMD=( "${TRANSCODE_CMD[@]}" )
        fi
        function run_transcode()
        {
            "${TRANSCODE_CMD[@]}" >> "$LOG_FILE" 2>&1
        }

        SED_VAR="frame="
        echo -e "\nRunning: "${CMD[@]}"\n" | fold -bs >> "$LOG_FILE"
        VOUT="png:z=7"; FRAMES=30
        FRAME_SIZE=$THUMB_SIZE
        D=2

        if [ "$SC_FRAMESTYLE" = "glass" ]; then
            MPLAYER_SEEK_VAL=${SEEK_VAL[i]}
            get_framed_pics "${IN_FILES[i]}"  >> "$LOG_FILE" 2>&1
            mv -fv $WORK_DIR/$(printf "%08d%s"  25 .$IMG_FMT) \
            $WORK_DIR/pics/$i/$(printf "%06d%s"  0 .$IMG_FMT)
            rm -f "$WORK_DIR"/00000*.png
        elif [ "$SC_FRAMESTYLE" = "none" ]; then
            if $NOASK; then
                if "${FFMPEG_CMD[@]}" >> "$LOG_FILE" 2>&1;then
                    : #cleanlog 3
                else
                    #cleanlog 3
                    runtime_error "Problem creating images from the video."
                    exit 1
                fi
            else
                run_transcode &
            fi
        fi

        [[ "$SC_FRAMESTYLE" = "none" && ! $NOASK ]] && check_stall &
        unset NAVSEEK_CMD rectangle run_transcode FFMPEG_CMD TRANSCODE_CMD
    done
fi
# overlay menu title and thumb titles on template
if $MIST; then
    # overlay white.png onto background
    composite -dissolve $MIST_OPACITY -gravity $TITLE_GRAVITY -geometry +0+${mist_pos} \
    "$WORK_DIR/white.png" "$WORK_DIR/pics/template.png" \
    "$WORK_DIR/pics/template.png"
fi
if $SHOWCASE; then
    for ((i=0; i<=NUM_FILES; i++)); do
        sc_thumb_title_cmd=( "${sc_thumb_title_cmd[@]}" "${THUMBTITLES_ARRAY[i]}"  \
        "$WORK_DIR/thumb_title${i}.png")
    done
    echo "Running:
    convert  -size $VIDSIZE "$WORK_DIR/pics/template.png"
    ${sc_thumb_title_cmd[@]} -page +210+400 "$WORK_DIR/title_txt.png" \
    -mosaic "$WORK_DIR/pics/template.png" "| format_output
    convert -size $VIDSIZE "$WORK_DIR/pics/template.png" \
    ${sc_thumb_title_cmd[@]} -mosaic "$WORK_DIR/pics/template.png"
    convert "$WORK_DIR/pics/template.png" "$WORK_DIR/title_txt.png" \
    -gravity $TITLE_GRAVITY -geometry +0+${title_pos} -composite "$WORK_DIR/pics/template.png"
fi
if $PLAYALL; then
    convert "$WORK_DIR/pics/template.png" "$WORK_DIR/PLAYALL.png" \
    -gravity SouthEast -geometry +55+55 -composite "$WORK_DIR/pics/template.png"
    convert "$WORK_DIR/pics/template.png" "$WORK_DIR/PLAYALL.png" \
    -gravity SouthEast -geometry +55+55 -composite "$WORK_DIR/pics/template.jpg"
fi
# lets be sure of order by using a loop
for ((i=0; i<=NUM_FILES; i++)); do
    PICS=( "${PICS[@]}" \
    $(find $WORK_DIR/pics/$i/  -maxdepth 1 -name 000\*.$IMG_FMT) )
done
if ! $NO_THUMBS; then
    for ((i=0; i<${#PICS[@]}; i++)); do
        if $THUMBS_3D && [ "$THUMB_SHAPE" != "normal" ]; then
        CURVE_VARS="5 3 5 1 1"
        . todisc-fade-routine
        fi
        PVIEW_CMD=(composite -compose CopyOpacity $THUMB_MASK +matte \
        "${PICS[i]}")
        PVIEW_CMD0=(convert "${PICS[i]}" $RAISE)
        PVIEW_CMD1=(convert - $RAISE)
        PVIEW_CMD2=(convert - -write mpr:${i}img -fx A  +matte \
        -blur 0x$( printf  "%.2f" $(awk_math 6.9 plus .${CURVE_ARRAY[i]/.} float) ) \
        -shade $(awk_math 115 plus ${CURVE_ARRAY[i]})x30 -normalize mpr:${i}img -compose \
        Overlay -composite mpr:${i}img  -matte  -compose Dst_In -composite)
        PVIEW_CMD3=(convert -trim +repage - "${PICS[i]}")
        if $FEATHER; then
            if $THUMBS_3D; then
                if $SHOWCASE; then
                    if [ "$THUMB_SHAPE" != "normal" ]; then
                        "${PVIEW_CMD[@]}" miff:- |
                        "${PVIEW_CMD2[@]}" miff:- |
                        "${PVIEW_CMD3[@]}"
                    else # normal thumbshape
                        "${PVIEW_CMD0[@]}" miff:- | "${PVIEW_CMD1[@]}" miff:- |
                        "${PVIEW_CMD3[@]}"
                    fi
                else  # not $SHOWCASE
                    if [ "$THUMB_SHAPE" != "normal" ]; then
                        "${PVIEW_CMD[@]}" miff:- |
                        "${PVIEW_CMD2[@]}" "${PICS[i]}"
                    else # normal thumbshape
                        echo "Running
                        "${PVIEW_CMD0[@]}" miff:- | "${PVIEW_CMD3[@]}"
                        "|format_output
                        "${PVIEW_CMD0[@]}" miff:- | "${PVIEW_CMD3[@]}"
                    fi
                fi
            else # not 3D
                "${PVIEW_CMD[@]}" miff:- | "${PVIEW_CMD3[@]}"
            fi
        else # not FEATHER
            "${PVIEW_CMD0[@]}" miff:- | "${PVIEW_CMD3[@]}"
        fi

        IM_CMD=(convert -background none $THUMB_FRAME -bordercolor "#444744" $RAISE "${PICS[i]}")
        IM_CMD0=(composite -gravity center -compose DstOver "$WORK_DIR/feather_mask2.png" "${PICS[i]}")
        IM_CMD1=(montage "${PICS[i]}" -geometry +4+4 -compose Copy  \
        -background  none -fill "$THUMB_TEXT_COLOUR" -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE \
        -title "${TITLES[i]}")
        IM_CMD2=(convert -resize $THUMB_SIZE! -)
        IM_CMD3=(composite -gravity center -compose DstOver "$WORK_DIR/feather_mask2.png" - )
        IM_CMD4=(convert -background none -frame 3x3 \
        -bordercolor "#444744" -)
        IM_CMD5=(convert -resize $THUMB_SIZE! - "${PICS[i]}")
        if $FEATHER; then
            if $SHOWCASE; then
                "${IM_CMD0[@]}" miff:- | "${IM_CMD5[@]}"
            else  # feather, but not showcase
                "${IM_CMD1[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
                "${IM_CMD3[@]}" miff:- | "${IM_CMD5[@]}"
            fi
        else  # not feather
            if $SHOWCASE; then
                "${IM_CMD[@]}" miff:- | "${IM_CMD5[@]}"
            else # not feather and not showcase
                "${IM_CMD1[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
                "${IM_CMD4[@]}" miff:- | "${IM_CMD5[@]}"
            fi
        fi
    done
fi

##############################################################################
#                 create button layer for spumux                             #
##############################################################################
get_button_geo()
{
    GEOx=${MENU_BUTTON_SIZE/x*}
    GEOy=${MENU_BUTTON_SIZE/*x}
    GEOx=$((GEOx - 3))
    GEOy=$((GEOy - 3))
    GEO="$GEOx,$GEOy"
}
echo
echo "Creating the highlight and selection PNGs for the main menu"
if [ "$BUTTON_STYLE" = "rect" ]; then
    MENU_BUTTON_SIZE=$THUMB_SIZE
    get_button_geo
(
cat  <<EOF
rectangle 2,2 $GEO
EOF
)  > "$WORK_DIR/draw_file"
fi
if [ $BUTTON_STYLE = "text-rect" ]; then
    for ((i=0; i<=NUM_FILES; i++)); do
        MENU_BUTTON_SIZE=${TT_DIM[i]}
        get_button_geo
(
cat <<EOF
rectangle 1,1 $GEO
EOF
)  > "$WORK_DIR/draw_file${i}"
    done
fi
# command constructions for -button-style options
if $PLAYALL; then
    for BUTTON in "$SELECT_COLOUR" "$HIGHLIGHT_COLOUR"; do
        convert -size 100x100 xc:none -font "$MENU_FONT" -pointsize 20 \
        -fill "$BUTTON" -stroke none -gravity center \
        -annotate +0+0 "Play All" \
        -fill "$BUTTON" -stroke none -strokewidth 1  \
        -annotate +1+1 "Play All" miff:- | convert  - -background none -rotate -30 \
        -trim +repage $WORK_DIR/${BUTTON/\#}_playall.png
    done
fi

PNG_IS_DONE=false
for ((t=0; t<${#TITLES[@]}; t++)); do
    unset BUTTON_CMD6b BUTTON_CMD7b
    if $FEATHER; then FRAME=0; else FRAME=3x3;fi
    BUTTON_SIZE=$THUMB_SIZE
    BUTTON_CMD=(montage -size $THUMB_SIZE xc:none -geometry +4+4 \
    -background none -mattecolor none -bordercolor none -stroke none \
    -fill "$SELECT_COLOUR" -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE \
    -title "${TITLES[t]}" -compose CopyOpacity)
    BUTTON_CMD1=(montage -size $THUMB_SIZE xc:none -geometry +4+4 \
    -background none -mattecolor none -bordercolor none -stroke none \
    -fill "$HIGHLIGHT_COLOUR" -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE \
    -title "${TITLES[t]}" -compose CopyOpacity)
    BUTTON_CMD2=(convert -mattecolor none -background none \
    -bordercolor none -frame 3x3 -)
    BUTTON_CMD3=(convert - -resize ${THUMB_SIZE}! +antialias)
    BUTTON_CMD4=(convert -size "${THUMB_SIZE}+5+5"  xc:none \
    -fill none +antialias -stroke "$SELECT_COLOUR" -strokewidth 4 -draw @draw_file \
    -colors 3 "$WORK_DIR/Selectx1.png")
    BUTTON_CMD5=(convert -size "${THUMB_SIZE}+5+5" xc:none \
    -fill none +antialias -stroke "$HIGHLIGHT_COLOUR" -strokewidth 4 -draw @draw_file \
    -colors 3 "$WORK_DIR/Highlightx1.png")
    BUTTON_CMD6=(convert -size ${THUMB_SIZE}+5+5 xc:none +antialias -fill none \
    -stroke "$SELECT_COLOUR" -strokewidth 4 -draw @draw_file "$WORK_DIR/Selectx1.png")
    BUTTON_CMD6b=(convert -size ${TT_DIM[t]} xc:none +antialias -fill none \
    -stroke "$SELECT_COLOUR" -strokewidth 4 -draw @draw_file${t} \
    "$WORK_DIR/$(printf %06d%s%s ${t} -select .png)")
    BUTTON_CMD7=(convert -size ${THUMB_SIZE}+5+5 xc:none +antialias -fill none \
    -stroke "$HIGHLIGHT_COLOUR" -strokewidth 4 -draw @draw_file "$WORK_DIR/Highlightx1.png")
    BUTTON_CMD7b=(convert -size ${TT_DIM[t]} xc:none +antialias -fill none \
    -stroke "$HIGHLIGHT_COLOUR" -strokewidth 4 -draw @draw_file${t} \
    "$WORK_DIR/$(printf %06d%s%s ${t} -highlight .png)")
    BUTTON_CMD8=(convert -size 620x300 xc:none \
    -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE \
    -fill $HIGHLIGHT_COLOUR -stroke none -gravity $THUMB_TITLE_ALIGN  \
    -annotate +0+0 "${TITLES[t]}" \
    -fill $HIGHLIGHT_COLOUR -stroke $HIGHLIGHT_COLOUR -strokewidth 1 \
    -annotate +1+1 "${TITLES[t]}")
    BUTTON_CMD9=(convert -size 620x300 xc:none \
    -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE \
    -fill $SELECT_COLOUR -stroke none -gravity $THUMB_TITLE_ALIGN  \
    -annotate +0+0 "${TITLES[t]}" \
    -fill $SELECT_COLOUR -stroke $SELECT_COLOUR -strokewidth 1 \
    -annotate +1+1 "${TITLES[t]}")
    BUTTON_CMD10=(convert - -trim +repage)

    if [ "$BUTTON_STYLE" = "text" ]; then
        if $SHOWCASE; then
            "${BUTTON_CMD8[@]}" miff:- |  "${BUTTON_CMD10[@]}" \
            "$WORK_DIR/$(printf %06d%s%s ${t} -highlight .png)"
            "${BUTTON_CMD9[@]}" miff:- |  "${BUTTON_CMD10[@]}" \
            "$WORK_DIR/$(printf %06d%s%s ${t} -select .png)"
        else # not showcase
            if $FEATHER; then
                "${BUTTON_CMD[@]}" miff:- | "${BUTTON_CMD3[@]}" \
                "$WORK_DIR/$(printf %06d%s%s ${t} -select .png)"
                "${BUTTON_CMD1[@]}" miff:- | "${BUTTON_CMD3[@]}" \
                "$WORK_DIR/$(printf %06d%s%s ${t} -highlight .png)"
            else
                "${BUTTON_CMD[@]}" miff:- | "${BUTTON_CMD2[@]}" miff:- |
                "${BUTTON_CMD3[@]}" \
                "$WORK_DIR/$(printf %06d%s%s ${t} -select .png)"
                "${BUTTON_CMD1[@]}" miff:- | "${BUTTON_CMD2[@]}" miff:- |
                "${BUTTON_CMD3[@]}" "$WORK_DIR/$(printf %06d%s%s ${t} -highlight .png)"
            fi
        fi
    elif [ $BUTTON_STYLE = "rect" ]; then
        if  ! $PNG_IS_DONE; then
            if $SHOWCASE; then
                "${BUTTON_CMD6[@]}"
                "${BUTTON_CMD7[@]}"
            else
                "${BUTTON_CMD4[@]}" 2> /dev/null
                "${BUTTON_CMD5[@]}" 2> /dev/null
            fi
        fi
    elif [ $BUTTON_STYLE = "text-rect" ]; then
        "${BUTTON_CMD6b[@]}"
        "${BUTTON_CMD7b[@]}"
    fi
    PNG_IS_DONE=: # do not loop over creating same png
done
#if ! $NOASK && ! $SHOWCASE; then
#    echo "Creating and displaying a preview of the main menu."
#    echo "(Press 'q' or ESC in the preview window to close it.)"
#fi
if [ "$BUTTON_STYLE" = "rect" ]; then
    for button in Select Highlight; do
        if $SHOWCASE; then
            unset sc_spumux_cmd fake_montage_cmd
            BUTTON_DIM=$(identify "$WORK_DIR/Highlightx1.png" |awk '{print $3}')
            convert -size $BUTTON_DIM xc:none -background none $WORK_DIR/empty-button.png
            fake_montage=( $WORK_DIR/Highlightx1.png $(for ((i=0; i<NUM_FILES-1; i++)); do
            echo $WORK_DIR/empty-button.png; done))
            for ((i=0; i<=NUM_FILES; i++)); do
                fake_montage_cmd=( ${fake_montage_cmd[@]} ${SHOWCASE_THUMB_PAGES[i]} "${fake_montage[i]}")
                sc_spumux_cmd=( ${sc_spumux_cmd[@]} ${SHOWCASE_THUMB_PAGES[i]} "$WORK_DIR/${button}x1.png" )
            done
            convert  -size $VIDSIZE xc:none -background none \
            ${fake_montage_cmd[@]} -mosaic "$WORK_DIR/fake_montage.png"
            convert  -size $VIDSIZE xc:none -background none \
            ${sc_spumux_cmd[@]} -mosaic "$WORK_DIR/${button}.png"
        else
            montage -background none \
            $(for ((i=0; i<=NUM_FILES; i++)); do echo $WORK_DIR/${button}x1.png;done) \
            -tile ${TILE_ARRAY[NUM_FILES]} -geometry ${THUMB_SIZE}+10+4 \
            -bordercolor none -mattecolor transparent miff:- |
            convert  -colors 3 -size $VIDSIZE xc:none - -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} \
            -composite  "$WORK_DIR/${button}.png"
            BUTTON_DIM=$(identify "$WORK_DIR/Highlightx1.png" |awk '{print $3}')
            convert -size $BUTTON_DIM xc:none -background none $WORK_DIR/empty-button.png
            fake_montage=( $WORK_DIR/Highlightx1.png $(for ((i=0; i<NUM_FILES-1; i++)); do
            echo $WORK_DIR/empty-button.png; done))
            montage -background none ${fake_montage[@]} \
            -tile ${TILE_ARRAY[NUM_FILES]} -geometry ${GEO_ARRAY[NUM_FILES]}+10+4 \
            -bordercolor none -mattecolor transparent miff:- |
            convert  -size $VIDSIZE xc:none - -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} \
            -composite "$WORK_DIR/fake_montage.png"
        fi
    done
elif [[ "$BUTTON_STYLE" = *text* ]]; then
    if $SHOWCASE; then
        select_buttons=( ${select_buttons[@]} \
        $(find $WORK_DIR/ -name 00\*select.png |sort) )
        highlight_buttons=( ${highlight_buttons[@]} \
        $(find $WORK_DIR/ -name 00\*highlight.png |sort) )
        for ((i=0; i<=NUM_FILES; i++)); do
            sc_select_cmd=(${sc_select_cmd[@]} ${THUMBTITLES_ARRAY[i]} "${select_buttons[i]}")
            sc_highlight_cmd=(${sc_highlight_cmd[@]} ${THUMBTITLES_ARRAY[i]} "${highlight_buttons[i]}")
        done
        convert -colors 3 -size $VIDSIZE xc:none -background none \
        ${sc_highlight_cmd[@]} -mosaic "$WORK_DIR/Highlight.png"
        convert  -colors 3 -size $VIDSIZE xc:none -background none \
        ${sc_select_cmd[@]} -mosaic "$WORK_DIR/Select.png"
    else
        select_buttons=( ${select_buttons[@]} \
        $(find $WORK_DIR/ -name 00\*select.png |sort) )
        highlight_buttons=( ${highlight_buttons[@]} \
        $(find $WORK_DIR/ -name 00\*highlight.png |sort) )
        montage -background none ${select_buttons[@]} \
        -tile ${TILE_ARRAY[NUM_FILES]} -geometry ${GEO_ARRAY[NUM_FILES]}+10+4 \
        -bordercolor none -mattecolor transparent miff:- |
        convert  -size $VIDSIZE xc:none - -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} \
        -composite "$WORK_DIR/Select.png"
        montage -background none ${highlight_buttons[@]} \
        -tile ${TILE_ARRAY[NUM_FILES]} -geometry ${GEO_ARRAY[NUM_FILES]}+10+4 \
        -bordercolor none -mattecolor transparent miff:- |
        convert  -size $VIDSIZE xc:none - -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} \
        -composite "$WORK_DIR/Highlight.png"
        BUTTON_DIM=$(identify "$WORK_DIR/000000-highlight.png" |awk '{print $3}')
        convert -size $BUTTON_DIM xc:none -background none $WORK_DIR/empty-button.png
        fake_montage=( $WORK_DIR/000000-highlight.png $(for ((i=0; i<NUM_FILES-1; i++)); do
        echo $WORK_DIR/empty-button.png; done))
    fi
    if $SHOWCASE; then
        convert  -size $VIDSIZE xc:none -background none \
        ${THUMBTITLES_ARRAY[0]} $WORK_DIR/000000-highlight.png \
        -mosaic "$WORK_DIR/fake_montage.png"
    else
        montage -background none ${fake_montage[@]} \
        -tile ${TILE_ARRAY[NUM_FILES]} -geometry ${GEO_ARRAY[NUM_FILES]}+10+4 \
        -bordercolor none -mattecolor transparent miff:- |
        convert  -size $VIDSIZE xc:none - -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} \
        -composite "$WORK_DIR/fake_montage.png"
    fi
fi
if $PLAYALL; then
    convert -gravity SouthEast -geometry +55+55 "$WORK_DIR/Select.png" \
    $WORK_DIR/${HIGHLIGHT_COLOUR/\#}_playall.png -composite "$WORK_DIR/Select.png"
    convert -gravity SouthEast -geometry +55+55 "$WORK_DIR/Highlight.png" \
    $WORK_DIR/${SELECT_COLOUR/\#}_playall.png -composite "$WORK_DIR/Highlight.png"
fi

# this reduces colours so spumux is happy
for button in Select Highlight; do
    mogrify -channel A -threshold 99% "$WORK_DIR/${button}.png"
done
if $SHOWCASE; then
    if ! $NO_SC_THUMB; then
        # find out where to put the showcase image/video in the X axis
        sc_size=$(identify "$WORK_DIR/showcase_img.png"|awk '{print $3}')
        sc_width=${sc_size/x*}
        sc_height=${sc_size/*x}
    fi
    if ! $NO_SC_THUMB && ! $TEXTMENU; then
        sc_xpage=$(( 360 - (sc_width / 2) )) # for -gt 5 videos
        if [[ $MAX_LEN -ge ${THUMB_SIZE/x*} ]]; then
            htmb=$(( ${THUMB_SIZE/x*} / 2 )) ; htle=$((MAX_LEN / 2))
            [[ "$SC_TITLE_ALIGN" = "centre" ]] && T=$(( htmb + htle )) || T=$((MAX_LEN + 5))
        else
            [[ "$SC_TITLE_ALIGN" = "centre" ]] &&  T=${THUMB_SIZE/x*}
        fi
        # add the thumb size if east align; for west align use MAX_LEN only
        [[ "$SC_TITLE_ALIGN" = "east" ]] && TS=${THUMB_SIZE/x*} || TS=0
        sc_palette=$((${VIDSIZE%x*} - ${SHOWCASE_THUMB_X_ARRAY[0]} - SAFE_AREA - T))
        # sc_palette is for centre align
        sc_palette=$(( ( ${SHOWCASE_THUMB_X_ARRAY[0]} + T) + (sc_palette / 2)))
        # sc_palette2 is for east and west align
        sc_palette2=$(( ${VIDSIZE%x*} - (${SHOWCASE_THUMB_X_ARRAY[0]} + TS + T + sc_width + SAFE_AREA) ))
        sc_xpage2=$((sc_palette - $((sc_width / 2)) ))
        sc_xpage3=$(( sc_palette2 / 2 ))
        sc_xpage3=$(( ${SHOWCASE_THUMB_X_ARRAY[0]} + $TS + 5 + T + sc_xpage3 ))
        # find out where to put the showcase image in the Y axis
        Y1=${SHOWCASE_THUMB_Y_ARRAY[0]}; Y2=${SHOWCASE_THUMB_Y_ARRAY[NUM_FILES]}
        Y_SPACE=$(( (Y2 - Y1) + ${THUMB_SIZE/*x} ))
        Y_SPACE=$(( Y_SPACE - sc_height ))
        SC_Y=$(( Y_SPACE / 2))
        SC_Y=$(( ${SHOWCASE_THUMB_Y_ARRAY[0]} + SC_Y ))
        if [ $V_TOTAL -le 5 ]; then
            if [[ $SC_TITLE_ALIGN = *st ]]; then
                SC_IMG_PAGE="-page +$sc_xpage3+$SC_Y"
            else
                SC_IMG_PAGE="-page +$sc_xpage2+$SC_Y"
            fi
        elif [ $V_TOTAL -gt 5 ]; then
            SC_IMG_PAGE="-page +$sc_xpage+$SC_Y"
        fi
        SC_IMG_CMD="$SC_IMG_PAGE "$WORK_DIR/showcase_img.png""
    elif ! $NO_SC_THUMB && $TEXTMENU; then
        :
        # FIXME allow showcase thumb with various textmenu options
        # needs to work with 1 column and 2 columns - 2 cols must be -align east
        #sc_xpage=$(( 360 - (sc_width / 2) )) # for -gt 5 videos
        #SC_TITLE_ALIGN="east"
        #sc_palette2=$(( ${VIDSIZE%x*} - (${SHOWCASE_TITLES_Y_ARRAY[0]} + MAX_LEN + 5) ))
        #sc_xpage2=$((sc_palette2 - $((sc_width / 2)) ))
        #SC_IMG_PAGE="-page +$sc_xpage2+$SC_Y"
        #SC_IMG_CMD="$SC_IMG_PAGE "$WORK_DIR/showcase_img.png""
    fi
    if $NO_SC_THUMB; then unset SC_IMG_CMD; fi
    if [[ -n "$SHOWCASE_IMG" || -n "$SHOWCASE_VIDEO" ]]; then
        unset sc_cmd
        for ((i=0; i<=NUM_FILES; i++)); do
            sc_cmd=( ${sc_cmd[@]} ${SHOWCASE_THUMB_PAGES[i]} "${PICS[i]}")
        done
        $NO_THUMBS && unset sc_cmd
        if $TRANSPARENT; then
            IM_CMD0=(convert  -size $VIDSIZE xc:none -background none \
            ${sc_cmd[@]} $SC_IMG_CMD -mosaic)
            IM_CMD1=(convert -size $VIDSIZE -background none \
                - ${sc_thumb_title_cmd[@]} -mosaic)
            IM_CMD2=(composite -size $VIDSIZE -background none \
                -gravity NorthWest  -dissolve $OPACITY - "$WORK_DIR/pics/template.png" \
                -background none)
            IM_CMD3=(convert - $WORK_DIR/title_txt.png  \
                -gravity $TITLE_GRAVITY -geometry +0+${title_pos} -composite "$WORK_DIR/preview.jpg" )
            echo "Running
            "${IM_CMD0[@]}" miff:- | "${IM_CMD1[@]}" miff:- |
            "${IM_CMD2[@]}" miff:- | "${IM_CMD3[@]}"
            " |format_output
            "${IM_CMD0[@]}" miff:- | "${IM_CMD1[@]}" miff:- |
            "${IM_CMD2[@]}" miff:- | "${IM_CMD3[@]}"
        else
            echo "Running:
            convert  -size $VIDSIZE "$WORK_DIR/pics/template.png"
            ${sc_cmd[@]} $SC_IMG_CMD \
            -mosaic "$WORK_DIR/preview.jpg" "|sed "s/    */ /g;s/^ *//"|fold -bs
            convert  -size $VIDSIZE "$WORK_DIR/pics/template.png" \
            ${sc_cmd[@]} $SC_IMG_CMD \
            -mosaic "$WORK_DIR/preview.jpg"
        fi
        unset sc_cmd IM_CMD05 IM_CMD04 IM_CMD03 IM_CMD4
    fi
else # not showcase

    if $TRANSPARENT; then
        montage ${PICS[@]} -blur 0x.3 -tile ${TILE_ARRAY[NUM_FILES]} \
        -geometry ${GEO_ARRAY[NUM_FILES]}+10+4 -background none -bordercolor "#444744" miff:- |
        composite -dissolve $OPACITY \
        -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} - \
        "$WORK_DIR/pics/template.png" -background none miff:- |
        convert - "$WORK_DIR/title_txt.png"  \
        -gravity $TITLE_GRAVITY -geometry +0+${title_pos} -composite "$WORK_DIR/preview.jpg"
    else # Not transparent
        montage ${PICS[@]} -tile ${TILE_ARRAY[NUM_FILES]} \
        -geometry ${GEO_ARRAY[NUM_FILES]}+10+4  -background none -bordercolor "#444744" miff:- |
        convert "$WORK_DIR/pics/template.png" \
        "$WORK_DIR/title_txt.png"  -gravity $TITLE_GRAVITY -geometry +0+${title_pos} -composite \
        -  -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} -composite "$WORK_DIR/preview.jpg"
    fi
fi
if ! $NOASK; then
    echo "Creating and displaying a preview of the main menu."
    echo "(Press 'q' or ESC in the preview window to close it.)"
fi
# make the fake montage with highlighted 1st button and display it
composite -compose Over "$WORK_DIR/fake_montage.png" "$WORK_DIR/preview.jpg" \
"$WORK_DIR/preview.jpg"
if $PLAYALL; then
convert -gravity SouthEast -geometry +55+55 "$WORK_DIR/preview.jpg" \
"$WORK_DIR/PLAYALL.png" -composite "$WORK_DIR/preview.jpg"
fi
if ! $NOASK; then
    convert -resize $PREVIEW_SIZE! "$WORK_DIR/preview.jpg" miff:- |
    display -title "todisc preview - close window to continue" -
    confirm_preview
fi
# copy the template back if using $MENU_FADE
if $MENU_FADE; then
    rm -v "$WORK_DIR/pics/template.png"
    cp -v "$WORK_DIR/pics/template.bk.png" "$WORK_DIR/pics/template.png"
fi
#rm -fv "${PICS[@]}"
unset PICS IM_CMD1 IM_CMD2 IM_CMD3 IM_CMD4 IM_CMD5

###############################################################################
#   get information about input videos, and some post preview preliminaries   #
###############################################################################

# if -bgvideo selected, but not -bgaudio, offer to use audio from bgvideo
if ! $NOASK; then
    if [[ -n "$BG_VIDEO" && -z "$BG_AUDIO" ]]; then
        if ! mencoder -quiet "$BG_VIDEO" -oac pcm -ovc copy -frames 0 \
        -o /dev/null 2>&1|grep Audio 2>&1 >/dev/null; then
            :
        else
            echo "You selected -bgvideo but not -bgaudio"
            echo "If you want to use the audio from "$BG_VIDEO" please type: yes"
            read bgaudio
            if [ ! -z "$bgaudio" -a "$bgaudio" = "yes" ]; then
                BG_AUDIO="$BG_VIDEO"
                echo "Using audio from "$BG_VIDEO""
            else
                echo "No audio selected, will use silence for main menu"
            fi
        fi
    fi
fi

# Check input files for compliance; offer to tovid-encode non-compliant files
check_compliance
check_compliance group
# check bgvideo and showcase VIDEO for compliance ( if present )
tovid_reencode()
{
    VIDEO_IN="$1"
    VIDEO_IN_SEEK="$2"
    $NOASK && NO_ASK="-noask"
    yecho "$VIDEO_IN is not complent - reencoding given slice to DVD compliant file"
    yecho "if you used a long seek this will take some time and produce a large file"
    yecho "Encoding $((VIDEO_IN_SEEK + ANI_MENU_LENGTH)) seconds of $VIDEO_IN"
    yecho "If the file is not encoded this way there may be sync problems"
    yecho "Do you want to continue encoding this file?, type 'yes' to do so"
    if ! $NOASK; then
        read response
        if [ ! -z "$response" -a "$response" = "yes" ]; then
            :
        else
            return
        fi
    fi
    tovid $NO_ASK -in "$VIDEO_IN" -slice 0-$((VIDEO_IN_SEEK + ANI_MENU_LENGTH)) -$TV_STANDARD \
    -$TARGET -in "$VIDEO_IN" -out "$VIDEO_IN.enc" $TOVID_OPTS
    # See if output file exists
    if ! test -f "$VIDEO_IN.enc.mpg"; then
        runtime_error "Could not encode file: $VIDEO_IN"
    fi
    SUPPORT_VIDEOS=( "${SUPPORT_VIDEOS[@]}" "$VIDEO_IN.enc.mpg" )
    yecho "Encoded file is "$VIDEO_IN.enc.mpg", this will be deleted when todisc is finished unless you used -keepfiles"
    yecho
}
if [[ -n $BG_VIDEO ]] && ! idvid -isformat dvd "$BG_VIDEO" >/dev/null; then
    tovid_reencode "$BG_VIDEO" $BG_SEEK && BG_VIDEO="$BG_VIDEO.enc.mpg"
elif [[ -n $SHOWCASE_VIDEO ]]  && ! idvid -isformat dvd "$SHOWCASE_VIDEO" >/dev/null; then
    tovid_reencode "$SHOWCASE_VIDEO" $SHOWCASE_SEEK_VAL && SHOWCASE_VIDEO="$SHOWCASE_VIDEO.enc.mpg"
fi
# symlink IN_FILES in $WORK_DIR to solve some quoting issues for dvdauthor

for i in ${!IN_FILES[@]}; do
    (cd "$REAL_WORK_DIR" &&  ln -sv "${IN_FILES[i]}" $((i+1)).mpg)
done

# Store info about input files in an array
for ((i=0; i<${#IN_FILES[@]}; i++)); do
    # use a nav_seek file and transcode if long seek
    if [ ${SEEK_VAL[i]} -gt 450 ] || $SUB_MENU; then
        STATS_FRAMES="-frames 1"
        if [ ! -e "$WORK_DIR/nav${i}_log" ]; then
            NAVSEEK[i]="--nav_seek "$WORK_DIR/nav${i}_log""
            NAVSEEK_CMD=(nice tcdemux  $TCDEMUX_MODE -f $FRAME_RATE -W -i "${IN_FILES[i]}")
            run_navseek()
            {
                yecho "Running "${NAVSEEK_CMD[@]}" > "$WORK_DIR/nav${i}_log""
                "${NAVSEEK_CMD[@]}"  2>> "$WORK_DIR/tc_pids" > "$WORK_DIR/nav${i}_log"
            }

            run_navseek &
            NS_PID="$!"
            if [[ -n "$NS_PID" ]]; then
                while ps -p $NS_PID >/dev/null; do
                    sleep .5 # spinner interval
                    spin "Creating a nav_seek log for "${IN_FILES[i]}": $SPINNER"
                done
            fi
            length=( ${length[@]} $(( $(awk '{ field = $2 }; END{ print field }' \
            "$WORK_DIR/nav${i}_log") + 1)) )
        fi
    fi
    echo
    echo "Getting stats on "${IN_FILES[i]}""
    mencoder_stats=("${mencoder_stats[@]}" \
    "$(mencoder -quiet "${IN_FILES[i]}" -oac pcm -ovc copy \
    $STATS_FRAMES -o /dev/null 2>&1)")
    unset NAVSEEK_CMD
done
if $GROUPING; then
    echo
    echo ". . . Getting stats on grouped files now . . ."
    echo
    for u in ${!grouping[@]}; do
        echo "Getting stats on "$(readlink "${grouping[u]}")""
        echo
        group_mencoder_stats=( "${group_mencoder_stats[@]}" \
        "$(mencoder -quiet "${grouping[u]}" -oac pcm -ovc copy \
        $STATS_FRAMES -o /dev/null 2>&1)")
    done
fi

# put in the log file in case anyone is interested
get_stats files
echo
$GROUPING && get_stats group
echo
echo $SEPARATOR

for ((i=0; i<${#mencoder_stats[@]}; i++)); do
    if [ -e "$WORK_DIR/nav${i}_log" ]; then
        VID_LEN=( ${VID_LEN[@]}  $(awk_math ${length[i]} by $FRAME_RATE float) )
    else
        VID_LEN=( ${VID_LEN[@]}  "$(awk '/Video stream:/{print $10}' \
        <<<"${mencoder_stats[i]}")" )
    fi
done
if $GROUPING; then
    index=0
    for i in "${!IN_FILES[@]}"; do
        if [[ ${GROUP[i]} ]]; then
            iter=( $WORK_DIR/group-$((i+1))-* )
            for ((t=index; t<index+${#iter[@]}; t++)); do
                GROUP_VID_LENGTHS[i]="${GROUP_VID_LENGTHS[i]} $(awk '/Video stream:/{print $10}' \
                <<< "${group_mencoder_stats[t]}")"
            done
            index=$((index+${#iter[@]}))
            unset iter
            GROUP_VID_LENGTHS[i]="${VID_LEN[i]} ${GROUP_VID_LENGTHS[i]}"
            GROUP_TOT_LEN[i]=$(awk_total <<< "${GROUP_VID_LENGTHS[i]}")
        fi
    done    
fi
echo
for ((i=0; i<${#VID_LEN[@]}; i++)); do
    NEW_LENGTH=( ${NEW_LENGTH[@]}   ${VID_LEN[i]%.*} )
done
# find out longest video and shortest video
for ((i=0; i<${#NEW_LENGTH[@]}; i++)); do
    val=${NEW_LENGTH[i]}
    [ -z "$MAX_VAL" ] || ((val > MAX_VAL)) && MAX_VAL=$val && max_key=$i
    if $ANI_SUB_MENU; then
        [ -z "$MIN_VAL" ]  || ((val < MIN_VAL)) && MIN_VAL=$val && min_key=$i
    fi
done
# if animated submenu check if videos are long enough for the # of chapters
if $ANI_SUB_MENU; then
    for ((i=0; i<=NUM_FILES; i++)); do
        S=$(awk_math ${SEEK_VAL[i]} times $FRAME_RATE)
        F=$(awk_math  "${CHAPTERS[i]}" times 340 )
        V=$(awk_math "${VID_LEN[i]}" times $FRAME_RATE)
        if [ $((V - S)) -le $F ] ; then
            echo "Sorry, you can not use ${CHAPTERS[i]} chapters for ${IN_FILES[i]}"
            echo "The maximum number for this video (using a -seek of ${SEEK_VAL[i]}):"
            echo "$(awk_math $((V - S)) by 340) chapters"
            exit 1
        fi
        unset V F
    done
fi
# allow animated menus of length of longest video
MAX_ANI_LENGTH=$(awk_math $FRAME_RATE times $ANI_MENU_LENGTH)
MAX_VAL_FRAMES="$((MAX_VAL * 30))"
#if [ $MAX_VAL_FRAMES -lt $MAX_ANI_LENGTH ]; then #FIXME - removed to see how it flys
#    MAX_ANI_LENGTH=$MAX_VAL_FRAMES
#fi
# if submenu selected, translate seconds of submenu length into # of frames
if $ANI_SUB_MENU; then
    ANI_SUBMENU_FRAMES=$(awk_math $FRAME_RATE times $ANI_SUBMENU_LENGTH)
fi

ANI_FRAMES=$MAX_ANI_LENGTH
if $STATIC; then
    FRAMES=1
else
    FRAMES=$ANI_FRAMES
fi
###############################################################################
#                           End of info block                                 #
###############################################################################

###############################################################################
#                       work on the clip title images                         #
###############################################################################
# extract images from the provided background video
if ! $NO_THUMBS; then
    echo
    echo "Creating $FRAMES images from each video for the main menu"
    if [ "$SC_FRAMESTYLE" = "glass" ]; then
        D=2
        VOUT="png:z=7"
        FRAME_SIZE=$THUMB_SIZE
        for ((i=0; i<=NUM_FILES; i++)) ; do
            echo "Using mplayer to get framed images from "${IN_FILES[i]}""
            OUT=$WORK_DIR/pics/$i
            echo "Working on "${IN_FILES[i]}""
            MPLAYER_SEEK_VAL=${SEEK_VAL[i]}
            get_framed_pics "${IN_FILES[i]}"   >> "$LOG_FILE" 2>&1
            echo
            for ((p=1; p<=$FRAMES; p++)); do
                mv  "$WORK_DIR"/$(printf "%08d%s" $p .png) \
            $WORK_DIR/pics/$i/$(printf "%06d%s" $p .png) 2>/dev/null
            done
        done
    else
        for ((i=0; i<=NUM_FILES; i++)) ; do
            echo "Working on "${IN_FILES[i]}""
            TRANSCODE_CMD2=(nice transcode --print_status 10 \
            --write_pid /tmp/tcode.pid -q 1 -i "${IN_FILES[i]}" \
            -c ${SEEK_FRAMES[i]}-$((${SEEK_FRAMES[i]} + $FRAMES)) ${NAVSEEK[i]} \
            -o "$WORK_DIR/pics/$i/" -f $FRAME_RATE  -Z $THUMB_SIZE $EXPORT)

                    function run_transcode()
                    {
                        "${TRANSCODE_CMD2[@]}" >> "$LOG_FILE"  2>&1
                        sleep 1
                    }
                    run_transcode &
                    sleep 1 # short sleep to allow 1st jpg to appear
                    TRANSCODE_PID=$(</tmp/tcode.pid)
                    check_stall &
                    if [[ -n "$TRANSCODE_PID" ]]; then
                        while ps -p $TRANSCODE_PID >/dev/null; do
                            sleep .5 # spinner interval
                        spin "Seeking in video and creating images: $(find $WORK_DIR/pics/$i \
                    -maxdepth 1 -name \*.$IMG_FMT|sort|awk -F / '{ field = $NF }; END{ print field }')"
                        done
                        echo
                        echo "Created $(find $WORK_DIR/pics/$i -maxdepth 1 -name \*.$IMG_FMT|wc -l) images of $FRAMES"
                        #cleanlog 1
                    else
                        #cleanlog 1
                        runtime_error "Problem creating images from the video."
                        exit 1
                    fi
                    unset TRANSCODE_CMD2 run_transcode
        done
    fi
fi
# create the pics for background image
    if [ -z "$BG_PIC" ]; then
        echo
        echo "Creating a black background"
        BG_PIC="$WORK_DIR/pics/template.jpg"
        convert  -size $VIDSIZE xc:"#161514" "$BG_PIC"
        convert  -size $VIDSIZE xc:"#161514" "$WORK_DIR/submenu_template.jpg"
    else
        convert -resize $VIDSIZE! "$BG_PIC" "$WORK_DIR/pics/template.jpg"
        convert -size $VIDSIZE xc:"#161514" "$WORK_DIR/submenu_template.jpg"
    fi

echo
# chapters and submenu xml stuff

for ((s=0; s<=NUM_FILES; s++)); do
    # make appropriate chapter lengths for each video
    # get chapter lengths by dividing by $CHAPTERS, then getting running totals
    CHAPT_INTERVALS=( ${CHAPT_INTERVALS[@]} "$(awk_math ${VID_LEN[s]} by ${CHAPTERS[s]} float)" )
    # <TODO if GROUPING:  for making chapter thumbs for the group 
    # feed group chapter points to transcode in a loop to transcode as usual, but output
    # to different subdirs.  Then rename according to framenumber, moving all to the same subdir
    # then follow same procedure as usual in moving into chapter subdirs for final montages
    # /TODO>
    # and format in HH:MM:SS
    L=( ${L[@]} $(for ((i=1; i<=${CHAPTERS[s]}; i++)) ; do echo "${CHAPT_INTERVALS[s]}";done) )
    chapt_intervals=$(running_total <<< ${L[@]})
    chapters="$(for c in $chapt_intervals; do echo $(format_seconds $c); done)"
    chapters="00:00:00.000 $chapters"
    if [ ${CHAPTERS[s]} = 1 ]; then chapters="00:00:00.000"; fi
    CHAPTS=$(for i in $chapters; do echo -n $i,;done)
    CHAPT_ARRAY[s]="${CHAPTS%?}" # %? to remove trailing ','
    unset L cmd
    if $SUB_MENU; then
        echo
        echo "Creating the highlight and selection PNGs for submenu $((s + 1))"
        C=$((${CHAPTERS[s]} - 1))
        MENU_BUTTON_SIZE="${GEO_ARRAY[C]}"
        get_button_geo
(
cat  <<EOF
rectangle 2,2 $GEO
EOF
)  > $WORK_DIR/draw_file${s}

        convert -size "${GEO_ARRAY[C]}+5+5" xc:none -fill none \
        +antialias -stroke "$SELECT_COLOUR" -strokewidth 4 -draw @draw_file${s} \
        -colors 3 "$WORK_DIR/Submenu${s}_Selectx1.png"
        convert -size "${GEO_ARRAY[C]}+5+5" xc:none -fill none \
        +antialias -stroke "$HIGHLIGHT_COLOUR" -strokewidth 4 -draw @draw_file${s} \
        -colors 3 "$WORK_DIR/Submenu${s}_Highlightx1.png"
        for button in Select Highlight; do
            montage -background none \
            $(for ((i=0; i<=C; i++)); do
            echo $WORK_DIR/Submenu${s}_${button}x1.png;done) \
            -tile ${TILE_ARRAY[C]} \
            -geometry ${GEO_ARRAY[C]}+5+5 \
            -bordercolor none -mattecolor transparent miff:- |

            convert  -colors 3 -size $VIDSIZE xc:none  - \
            -gravity north -geometry +0+45  \
            -composite  $WORK_DIR/Submenu${s}_${button}.png
        done
        # make submenu spumux.xml
(
    cat <<EOF
<subpictures>
   <stream>
     <spu force="yes" start="00:00:00.0"
          highlight="$WORK_DIR/Submenu${s}_Highlight.png"
          select="$WORK_DIR/Submenu${s}_Select.png"
          autooutline="infer"
          autoorder="rows"/>
   </stream>
 </subpictures>
EOF
) > "$WORK_DIR/submenu$((s + 1))_spumux.xml"
    fi
done
# debug chapters
echo
for ((i=0; i<=NUM_FILES; i++)); do
    echo -e "Chapters for "${IN_FILES[i]}" are: \n"${CHAPT_ARRAY[i]}"\n"
done
if [[ "$BUTTON_STYLE" = "text" ]]; then
    if $TEXTMENU; then
        (( THUMB_FONTSIZE < 26 )) &&  OUTLINEWIDTH="\"10\"" || OUTLINEWIDTH="\"12\""
    else
        OUTLINEWIDTH="\"14\""
    fi
else
    OUTLINEWIDTH="\"6\""
fi

(
    cat <<EOF
<subpictures>
   <stream>
     <spu force="yes" start="$START"$END
          highlight="$WORK_DIR/Highlight.png"
          select="$WORK_DIR/Select.png"
          autooutline="infer"
          outlinewidth=$OUTLINEWIDTH
          autoorder="$AUTOORDER"/>
   </stream>
 </subpictures>
EOF
)  > "$SPUMUX_XML"

if $SUB_MENU; then
    JUMP=menu
    POST="        <post> jump cell 1; </post>"
    if $ANI_SUB_MENU; then
        PAUSE=" pause=\"$PAUSE_TIME\""
    else
        PAUSE=" pause=\"inf\""
        unset POST
    fi
else
    JUMP=title
fi
if [ "$TARGET" = "dvd" ]; then
# make dvdauthor.xml
(
    cat <<EOF
<?xml version="1.0" encoding="utf-8"?>
<dvdauthor dest="$OUT_DIR" jumppad="0">
  <vmgm>
    <menus>
      <pgc>
        $INTRO
        <post>jump titleset 1 menu;</post>
      </pgc>
    </menus>
  </vmgm>
  <titleset>
    <menus>
      $MENU_VIDEO_TAG
      <pgc>
$(for ((i=1; i<=$V_TOTAL; i++)); do
    if $SUB_MENU; then
        JUMP_INC=$((i + 1))
    else
        JUMP_INC=$i
    fi
    echo -e "        <button name=\"$i\">jump $JUMP $JUMP_INC;</button>"
done)
$(if $PLAYALL; then
    echo -e "        <button name=\"$((V_TOTAL + 1))\">g4=1; jump title 1 chapter 1;</button>"
fi)
        <vob file="$MENU_FILE" pause="$VMGM_PAUSE_TIME"/>
$MAIN_PRE
$MAIN_POST
      </pgc>
$(if $SUB_MENU; then
    echo -ne "      <pgc>\n"
        for ((Y=1; Y<=$V_TOTAL; Y++)); do
            for ((g=1; g<="${CHAPTERS[Y-1]}"; g++)); do
                echo -e "        <button name=\"$g\">jump title $Y chapter $g;</button>"
            done
            echo -e "        <vob file=\"$WORK_DIR/Menu$Y.mpg\"$PAUSE/>"
echo "$POST"
            echo "      </pgc>"
            echo "      <pgc>"
        done | sed '$d'
fi)
    </menus>
    <titles>
      $TITLES_VIDEO_TAG
$(if $SUBTITLES; then
    for ((s=0; s<${#SUBS_ARRAY[@]}; s++)); do
        echo -e "      <subpicture lang=\"${SUBS_ARRAY[s]}\"/>"
    done
fi)
$(for ((i=0; i<${#IN_FILES[@]}; i++)); do
    unset j
    echo -e "      <pgc>"
    if $AUDIOLANG; then
        echo "${VOB_PRE[i]}"
    fi
    if [[ -n ${GROUP[i]} ]]; then
        get_group_chapters $i format
        if ((${CHAPTERS[i]} == 0)); then
            echo -e "        <vob file=\"$REAL_WORK_DIR/$i.mpg\"/>"
            for mpg in $WORK_DIR/group-$((i+1))-*; do
                echo -e "        <vob file=\"$mpg\"/>"
            done
        else
            echo -e "        <vob file=\"$REAL_WORK_DIR/$((i+1)).mpg\" $chpts0/>"
            for mpg in $WORK_DIR/group-$((i+1))-*; do
                echo -e "        <vob file=\"$mpg\" ${chpts[++j]}/>"
            done
        fi
    else
        echo -ne "        <vob file=\"$REAL_WORK_DIR/$((i+1)).mpg\""
        echo -e  " chapters=\""${CHAPT_ARRAY[i]}"\"/>"
    fi
    if $CHAIN_VIDEOS; then
        if [ "${POST_PLAY[i]}" = "chain" ]; then
            (( i < NUM_FILES )) && CHAIN_PP="jump title $((i + 2)) chapter 1"
            (( i == NUM_FILES )) && CHAIN_PP="jump title 1 chapter 1"
        else
            CHAIN_PP="call vmgm menu 1"
        fi
        if $PLAYALL; then
            if [ $i -lt $NUM_FILES ]; then
                echo -e "        <post>if (g4==1) jump title $((i+2)) chapter 1; $CHAIN_PP;</post>"
            else
                echo -e "        <post>call vmgm menu 1;</post>"
            fi
        else
            echo -e "        <post>$CHAIN_PP;</post>"
        fi
    else
        if $PLAYALL; then
            if [ $i -lt $NUM_FILES ]; then
                echo -e "        <post>if (g4==1) jump title $((i+2)) chapter 1; call vmgm menu 1;</post>"
            else
                echo -e "        <post>call vmgm menu 1;</post>"
            fi
        else
            echo -e "        <post>call vmgm menu 1;</post>"
        fi
    fi
    echo -e "      </pgc>"
done)
    </titles>
  </titleset>
</dvdauthor>
EOF
) |sed '/^ *$/d' >> "$DVDAUTHOR_XML"
fi


##############################################################################
#                            Animenu stuff                                   #
##############################################################################

# do submenu 1st for debug purposes
if $SUB_MENU; then
    yecho
    yecho "Building submenus"
    yecho
    yecho "Creating images for each chapter"
    if [ -z "$SM_TITLES" ]; then
        if $MULTILINE_TITLE; then
            for i in ${!TITLES[@]}; do
                SM_TITLES[i]="${TITLES[i]//\\n/ }"
            done
        else
            SM_TITLES=("${TITLES[@]}")
        fi
    fi
    for ((i=0; i<${#IN_FILES[@]}; i++)); do
        C=$((${CHAPTERS[i]} - 1))
        yecho "Creating a transparent title PNG"
        convert -size 620x300 xc:none -font "$MENU_FONT" \
        -pointsize $MENU_FONTSIZE \
        -fill "$SM_TITLE_COLOUR" -draw "gravity center text 2,2 \"${SM_TITLES[i]}\"" \
        -stroke "$SUBMENU_STROKE" -strokewidth 1 \
        -fill "$SM_TITLE_COLOUR" -stroke "$SUBMENU_STROKE" \
        -draw "gravity center text 1,1 \"${SM_TITLES[i]}\"" miff:- | \
        convert -trim +repage - -blur 0x0.4 $WORK_DIR/title${i}_txt.png 2>/dev/null

        # which is harmless as they get removed, but needs to be tweaked
        if $ANI_SUB_MENU; then
            JPEG2YUV_OPTS=(-n $ANI_SUBMENU_FRAMES)
            PICS_IN=($WORK_DIR/animenu/%0d.$SM_IMG_FMT)
            PICS_OUT=($WORK_DIR/animenu/)
            CUT_TIME=340
            JPEG_DIR="$WORK_DIR/animenu"
            SLEEP=1
            TOTAL_JPEGS=$((340 * ${CHAPTERS[i]}))

        else  # not animated submenu
            if [[ -n "$SUBMENU_AUDIOLENGTH" ]]; then
                SM_LOOPS=$( bc <<< "$SUBMENU_AUDIOLENGTH * $FRAME_RATE")
                SM_LOOPS=${SM_LOOPS%.*}
            else
                SM_LOOPS=60
            fi
            JPEG2YUV_OPTS=(-n 1 -l $SM_LOOPS)
            PICS_IN=($WORK_DIR/${i}-submenu.$SM_IMG_FMT)
            PICS_OUT=($WORK_DIR/submenu/)
            CUT_TIME=1
            JPEG_DIR="$WORK_DIR/submenu"
            SLEEP=.5
            TOTAL_JPEGS=${CHAPTERS[i]}
            PREFIX=${i}-
        fi
        counts=$(awk_math ${CHAPT_INTERVALS[i]} times $FRAME_RATE)
        CUT=( 30 $(running_total <<<  $(for ((a=0; a<${CHAPTERS[i]} ; a++)); \
        do echo -n "$counts ";done)) )
        for ((c=0; c<${#CUT[@]}; c++)); do
            cmd[c]=${CUT[c]}-$(( ${CUT[c]} + CUT_TIME))
        done
        key=$((${#cmd[@]} - 1))
        unset cmd[key]
        # create a nav_seek log with tcdemux if not already present
        NAVSEEK_CMD=(nice tcdemux  $TCDEMUX_MODE -f $FRAME_RATE -W -i "${IN_FILES[i]}")
        if [ ! -e "$WORK_DIR/nav${i}_log" ]; then
            yecho "Running "${NAVSEEK_CMD[@]}" > "$WORK_DIR/nav${i}_log""
            "${NAVSEEK_CMD[@]}"  2>> "$WORK_DIR/tc_pids" > "$WORK_DIR/nav${i}_log"
        fi
        NAVSEEK[i]="--nav_seek "$WORK_DIR/nav${i}_log""
        yecho
        yecho "Creating $TOTAL_JPEGS chapter images for "${IN_FILES[i]}""
        yecho
        for t in "${cmd[@]}"; do
            echo "Running nice transcode --print_status 10 -q 1 -i "${IN_FILES[i]}" \
            ${NAVSEEK[i]} -o $WORK_DIR/submenu/ \
            -f $FRAME_RATE -Z ${GEO_ARRAY[C]},fast -c $t -y $SM_IMG_FMT,null" |
            sed 's/    */ /g'|sed -e "s/^ *//"|tee -a "$LOG_FILE"

            TCODE_CMD=(nice transcode --print_status 10 --write_pid /tmp/tcode.pid \
            -q 1 -i "${IN_FILES[i]}"   ${NAVSEEK[i]} -o "${PICS_OUT[@]}" \
            -f $FRAME_RATE -Z ${GEO_ARRAY[C]},fast -c $t -y $SM_IMG_FMT,null)
            function run_transcode()
            {
                "${TCODE_CMD[@]}" >> "$LOG_FILE"  2>&1
                sleep 1
            }
            run_transcode &
            sleep .5 # short sleep to allow 1st jpg to appear
            TCODE_PID=$(</tmp/tcode.pid)
            check_stall &
            if [[ -n "$TCODE_PID" ]]; then
                while ps -p $TCODE_PID >/dev/null; do
                    sleep $SLEEP # spinner interval
                spin "Seeking in video and creating images: $(find "$JPEG_DIR" \
            -maxdepth 1 -name \*.jpg|sort|awk -F / '{ field = $NF }; END{ print field }')"
                done
                echo

                echo "Created $(find "$JPEG_DIR" -maxdepth 1 -name \*.jpg|wc -l) JPEGS of $TOTAL_JPEGS"
                #cleanlog 1
            else
                #cleanlog 1
                runtime_error "Problem creating images from the video."
                exit 1
            fi
            unset TCODE_CMD cmd run_transcode
            if ! $ANI_SUB_MENU ; then
                echo
                mv $WORK_DIR/submenu/000000.$SM_IMG_FMT \
                $WORK_DIR/submenu/$(printf "%08d%s\n" ${t%-*} .$SM_IMG_FMT)
            elif $ANI_SUB_MENU; then
                echo "renaming images by frame number"
                echo
                u=${t/*-}; v=${t/-*}
                for ((n=0; n<340; n++)); do
                    if [ $v -eq 30 ]; then
                        mv  $WORK_DIR/animenu/$(printf "%06d%s\n" $n .jpg) \
                        $WORK_DIR/animenu/$(printf "%08d%s\n" $((n+30)) .jpg)
                    else
                        mv  $WORK_DIR/animenu/$(printf "%06d%s\n" $n .jpg) \
                        $WORK_DIR/animenu/$(printf "%08d%s\n" $((n+v)) .jpg)
                    fi
                done
            fi
        done
            if $ANI_SUB_MENU ; then
                # move 340 images to each subdir:  $WORK_DIR/animenu/{0,1,2,3,etc}
                echo "moving images into subdirectories"
                for ((a=0; a<${CHAPTERS[i]}; a++)); do
                    # 2>/dev/null to work around perplexing spawned xterm bug
                    pics=( $(find $WORK_DIR/animenu/ -maxdepth 1 -name 00\*.$SM_IMG_FMT | sort 2>/dev/null|head -n 340 2>/dev/null) )
                    echo "${pics[@]}" >> "$WORK_DIR/pics.log"
                    for f in ${pics[@]}; do
                        mv "$f" $WORK_DIR/animenu/$a
                    done
                    unset pics
                done
                for ((a=0; a<${CHAPTERS[i]}; a++)); do
                    find $WORK_DIR/animenu/$a/ -name 00\*.$SM_IMG_FMT |
                    sort| head -n 20|xargs rm -f
                    find $WORK_DIR/animenu/$a/ -name 00\*.$SM_IMG_FMT |
                    sort|tail -n 20|xargs rm -f
                done
                # clean up left over pics in animenu/ dir
#                rm -f $WORK_DIR/animenu/*.$SM_IMG_FMT
            fi

        if $ANI_SUB_MENU; then
            echo
            echo "Making 300 montage images for "${IN_FILES[i]}""

            for ((a=1; a<300; a++)); do
                spin "\rProcessing "$a.$SM_IMG_FMT"  "
                for ((b=0; b<${CHAPTERS[i]}; b++)); do
                    IMGS=( "${IMGS[@]}" $(find $WORK_DIR/animenu/$b \
                    -name \*.$SM_IMG_FMT| sort 2>/dev/null | head -n $a | sed -n -e "$a p") )
                done
                IM_CMD=(montage ${IMGS[@]} -tile ${TILE_ARRAY[C]} \
                -geometry ${GEO_ARRAY[C]}+5+5 -bordercolor '#161514' \
                -mattecolor '#161514' -background '#161514' miff:-)
                IM_CMD2=(convert $WORK_DIR/submenu_template.jpg \
                $WORK_DIR/title${i}_txt.png  -gravity south \
                -geometry +0+55 -composite -  -gravity north -geometry +0+45 \
                -composite $WORK_DIR/animenu/$a.$SM_IMG_FMT)
                "${IM_CMD[@]}" | "${IM_CMD2[@]}"
                unset IMGS
            done

            unset IM_CMD IM_CMD2 d f PIC

        else # not $ANI_SUB_MENU

            yecho
            yecho "Making montage images for "${IN_FILES[i]}""
            # just use $CHAPTERS number of images
            imgs=( $(find $WORK_DIR/submenu -name \*.$SM_IMG_FMT |
            sort| head -n ${CHAPTERS[i]}) )
            # create frames for the chapter thumbs
            for PIC in "${imgs[@]}"; do
            spin "\rProcessing $(awk -F / '{ print $NF }' <<< "$PIC")  "
                convert -background '#141614' -frame 3x3 \
                -bordercolor none -mattecolor "#444744" "$PIC" miff:- |
                convert -resize "${GEO_ARRAY[C]}"! - "$PIC"
            done

            IM_CMD=(montage "${imgs[@]}" -tile ${TILE_ARRAY[C]} -geometry \
            ${GEO_ARRAY[C]}+5+5 -background '#141614' miff:-)
            IM_CMD2=(convert $WORK_DIR/submenu_template.jpg \
            $WORK_DIR/title${i}_txt.png  -gravity south -geometry +0+55 \
            -composite - -gravity north -geometry +0+45 -composite \
            $WORK_DIR/${i}-submenu.$SM_IMG_FMT)
            "${IM_CMD[@]}" | "${IM_CMD2[@]}"
        fi

        yecho
        yecho "Converting chapter montages of "${IN_FILES[i]}" to m2v video format"
        IMG_STREAM_CMD1=(jpeg2yuv -v 0 -f $FRAME_RATE -I p \
        "${JPEG2YUV_OPTS[@]}" -L 1 -b 1  -j "${PICS_IN[@]}")
        ENC_CMD1=(ffmpeg   -f yuv4mpegpipe -i - -r $FRAME_RATE -s $VIDSIZE \
        -tvstd $TV_STANDARD $FFMPEG_OPTS -y "$WORK_DIR/menu$i.m2v")
        echo "Running "${IMG_STREAM_CMD1[@]}" | "${ENC_CMD1[@]}""|format_output | tee -a "$LOG_FILE" 2>&1
        if "${IMG_STREAM_CMD1[@]}" | "${ENC_CMD1[@]}" >> "$LOG_FILE.tmp" 2>&1; then
            cleanlog 3
        else
            cleanlog 3
            runtime_error
        fi

        # check if m2v was created ok before proceeding
        if mencoder -quiet -oac pcm -ovc copy -frames 0 \
        "$WORK_DIR/menu$i.m2v" -o /dev/null &>/dev/null; then
            :
        else
            echo
            runtime_error  \
            "The submenu video (m2v) does not appear to have been created"
        fi
        # clean out submenu dirs of images
        echo "Cleaning up leftover pics in $REAL_WORK_DIR/animenu"
        rm -fv $WORK_DIR/submenu/*
        find $WORK_DIR/animenu/ -maxdepth 1 -type f -exec rm -f {} \;
        if $ANI_SUB_MENU; then
            find $WORK_DIR/animenu/[0-9]/ -type f -exec rm -f {} \;
        fi
    done
    unset IMG_STREAM_CMD1 ENC_CMD1 JPEG2YUV_OPTS
    for ((s=0; s<=NUM_FILES; s++)); do
        # create audio background for either animated or plain submenus
        yecho
        yecho "Creating an audio background"
        yecho "Working on submenu audio for "${IN_FILES[s]}""
        if $SUBMENU_AUDIO; then # user supplied audio file for ths video
            if ! $ANI_SUB_MENU ; then  # if static, see if length option given
                [[ -n "$SUBMENU_AUDIOLENGTH" ]] && TIME=$SUBMENU_AUDIOLENGTH
                if [[ -n "$SM_AUDIO_FILE" ]]; then # one audio file for all menus
                    TIME_TMP=$(ffmpeg -i "$SM_AUDIO_FILE" 2>&1|
                    awk '/Duration/ {print $2}')
                    TIME_TMP=${TIME_TMP/,/}
                else # audio will be different for each menu
                    TIME_TMP=$(ffmpeg -i "${SM_AUDIO[s]}" 2>&1|
                    awk '/Duration/ {print $2}')
                    TIME_TMP=${TIME_TMP/,/}
                fi
            else # if animated, get time from video instead of the audio file
                TIME_TMP=$(vid_length "$WORK_DIR/menu$s.m2v")
            fi
            # if length option is supplied, we use that, else use $TIME_TMP
            TIME=${TIME:-$TIME_TMP}
            # silence only need be the length of the static menu
            if [ "${SM_AUDIO[s]}" = "none" ]; then # user asked for silence
                TIME=$(vid_length "$WORK_DIR/menu$s.m2v")
                BGAUDIO_CMD=(ffmpeg -f s16le -i /dev/zero -t $TIME \
                $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT)
            elif [[ -n "$SM_AUDIO_FILE" ]]; then # user supplied "1" audio file
                COPY_AC3=(cp -v $WORK_DIR/submenu.$AUDIO_EXT \
                $WORK_DIR/menu$s.$AUDIO_EXT)
                BGAUDIO_CMD=(ffmpeg -i "$SM_AUDIO_FILE" -t $TIME -ar 48000 \
                -ac 2 -acodec pcm_s16le -y $WORK_DIR/submenu.wav)
            else # SM_AUDIO[s] is an audio file we will process it
                # make seperate wavs for each supplied audio bg for each submenu
                BGAUDIO_CMD=(ffmpeg -i "${SM_AUDIO[s]}" -t $TIME -ar 48000 \
                -ac 2 -acodec pcm_s16le -y $WORK_DIR/menu$s.wav)
                BGAUDIO_CMD2=(ffmpeg -i $WORK_DIR/menu$s.wav \
                $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT)
            fi
        else # no supplied audio for submenu so create silence
            TIME=$(vid_length "$WORK_DIR/menu$s.m2v")
            BGAUDIO_CMD=(ffmpeg -f s16le -i /dev/zero -t $TIME \
            $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT)
        fi
        if [ ! -e $WORK_DIR/submenu.wav ]; then # only run if no wav
            yecho "Running "${BGAUDIO_CMD[@]}"" >> "$LOG_FILE.tmp" 2>&1
            cleanlog 1
            if "${BGAUDIO_CMD[@]}" >> "$LOG_FILE.tmp" 2>&1; then #run command
                cleanlog 3
            else
                cleanlog 3
                runtime_error
            fi
        fi
        # convert to DVD/SVCD format as long as not "none" or single audio file
        if $SUBMENU_AUDIO && [[ ! "${SM_AUDIO[s]}" = "none" && -z "$SM_AUDIO_FILE" ]]; then
            if $SM_AUDIO_FADE; then
                TIME=$(ffmpeg -i "$WORK_DIR/menu$s.wav" 2>&1|awk '/Duration/ {print $2}')
                TIME=${TIME/,/}
                echo -e "Running:
                sox $WORK_DIR/menu$s.wav \
                $WORK_DIR/menu$s-processed.wav fade t $SM_FADE $TIME $SM_FADE" |
                sed 's/    */ /g'|sed -e "s/^ *//"
                sox -q $WORK_DIR/menu$s.wav \
                $WORK_DIR/menu$s-processed.wav fade t $FADE $TIME $FADE
                rm $WORK_DIR/menu$s.wav
                mv $WORK_DIR/menu$s-processed.wav $WORK_DIR/menu$s.wav
            fi
            echo "Running "${BGAUDIO_CMD2[@]}"" >> "$LOG_FILE.tmp" 2>&1
            cleanlog 1
            if "${BGAUDIO_CMD2[@]}" >> "$LOG_FILE.tmp" 2>&1; then
                cleanlog 3
            else
                cleanlog 3
                runtime_error
            fi
            unset TIME
        fi
        # if "1" audio file, then convert it if it has not been done yet
        if [[ -n "$SM_AUDIO_FILE" && ! -e $WORK_DIR/submenu-processed.wav ]]; then
            if $AUDIO_FADE; then
                TIME=$(ffmpeg -i "$WORK_DIR/submenu.wav" 2>&1|awk '/Duration/ {print $2}')
                TIME=${TIME/,/}
                echo -e "Running:
                sox $WORK_DIR/submenu.wav \
                $WORK_DIR/submenu-processed.wav fade t $SM_FADE $TIME $SM_FADE" |sed 's/    */ /g'

                sox -q $WORK_DIR/submenu.wav \
                $WORK_DIR/submenu-processed.wav fade t $FADE $TIME $FADE
                rm -f $WORK_DIR/submenu.wav
                cp  $WORK_DIR/submenu-processed.wav $WORK_DIR/submenu.wav
            fi
            BGAUDIO_CMD3=(ffmpeg -i $WORK_DIR/submenu.wav \
            $AUDIO_OPTS -y $WORK_DIR/submenu.$AUDIO_EXT)
            if [ -e $WORK_DIR/submenu.$AUDIO_EXT ]; then # if file exists do nothing
                :
            else
                echo "Running "${BGAUDIO_CMD3[@]}"" >> "$LOG_FILE.tmp" 2>&1
                if "${BGAUDIO_CMD3[@]}" >> "$LOG_FILE.tmp" 2>&1; then
                    cleanlog 3
                else
                    cleanlog 3
                    runtime_error
                fi
            fi
        fi
        # copy the final file for each submenu if only 1 supplied
        "${COPY_AC3[@]}"
        yecho
        yecho "Multiplexing video and audio together"
        S=$((s + 1))
        MPLEX_CMD=(mplex -V -f $MPLEX_FORMAT -o $WORK_DIR/menu$S.mpg \
        $WORK_DIR/menu$s.$AUDIO_EXT $WORK_DIR/menu$s.m2v)
        echo "Running: "${MPLEX_CMD[@]}"" >> "$LOG_FILE.tmp"
        cleanlog 1
        if "${MPLEX_CMD[@]}" >> "$LOG_FILE.tmp" 2>&1; then
            cleanlog 1
        else
            cleanlog 1
            runtime_error
        fi
        # remove wav to save space
        rm -fv $WORK_DIR/menu$s.wav
    done
    rm -fv $WORK_DIR/submenu.{wav,$AUDIO_EXT}
    rm -fr $WORK_DIR/animenu/*
fi

##############################################################################
#                      Work on main menu                                     #
##############################################################################
yecho
yecho "Building main menu"
if [[ -n "$BG_VIDEO" ]]; then
    yecho "Getting background video from $BG_VIDEO"
    FFMPEG_CMD="ffmpeg -i \"$BG_VIDEO\" -ss $BG_SEEK -vframes $FRAMES $BG_ASYNC \
    -s $VIDSIZE -sameq \"$WORK_DIR/bg/%d.jpg\""
    yecho "Extracting/resizing background images with the following command:"
    yecho "$FFMPEG_CMD"
    # Filter ffmpeg output
    LOG_FILTER="sed s/\\r/\\r\\n/g"
    # Run command and check for failure
    if ! cmd_exec "$FFMPEG_CMD"; then
        runtime_error "Problem creating images from the background video"
    fi
    # make sure there are enough pics to make a bg video
    IMAGES=( "${IMAGES[@]}" \
    $(find $WORK_DIR/bg -maxdepth 1 -name \*[1-9]\*.jpg|sort) )
    last_pic=${#IMAGES[@]}
    next_pic=$(($last_pic + 1))
    if [ $last_pic -lt $MAX_ANI_LENGTH ]; then
        for ((l=next_pic; l<=MAX_ANI_LENGTH; l++)); do
            cp $WORK_DIR/bg/${last_pic}.jpg $WORK_DIR/bg/$l.jpg
        done
    fi
    unset IMAGES PICS last_pic next_pic
fi
#if [ -n "$SHOWCASE_VIDEO" ] && ! $NO_SC_THUMB; then
if [[ -n "$SHOWCASE_VIDEO" ]] && ! $NO_SC_THUMB; then
    echo "Getting showcase video images from $SHOWCASE_VIDEO"
    if [ "$SC_FRAMESTYLE" = "glass" ]; then
        FIND_FRAMES=$((FRAMES + 1)) # unfortunately mplayer starts at 1 not 0
        D=2
        FRAME_SIZE=$SHOWCASE_SIZE
        VOUT="png:z=7"
        MPLAYER_SEEK_VAL=$SHOWCASE_SEEK_VAL
        get_framed_pics "$SHOWCASE_VIDEO"  >> "$LOG_FILE" 2>&1
        for ((i=1; i<=$FIND_FRAMES; i++)); do
            mv  "$WORK_DIR"/$(printf "%08d%s"  $i .png) \
            "$WORK_DIR"/showcase/$(printf "%06d%s"  $i .png) 2>/dev/null
        done
    elif [ "$SC_FRAMESTYLE" = "none" ]; then
        FIND_FRAMES=$FRAMES # ffmpeg starts at 0
        FFMPEG_CMD=(ffmpeg -i "$SHOWCASE_VIDEO" -ss $SHOWCASE_SEEK_VAL $BG_ASYNC \
        -s $SHOWCASE_SIZE -vframes $FRAMES -an -y "$WORK_DIR/showcase/%06d.png")
        echo -e "\nRunning: "${FFMPEG_CMD[@]}"\n" | fold -bs >> "$LOG_FILE"
        SED_VAR="frame="
        if "${FFMPEG_CMD[@]}" >> "$LOG_FILE.tmp" 2>&1;then
            cleanlog 3
        else
            cleanlog 3
            runtime_error "Problem creating images from the video."
            exit 1
        fi
    fi

    for ((i=0; i<$FRAMES; i++)); do
        SC_PICS=( ${SC_PICS[@]} $(find $WORK_DIR/showcase -maxdepth 1  -name $(printf "%06d%s"  $i .png) ) )
    done
    if [[ "$SC_FRAMESTYLE" = "glass" ]] &&  [[ -z "$ROTATE" && -z "$WAVE" ]]; then
        :
    else
        for pic in "${SC_PICS[@]}"; do
            spin "\rProcessing $(awk -F / '{ print $NF }' <<< "$pic") of $FRAMES  "
            SC_CMD=(convert -resize $SHOWCASE_SIZE! "$pic" -mattecolor gray $SC_FRAME)
            SC_CMD1=(convert "$pic" -background none $ROTATE $WAVE)
            SC_CMD2=(convert -background none $ROTATE $WAVE -)
            SC_CMD3=(convert - -resize $SHOWCASE_SIZE! "$pic")
            # if glass and either wave or rotate
            if [ "$SC_FRAMESTYLE" = "glass" ] && [[ -n "$WAVE" || -n "$ROTATE" ]]; then
                "${SC_CMD1[@]}" miff:- | "${SC_CMD3[@]}"
            # if glass and neither wave or rotate
            elif [ "$SC_FRAMESTYLE" = "glass" ] && [[ -z "$WAVE" && -z "$ROTATE" ]]; then
                :
            else # not glass
                "${SC_CMD[@]}" miff:- | "${SC_CMD2[@]}" miff:- | "${SC_CMD3[@]}"
            fi
        done
    fi
    # make sure showcase video finishes at the time time as other menu items
    IMAGES=( $(find $WORK_DIR/showcase -maxdepth 1 -name 00\*.$IMG_FMT|sort) )
    last_pic=$(( ${#IMAGES[@]} - 1 ))
    next_pic=$(($last_pic + 1))
    if [ $last_pic -lt $MAX_ANI_LENGTH ] && ! $STATIC; then
        for ((l=next_pic; l<=MAX_ANI_LENGTH; l++)); do
            cp $WORK_DIR/showcase/$( printf %06d $last_pic).$IMG_FMT \
            $WORK_DIR/showcase/$(printf %06d $l).$IMG_FMT
        done
    fi

fi
unset IMAGES last_pic next_pic FFMPEG_CMD pic

yecho
if [[ ! "$SC_FRAMESTYLE" = "glass" && ! $NO_THUMBS ]]; then
    if $SHOWCASE; then
        yecho "Processing video images"
    else
        yecho "Adding title to video images and resizing"
    fi
fi
if ! $NO_THUMBS; then
    for ((i=0; i<=NUM_FILES; i++)); do
        if $FEATHER && $THUMBS_3D && [ "$THUMB_SHAPE" != "normal" ]; then
            unset CURVE_ARRAY CURVE_VALUES CURVE_VARS
            CURVE_VARS="5 3 5 1 1"
            . todisc-fade-routine "3 5 5 1 1"
        fi
        PICS=( "${PICS[@]}" \
        $(find $WORK_DIR/pics/$i -maxdepth 1 -name \*[0-9]\*.$IMG_FMT|sort) )
        echo
        yecho "Working on ${#PICS[@]} images from ${IN_FILES[i]}"
        for ((p=0; p<${#PICS[@]}; p++)); do
            unset IM_CMD6
            IM_CMD=(composite -compose CopyOpacity $THUMB_MASK +matte "${PICS[p]}")
            IM_CMD0=(montage -  -geometry +4+4 -compose Copy -background none \
            -fill "$THUMB_TEXT_COLOUR" -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE -title "${TITLES[i]}")
            IM_CMD01=(convert -background '#161514' -frame 3x3 \
            -bordercolor none -mattecolor "#444744" "${PICS[p]}")
            IM_CMD02=(convert "${PICS[p]}" $RAISE)
            IM_CMD03=(composite -compose CopyOpacity $THUMB_MASK +matte -)
            IM_CMD04=(montage - -geometry +4+4 -background '#444744' \
            -mattecolor "#444744" -fill "$THUMB_TEXT_COLOUR" -font "$THUMB_FONT" \
            -pointsize $THUMB_FONTSIZE -title "${TITLES[i]}")
            IM_CMD1=(convert -resize $THUMB_SIZE! -)
            IM_CMD2=(composite -gravity center -compose DstOver $WORK_DIR/feather_mask2.png -)
            IM_CMD3=(montage -geometry +4+4 -background '#444744' \
            -fill "$THUMB_TEXT_COLOUR" -font "$THUMB_FONT" \
            -pointsize $THUMB_FONTSIZE -title "${TITLES[i]}" "${PICS[p]}")
            IM_CMD4=(convert -background none -frame 3x3 \
            -bordercolor "#444744" -)
            IM_CMD4b=(convert -background none -frame 3x3 \
            -bordercolor none -)
            IM_CMD5=(convert -resize $THUMB_SIZE! - "${PICS[p]}")
            IM_CMD6=(convert - -write mpr:img${p} -fx A  +matte \
            -blur 0x$( printf "%.2f" $(awk_math 7 plus .${CURVE_ARRAY[p]/.} float) )  \
            -shade $(awk_math 115 plus ${CURVE_ARRAY[p]} float)x30 -normalize mpr:img${p} \
            -compose Overlay -composite mpr:img${p} -matte -compose Dst_In -composite)
            IM_CMD7=(convert -trim +repage - )
            if $FEATHER &&  [ "$THUMB_SHAPE" != "normal" ] && $THUMBS_3D; then # debug FIXME
                CURVE_UPDATE="with -blur 0x$( printf  "%.2f" $(awk_math 7 plus .${CURVE_ARRAY[p]/.} float) ) \
                -shade $( printf "%.2f" $(awk_math 115 plus ${CURVE_ARRAY[p]} float) )x30"
            fi
            if $FEATHER; then
                spin "\rProcessing $(awk -F / '{ print $NF }' <<< "${PICS[p]}") \
                $(echo $CURVE_UPDATE | format_output) " # debug FIXME
                if $SHOWCASE; then
                    if $THUMBS_3D; then
                        if [ "$THUMB_SHAPE" != "normal" ]; then # normal has $RAISE
                            "${IM_CMD[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
                            "${IM_CMD6[@]}" miff:- |  "${IM_CMD7[@]}" miff:- |
                            "${IM_CMD5[@]}"
                        else # normal thumbshape, with feather and 3D
                            "${IM_CMD02[@]}" miff:- | "${IM_CMD03[@]}" miff:- |
                            "${IM_CMD2[@]}" miff:- |"${IM_CMD7[@]}" miff:- |
                            "${IM_CMD5[@]}"

                        fi
                    else
                        "${IM_CMD[@]}" miff:- | "${IM_CMD2[@]}" miff:- |"${IM_CMD5[@]}"
                    fi
                else # not SHOWCASE
                    if $THUMBS_3D; then
                        if [ "$THUMB_SHAPE" != "normal" ]; then
                            "${IM_CMD[@]}" miff:- | "${IM_CMD6[@]}" miff:- |
                            "${IM_CMD1[@]}" miff:- |"${IM_CMD0[@]}" miff:- |
                            "${IM_CMD1[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
                            "${IM_CMD5[@]}"
                        else
                            "${IM_CMD02[@]}" miff:- | "${IM_CMD0[@]}" miff:- |
                            "${IM_CMD1[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
                            "${IM_CMD5[@]}"
                        fi
                    else # not 3D
                        "${IM_CMD[@]}" miff:- | "${IM_CMD0[@]}" miff:- |
                        "${IM_CMD1[@]}" miff:- |"${IM_CMD2[@]}" miff:- |
                        "${IM_CMD5[@]}"
                    fi
                fi
            else # not FEATHER
                if $SHOWCASE; then # showcase but not feather
                    if [ "$SC_FRAMESTYLE" = "glass" ]; then
                        :
                    else
                        spin "\rProcessing $(awk -F / '{ print $NF }' <<< "${PICS[p]}")  "
                        if $THUMBS_3D; then
                            "${IM_CMD02[@]}" miff:- | "${IM_CMD5[@]}"
                        else
                            "${IM_CMD01[@]}" miff:- | "${IM_CMD5[@]}"
                        fi
                    fi
                else # not showcase or feather
                    spin "\rProcessing $(awk -F / '{ print $NF }' <<< "${PICS[p]}")  "
                    if $THUMBS_3D; then
                        "${IM_CMD02[@]}" miff:- |"${IM_CMD04[@]}" miff:- |
                        "${IM_CMD4b[@]}" miff:- | "${IM_CMD5[@]}"
                    else
                        "${IM_CMD3[@]}" miff:- | "${IM_CMD4[@]}" miff:- |
                        "${IM_CMD5[@]}"
                    fi
                fi
            fi
            if $STATIC; then unset PICS; fi
            unset IM_CMD0 IM_CMD1 IM_CMD2 IM_CMD3 IM_CMD4 IM_CMD5 IM_CMD6
        done
        # make sure all animated thumbs finish at the same time
        if ! $STATIC; then
            IMAGES=( "${IMAGES[@]}" \
            $(find $WORK_DIR/pics/$i -maxdepth 1 -name 00\*.$IMG_FMT|sort) )
            last_pic=$(( ${#IMAGES[@]} - 1 ))
            next_pic=$(($last_pic + 1))
            if [ $last_pic -lt $MAX_ANI_LENGTH ]; then
                for ((l=next_pic; l<=MAX_ANI_LENGTH; l++)); do
                    cp $WORK_DIR/pics/$i/$( printf %06d $last_pic).$IMG_FMT \
                    $WORK_DIR/pics/$i/$(printf %06d $l).$IMG_FMT
                done
            fi
            unset IMAGES last_pic next_pic
        fi
        unset PICS
    done
fi
if ! $MENU_FADE; then
    yecho
    yecho "Making $FRAMES final montages and compositing onto background with title"
    yecho
fi
if $MENU_FADE && ! $STATIC; then
    . todisc-fade-routine
    yecho
    yecho "Creating background fade"
    yecho
    if [ -z "$BG_VIDEO" ]; then
        for ((frame=0; frame<=ANI_MENU_END_FRAME; frame++)); do
            # copy template for fade out beginning and end frames
            cp $WORK_DIR/pics/template.jpg $WORK_DIR/bg/$(($frame + 1)).jpg
        done
    fi
    for ((frame=0; frame<=BACKGROUND_FADE_IN_END_FRAME; frame++)); do
        D=`get_bg_opacity`
        composite -dissolve $D $WORK_DIR/bg/$(($frame + 1)).jpg $WORK_DIR/black.jpg \
        $WORK_DIR/bg/$(($frame + 1)).jpg
    done
    yecho
    yecho "Making $FRAMES final montages and compositing onto background with title"
    yecho
    for ((frame=BACKGROUND_FADE_OUT_START_FRAME; frame<BACKGROUND_FADE_OUT_END_FRAME; frame++)); do
        D=`get_bg_opacity`
        composite -dissolve $D $WORK_DIR/bg/$(($frame + 1)).jpg $WORK_DIR/black.jpg \
        $WORK_DIR/bg/$(($frame + 1)).jpg
    done
    for ((frame=0; frame<ANI_MENU_END_FRAME; frame++)); do
        # set dissolve vars from todisc-fade-routine functions
        BC=$(get_title_opacity)
        B=$(awk -F ':' '{print $1'}<<<$BC)
        C=$(awk -F ':' '{print $2'}<<<$BC)
        S=$(get_thumb_opacity)

        spin  "\rProcessing "$(($frame + 1)).jpg"  "

        for ((cnt=0; cnt<=NUM_FILES; cnt++)); do
            ANI_PICS=( "${ANI_PICS[@]}" $(find $WORK_DIR/pics/$cnt  -name $(printf "%06d%s"  $((frame + 1)) .$IMG_FMT) ) )
        done
        if $SHOWCASE && ! $NO_THUMBS; then
            for ((i=0; i<${#ANI_PICS[@]}; i++)); do
                sc_cmd=( ${sc_cmd[@]} ${SHOWCASE_THUMB_PAGES[i]} "${ANI_PICS[i]}")
            done
            if ! $NO_SC_THUMB; then
                SC_VIDEO_CMD="$SC_IMG_PAGE \
                "$WORK_DIR"/showcase/$(printf "%06d%s"  $(($frame + 1)) .png)"
            else
                unset SC_VIDEO_CMD
            fi
        fi
        $NO_THUMBS && unset sc_cmd
        ! $NO_THUMBS && MOSAIC="-mosaic"
        BG_PIC=$(find $WORK_DIR/bg -name $(($frame + 1)).jpg)
        # create the montage from the images in each video dir
        MONTAGE_CMD=(convert  -size $VIDSIZE -background none \
        ${sc_cmd[@]} $SC_IMG_CMD $MOSAIC)
        MONTAGE_CMD0=(convert  -size $VIDSIZE "$WORK_DIR/pics/template.png" \
        ${sc_cmd[@]} $SC_VIDEO_CMD $MOSAIC $WORK_DIR/animenu/$(($frame + 1)).jpg)
        MONTAGE_CMD01=(convert  -size $VIDSIZE xc:none -background none \
        ${sc_cmd[@]} $SC_VIDEO_CMD $MOSAIC)
        MONTAGE_CMD02=(convert -size $VIDSIZE -background none \
        - ${sc_thumb_title_cmd[@]} -mosaic)
        MONTAGE_CMD03=(convert -size $VIDSIZE -background none \
        ${sc_thumb_title_cmd[@]} -mosaic)
        MONTAGE_CMD1=(montage "${ANI_PICS[@]}" -tile ${TILE_ARRAY[NUM_FILES]} \
        -geometry ${GEO_ARRAY[NUM_FILES]}+10+4 -background none)
        #  dissolve the finished montages onto the background
        MONTAGE_CMD2=(composite -dissolve $S -gravity $BUTTON_GRAVITY \
        -geometry +${XGEO}+${YGEO} - $WORK_DIR/bg/$(($frame + 1)).jpg -background none)
        MONTAGE_CMD2b=(composite -size $VIDSIZE -background none \
        -gravity NorthWest  -dissolve $S - $WORK_DIR/bg/$(($frame + 1)).jpg \
        -background none  $WORK_DIR/animenu/$(($frame + 1)).jpg)
        MONTAGE_CMD2c=(composite -size $VIDSIZE -background none \
        -gravity NorthWest  -dissolve $S - $WORK_DIR/bg/$(($frame + 1)).jpg \
        -background none)
        # if MIST is called for, this dissolves the mist onto the background
        MONTAGE_CMD3=(composite -dissolve $B -gravity $TITLE_GRAVITY -geometry +0+${mist_pos} \
        $WORK_DIR/white.png -)
        # finally, we dissolve the title onto the MIST (or plain background)
        MONTAGE_CMD4=(composite -dissolve $C -gravity $TITLE_GRAVITY -geometry +0+${title_pos} \
        $WORK_DIR/title_txt.png - -background none $WORK_DIR/animenu/$(($frame + 1)).jpg)
        if $PLAYALL; then
            MONTAGE_CMD5=(composite -dissolve $S -gravity SouthEast -geometry +55+55 \
            $WORK_DIR/PLAYALL.png - -background none)
        else
            MONTAGE_CMD5=(convert -)
        fi
        $NO_THUMBS && unset MONTAGE_CMD
        $NO_THUMBS && MONTAGE_CMD=( "${MONTAGE_CMD03[@]}" )
        # pipe all of above commands if using MIST
        if $MIST; then
            if $SHOWCASE; then
                if [[ -n "$SHOWCASE_VIDEO" ]]; then
                    "${MONTAGE_CMD01[@]}" miff:- | "${MONTAGE_CMD02[@]}" miff:- |
                    "${MONTAGE_CMD2c[@]}" miff:- | "${MONTAGE_CMD3[@]}" miff:- |
                    "${MONTAGE_CMD5[@]}" miff:- | "${MONTAGE_CMD4[@]}"
                else # not SHOWCASE_VIDEO (SHOWCASE_IMG)
                    "${MONTAGE_CMD[@]}" miff:- | "${MONTAGE_CMD02[@]}" miff:- |
                    "${MONTAGE_CMD2c[@]}" miff:- |  "${MONTAGE_CMD5[@]}" miff:- |
                    "${MONTAGE_CMD3[@]}" miff:- | "${MONTAGE_CMD4[@]}"
                fi
            else # not SHOWCASE
                "${MONTAGE_CMD1[@]}" miff:- | "${MONTAGE_CMD2[@]}" miff:- |
                "${MONTAGE_CMD3[@]}" miff:- | "${MONTAGE_CMD5[@]}" miff:- |
                "${MONTAGE_CMD4[@]}"
            fi
        else  # no mist: pipe all commands but the mist command
            if $SHOWCASE; then
                if [[ -n "$SHOWCASE_VIDEO" ]]; then
                    "${MONTAGE_CMD01[@]}" miff:- | "${MONTAGE_CMD02[@]}" miff:- |
                    "${MONTAGE_CMD2c[@]}" miff:- | "${MONTAGE_CMD5[@]}" miff:- |
                    "${MONTAGE_CMD4[@]}"
                else
                    "${MONTAGE_CMD[@]}" miff:- | "${MONTAGE_CMD02[@]}" miff:- |
                    "${MONTAGE_CMD2c[@]}" miff:- |  "${MONTAGE_CMD5[@]}" miff:- |
                    "${MONTAGE_CMD4[@]}"
                fi
            else
                "${MONTAGE_CMD1[@]}" miff:- | "${MONTAGE_CMD2[@]}" miff:- |
                "${MONTAGE_CMD5[@]}" miff:- | "${MONTAGE_CMD4[@]}"
            fi
        fi
        unset ANI_PICS sc_cmd
    done
    # copy a few black frames to make sure end frame is really "black"
    for ((i=FRAMES; i<FRAMES+18; i++)); do
        cp $WORK_DIR/black.jpg $WORK_DIR/animenu/$i.jpg
    done
else # Do not do menu fade
    if $TRANSPARENT; then # non transparent -showcase-* uses this block too
        for (( count=1; count<=$FRAMES; count++)); do
            spin "\rProcessing "$count.jpg"  "
            for ((cnt=0; cnt<=NUM_FILES; cnt++)); do
                ANI_PICS=( "${ANI_PICS[@]}" $(find $WORK_DIR/pics/$cnt  \
                -name $(printf "%06d%s"  $((count - 1)) .$IMG_FMT) ) )
            done
            for ((f=0; f<${#ANI_PICS[@]}; f++)); do
                sc_cmd=( ${sc_cmd[@]} ${SHOWCASE_THUMB_PAGES[f]} "${ANI_PICS[f]}")
            done
            SC_VIDEO_CMD="$SC_IMG_PAGE \
            "$WORK_DIR"/showcase/$(printf "%06d%s"  $count .png)"
            $STATIC && SC_VIDEO_CMD="$SC_IMG_PAGE \
            "$WORK_DIR"/showcase_img.png" #FIXME
            $NO_THUMBS && unset sc_cmd SC_IMG_CMD SC_VIDEO_CMD #FIXME

            IM_CMD0=(convert  -size $VIDSIZE "$WORK_DIR/pics/template.png" \
            ${sc_cmd[@]} $SC_IMG_CMD -mosaic)
            IM_CMD01=(convert  -size $VIDSIZE xc:none -background none \
            ${sc_cmd[@]} $SC_VIDEO_CMD -mosaic)
            # dissolve piped images onto bgimage
            IM_CMD02=(composite \
            -gravity NorthWest  -dissolve $OPACITY - $WORK_DIR/pics/template.png)
            # dissolve piped images onto bgvideo
            IM_CMD03=(composite -size $VIDSIZE -background none \
            -gravity NorthWest  -dissolve $OPACITY - $WORK_DIR/bg/$count.jpg \
            -background none)
            # dissolve titles onto bgvideo
            IM_CMD04=(convert -size $VIDSIZE -background none \
            - ${sc_thumb_title_cmd[@]} -mosaic)
            IM_CMD05=(convert  -size $VIDSIZE xc:none -background none \
            ${sc_cmd[@]} $SC_IMG_PAGE -mosaic)
            IM_CMD1=(montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[NUM_FILES]} \
            -geometry ${GEO_ARRAY[NUM_FILES]}+10+4 -background none miff:-)
            IM_CMD2=(composite -dissolve $OPACITY \
            -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} - \
            $WORK_DIR/pics/template.jpg -background none miff:-)
            IM_CMD2b=(composite -dissolve $OPACITY \
            -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} - \
            $WORK_DIR/bg/$count.jpg -background none miff:-)
            IM_CMD3=(composite -dissolve 30 -gravity $TITLE_GRAVITY -geometry +0+${mist_pos} \
            $WORK_DIR/white.png - miff:-)
            IM_CMD4=(convert - $WORK_DIR/title_txt.png  \
            -gravity $TITLE_GRAVITY -geometry +0+${title_pos} -composite $ADD_PLAYALL \
            $WORK_DIR/animenu/$count.jpg )
            if $MIST; then
                if $SHOWCASE && [[ -n "$SHOWCASE_VIDEO" ]]; then # showcase, mist, showcase-video
                    if test -n "$BG_VIDEO"; then # showcase, mist, showcase-video, bgvideo
                        "${IM_CMD01[@]}" miff:- | "${IM_CMD04[@]}" miff:- |
                       "${IM_CMD03[@]}" miff:- |  "${IM_CMD3[@]}" |  "${IM_CMD4[@]}"
                    else # showcase, mist showcase-video, not bgvideo
                        "${IM_CMD01[@]}" miff:- | "${IM_CMD02[@]}" "$WORK_DIR/animenu/$count.jpg"
                    fi
                elif $SHOWCASE && [[ -n "$SHOWCASE_IMG" ]]; then # showcase, mist, showcase-image
                    if test -n "$BG_VIDEO"; then # showcase, mist, showcase-image with bgvideo
                        "${IM_CMD05[@]}" miff:- | "${IM_CMD04[@]}" miff:- |
                        "${IM_CMD03[@]}" miff:- |"${IM_CMD3[@]}" |  "${IM_CMD4[@]}"
                    else # showcase, mist, showcase-image, not bgvideo
                        "${IM_CMD0[@]}" $WORK_DIR/animenu/$count.jpg
                    fi
                elif ! $SHOWCASE; then
                    if test -n "$BG_VIDEO"; then
                        "${IM_CMD1[@]}" | "${IM_CMD2b[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
                    else
                    "${IM_CMD1[@]}" | "${IM_CMD2[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
                    fi
                fi
            else # not mist
                if $SHOWCASE && [[ -n "$SHOWCASE_VIDEO" ]]; then # showcase, no mist, showcase-video
                    if test -n "$BG_VIDEO"; then # showcase, no mist, showcase-video, bgvideo
                        "${IM_CMD01[@]}" miff:- | "${IM_CMD04[@]}" miff:- |
                        "${IM_CMD03[@]}" miff:- | "${IM_CMD4[@]}"
                    else # showcase, no mist, showcase-video, not bgvideo
                        "${IM_CMD01[@]}" miff:- | "${IM_CMD04[@]}" miff:- |
                        "${IM_CMD02[@]}" miff:- | "${IM_CMD4[@]}"
                    fi
                elif $SHOWCASE && [[ -n "$SHOWCASE_IMG" ]]; then # showcase, no mist, showcase-image
                    if test -n "$BG_VIDEO"; then # showcase, no mist, showcase-image with bgvideo
                        "${IM_CMD05[@]}" miff:- | "${IM_CMD04[@]}" miff:- |
                        "${IM_CMD03[@]}" miff:- | "${IM_CMD4[@]}"
                    else # showcase, no mist, showcase-image, no bgvideo
                        "${IM_CMD0[@]}" $WORK_DIR/animenu/$count.jpg
                    fi
                elif ! $SHOWCASE; then
                    if test -n "$BG_VIDEO"; then
                        "${IM_CMD1[@]}" | "${IM_CMD2b[@]}" | "${IM_CMD4[@]}"
                    else
                        "${IM_CMD1[@]}" | "${IM_CMD2[@]}" | "${IM_CMD4[@]}"
                    fi
                fi
            fi
            rm -f ${ANI_PICS[@]}
            unset ANI_PICS sc_cmd
        done
    else # Not transparent (non transparent showcase uses transparent block ^^)
         C=$((${CHAPTERS[s]} - 1))
        for (( count=1; count <=FRAMES; count++)); do
            spin -ne "\rProcessing "$count.jpg"  "
            for ((cnt=0; cnt<=NUM_FILES; cnt++)); do
                ANI_PICS=( "${ANI_PICS[@]}" \
                $(find $WORK_DIR/pics/$cnt  -name $(printf "%06d%s"  $((count - 1))  .$IMG_FMT) ) )
            done
            # make final montages and composite onto grey background with title
            IM_CMD0=(montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[NUM_FILES]} \
            -geometry ${GEO_ARRAY[NUM_FILES]}+10+4 -background none miff:-)
            IM_CMD1=(convert $WORK_DIR/pics/template.jpg \
            -  -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} -composite miff:-)
            IM_CMD2=(convert $WORK_DIR/bg/$count.jpg \
            -  -gravity $BUTTON_GRAVITY -geometry +${XGEO}+${YGEO} -composite miff:-)
            IM_CMD3=(composite -dissolve 30 -gravity $TITLE_GRAVITY -geometry +0+${mist_pos} \
            $WORK_DIR/white.png - miff:-)
            IM_CMD4=(convert - $WORK_DIR/title_txt.png  \
            -gravity $TITLE_GRAVITY -geometry +0+${title_pos} -composite $ADD_PLAYALL \
            $WORK_DIR/animenu/$count.jpg )

            if $STATIC; then
                if $MIST; then
                    "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
                else  # static and no MIST
                    echo "running "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD4[@]}""
                    "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD4[@]}" >> "$LOG_FILE"
                fi
            else # animated
                if test -n "$BG_VIDEO"; then
                    if $MIST; then
                        "${IM_CMD0[@]}" | "${IM_CMD2[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
                    else # no mist
                        "${IM_CMD0[@]}" | "${IM_CMD2[@]}" | "${IM_CMD4[@]}"
                    fi
                else # no bg video
                    if $MIST; then
                        "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
                    else # no mist
                        "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD4[@]}"
                    fi
                fi
            fi
            unset ANI_PICS
        done
    fi
fi
echo
echo "Converting images to video stream and encoding to DVD-compliant format"
# convert images to video stream and encode to dvd compliant m2v
if $STATIC; then
    if [[ -n "$MENU_AUDIOLENGTH" ]]; then
        LOOPS=$( bc <<< "$MENU_AUDIOLENGTH * $FRAME_RATE")
        LOOPS=${LOOPS%.*}
    else
        LOOPS=60
    fi
    JPEG2YUV_OPTS=(-n 1 -l $LOOPS)
    PICS_IN="$WORK_DIR/animenu/1.jpg"
else  # animated menu
    if $MENU_FADE; then
        JPEG2YUV_OPTS="-n $((ANI_MENU_END_FRAME + 18))"
    else
        JPEG2YUV_OPTS="-n $ANI_FRAMES"
    fi
    PICS_IN="$WORK_DIR/animenu/%d.jpg"
fi
ENC_CMD1=(jpeg2yuv -v 0 -f $FRAME_RATE -I p "${JPEG2YUV_OPTS[@]}" -L 1 -b1 \
-j "$PICS_IN")
ENC_CMD2=(ffmpeg   -f yuv4mpegpipe -i - -an -r $FRAME_RATE -s $VIDSIZE \
-tvstd $TV_STANDARD $FFMPEG_OPTS -y $WORK_DIR/intro.m2v)
yecho
echo "Running "${ENC_CMD1[@]}" | "${ENC_CMD2[@]}"" |format_output
if "${ENC_CMD1[@]}" | "${ENC_CMD2[@]}" >> "$LOG_FILE.tmp" 2>&1; then
    cleanlog 3
else
    cleanlog 3
    runtime_error
fi
echo
echo "Cleaning up montage images"
rm -fr $WORK_DIR/animenu/*.jpg
# check if m2v was created ok before proceeding
if mencoder -quiet -oac pcm -ovc copy -frames 0 $WORK_DIR/intro.m2v -o /dev/null &> /dev/null; then
    :
else
    echo
    runtime_error  "The menu video (m2v) does not appear to have been created"
fi
# if static then keep bg audio length (check later if -menu-audiolength opt used
if $STATIC && [[ -n "$BG_AUDIO" ]]; then
    TMP_TIME=$(ffmpeg -i "$BG_AUDIO" 2>&1|
    awk '/Duration/ {print $2}')
    TMP_TIME=$(awk_math ${TMP_TIME/,/} less $BG_AUDIO_SEEK float )
else
    TIME=$(vid_length "$WORK_DIR/intro.m2v")
fi
if [[ -n "$MENU_AUDIOLENGTH" ]] && $STATIC; then TIME=$MENU_AUDIOLENGTH; fi
TIME=${TIME:-$TMP_TIME}
BG_AUDIO_LENGTH="-t $TIME"
# create audio background for the main menu
if [ -z "$BG_AUDIO" ]; then # no audio supplied: use silence
    cat /dev/zero | nice -n 0 sox -t raw -c 2 -r 48000 -w \
    -s - $WORK_DIR/intro.wav  trim 0 $TIME
# Make sure file exists
elif test ! -e "$BG_AUDIO"; then
    runtime_error "Cannot find background audio file: $BG_AUDIO"
else # audio supplied: convert to wav then later to dvd/svcd format
    # TODO if ! $BG_AUDIOVIDEO_FILE; then  # check if same file and if so
    # decode the audio and jpegs in one step above, and skip this block
    BGAUDIO_CMD=(ffmpeg -i "$BG_AUDIO" -ar 48000 -ac 2 -acodec pcm_s16le -async 1 -y \
    -ss $BG_AUDIO_SEEK $BG_AUDIO_LENGTH $WORK_DIR/intro.wav)
    yecho
    echo "Running "${BGAUDIO_CMD[@]}"" >> "$LOG_FILE.tmp" 2>&1
    if "${BGAUDIO_CMD[@]}" >> "$LOG_FILE.tmp" 2>&1; then
        cleanlog 3
    else
        cleanlog 3
        runtime_error
    fi
    if $AUDIO_FADE; then  # bgaudio supplied and audio fade selected
        TIME=$(ffmpeg -i "$WORK_DIR/intro.wav" 2>&1|awk '/Duration/ {print $2}')
        TIME=${TIME/,/}
        echo "Running: "
        echo "sox $WORK_DIR/intro.wav $WORK_DIR/intro-processed.wav fade t \
        $FADE $TIME $FADE"
        sox $WORK_DIR/intro.wav \
        $WORK_DIR/intro-processed.wav fade t $FADE $TIME $FADE
        rm $WORK_DIR/intro.wav
        mv $WORK_DIR/intro-processed.wav $WORK_DIR/intro.wav
    fi
fi

unset BGAUDIO_CMD TIME

# convert to proper audio format
BGAUDIO_CMD=(ffmpeg -i $WORK_DIR/intro.wav \
$AUDIO_OPTS -y $WORK_DIR/intro.$AUDIO_EXT)
if "${BGAUDIO_CMD[@]}" >> "$LOG_FILE.tmp" 2>&1; then
    cleanlog 3
    else
    cleanlog 3
    runtime_error
fi
unset BGAUDIO_CMD
rm -fv "$WORK_DIR/intro.wav"
echo
echo "Multiplexing main menu audio and video together"
# mplex main menu audio and video together
INTRO_MPLEX_CMD="mplex -V -f $MPLEX_FORMAT -o $WORK_DIR/intro.mpg \
$WORK_DIR/intro.$AUDIO_EXT $WORK_DIR/intro.m2v"
echo -e "\nRunning: $INTRO_MPLEX_CMD\n" >> "$LOG_FILE.tmp"
cleanlog 1
yecho
if ${INTRO_MPLEX_CMD[@]} >> "$LOG_FILE.tmp" 2>&1; then
    cleanlog 1
else
    cleanlog 1
    runtime_error
fi

yecho
yecho "Running spumux "$SPUMUX_XML" < $WORK_DIR/intro.mpg > "$MENU_FILE""
spumux "$SPUMUX_XML" < $WORK_DIR/intro.mpg > "$MENU_FILE" 2>> "$LOG_FILE"
yecho
if test -f "$MENU_FILE"; then
    echo "Menu file $MENU_FILE created"
else
    runtime_error "Menu file $MENU_FILE not found.  Spumux seems to have had problems"
fi
if $SUB_MENU; then
    echo "Creating submenus"
    for ((x=1; x<=V_TOTAL; x++)); do
        yecho "Running spumux "$WORK_DIR/submenu${x}_spumux.xml" < \
        $WORK_DIR/menu${x}.mpg > \
        $(sed 's/\(.*\)menu/\1Menu/' <<< $WORK_DIR/menu${x}.mpg)"|fold -bs
        spumux "$WORK_DIR/submenu${x}_spumux.xml" < \
        $WORK_DIR/menu${x}.mpg > \
        $(sed 's/\(.*\)menu/\1Menu/' <<< $WORK_DIR/menu${x}.mpg) 2>> "$LOG_FILE"
    done
fi
if [ "$TARGET" = dvd ]; then
    echo "Running dvdauthor to create the DVD filesystem"
    dvdauthor -x "$DVDAUTHOR_XML" 2>&1 | tee -a "$LOG_FILE"
    if [[ ${PIPESTATUS[0]} -ne 0 ]]; then
        runtime_error "There was a problem creating the DVD structure"
    fi
elif [ "$TARGET" = svcd ]; then
    makexml -svcd -menu "$WORK_DIR/animenu.mpg" "${IN_FILES[@]}" -out MyDisc
    vcdxbuild -b ../videocd.bin -c ../videocd.cue  MyDisc.xml
fi
echo "Cleaning up unwanted files in $REAL_WORK_DIR"
find "$WORK_DIR"/ -name '*.png' ! -name Highlight.png ! -name Select.png -exec rm -f {} \;
find "$WORK_DIR"/ -name '*.jpg' ! -name preview.jpg -exec rm -f {} \;
rm -frv "$WORK_DIR/animenu" "$WORK_DIR/pics" "$WORK_DIR/submenu"
echo "Removing the link in /tmp"
rm -fv "$WORK_DIR"
#    if $SUB_MENU; then
#        makexml -vcd -topmenu "$WORK_DIR/animenu.mpg" \
#        $(for ((x=1; x<=V_TOTAL; x++)); do echo \
#        "-menu $WORK_DIR/Menu${x}.mpg";done) "${IN_FILES[@]}" -out MyDisc
#        vcdxbuild MyDisc.xml
#    else

SCRIPT_END_TIME=`date +%s`
SCRIPT_TOT_TIME=`expr $SCRIPT_END_TIME \- $SCRIPT_START_TIME`
HHMMSS=`format_time $SCRIPT_TOT_TIME`
echo
echo $SEPARATOR
echo "todisc took $HHMMSS to finish on $CPU_MODEL $CPU_SPEED mhz"
echo $SEPARATOR
if [ "$TARGET" = dvd ]; then
    echo "Your new DVD should be in $OUT_DIR"
    echo "You can preview them in gxine with this command:"
    echo "    gxine dvd:/$OUT_DIR"
    echo "If you are satisfied with the results, you can burn a disc with:"
    echo "    makedvd -burn $OUT_DIR"
elif [ "$TARGET" = svcd ]; then
    echo "Your svcd bin and cue files are ready. You can burn them with:"
    echo "    cdrdao write --device /dev/hdc --driver generic-mmc videocd.cue"
fi
echo
echo "Thanks for using todisc."
cleanup
exit 0
