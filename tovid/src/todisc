#!/bin/bash
ME="[todisc]:"
. tovid-init

# todisc
# Part of the tovid suite
# =======================
# A bash script for generating a DVD with animated thumbnail menus
# from a collection of MPEG video files.
#
# Project homepage: http://www.tovid.org
#
#
# Copyright (C) 2005 tovid.org <http://www.tovid.org>
# 
# This program is free software; you can redistribute it and/or 
# modify it under the terms of the GNU General Public License 
# as published by the Free Software Foundation; either 
# version 2 of the License, or (at your option) any later 
# version.
# 
# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.
# 
# You should have received a copy of the GNU General Public License
# along with this program; if not, write to the Free Software
# Foundation, Inc., 675 Mass Ave, Cambridge, MA 02139, USA. Or see:
#
#           http://www.gnu.org/licenses/gpl.txt


# Mostly written by Robert Sohn:
#     <grepper@gmail.com>
#     grepper on irc.freenode.net

SCRIPT_NAME=`cat << EOF
--------------------------------
todisc
Generate a DVD filesystem with animated thumbnail menus
Part of the tovid suite, version $TOVID_VERSION
$BUILD_OPTIONS
$TOVID_HOME_PAGE
--------------------------------
EOF`

USAGE=`cat << EOF
Usage:
    todisc [OPTIONS] \\\\
      -files File1.mpg File2.mpg ... \\\\
      -titles "Title 1" "Title 2" ... \\\\
      -out OUT_PREFIX
Input files must be MPEG, and the number of -files and -titles must be equal. 
See the todisc manual page ('man todisc') for additional documentation.

EOF`

WORK_DIR="$(abspath "todisc-work")"
LOG_FILE="`pwd`/todisc.log"
OUT_PREFIX=""
TV_STANDARD=ntsc
ANI_MENU_LENGTH=20
ANI_SUBMENU_LENGTH=10
MAX_ANI_LENGTH=""
TARGET=dvd
FRAME_RATE=29.970  # when -ntsc and -pal options added put in body in if block
VID_SIZE=720x480
VMGM_TITLE="My Video Collection"
SPUMUX_XML="$WORK_DIR/spumux.xml"
SUBMENU_SPUMUX_XML="$WORK_DIR/submenu_spumux.xml"
DVDAUTHOR_XML="$WORK_DIR/dvdauthor.xml"
STATIC=false
SUB_MENU=false
ANI_SUB_MENU=false
TITLE_COLOUR="#CDC0B0"
THUMB_BG_COLOUR=white
THUMB_TEXT_COLOUR=""
MIST_COLOUR=white
MIST_BLUR=60
STROKE=""
CHAPTERS=6
BG_AUDIO=""
BG_PIC=""
BG_VIDEO=""
SUBMENU_AUDIO=false
SM_AUDIO_FADE=:
AUDIO_FADE=:
OPACITY=100
MENU_FADE=false
TRANSPARENT=false
PREVIEW=:
PAUSE_TIME=10
MIST=false
FEATHER=false
BLUR=5
SUB_MENU_FEATHER=false
IMG_FMT=jpg
SM_IMG_FMT=jpg  # submenu image format
KEEP_FILES=false
DEBUG=false
THUMB_SHAPE=""
SEEK="-ss 1"
SEEK_VAL=1
FADE=1

SCRIPT_START_TIME=`date +%s`

##############################################################################
#                                 Functions                                  #
##############################################################################

# Y-echo: echo to two places at once (stdout and logfile)
# Output is preceded by the script name that produced it
# Args: $@ == any text string
# If no args are given, echo a separator bar
# Use yecho if you want output to go to the logfile
yecho()
{
    if test $# -eq 0; then
        printf "\n%s\n\n" "$SEPARATOR"
        # If logfile exists, copy output to it (with pretty formatting)
        test -e "$LOG_FILE" && \
            printf "%s\n%s %s\n%s\n" "$ME" "$ME" "$SEPARATOR" "$ME" >> "$LOG_FILE"
    else
        echo "$@"
        test -e "$LOG_FILE" && \
            printf "%s %s\n" "$ME" "$@" >> "$LOG_FILE"
    fi
}

# ******************************************************************************
# Execute the given command-line string, with appropriate stream redirection
# Args: $@ == text string contianing complete command-line
# Returns: Exit status of the subprocess
# To filter/prettify the subprocess output before writing it to the log file,
# set the LOG_FILTER variable before calling this function, to e.g.
#    LOG_FILTER="sed 's/\r/\r\n/g'"    # Replace LF with CR/LF
# ******************************************************************************
cmd_exec()
{
    if $DEBUG; then
        # Display all output, and also write it to the log
        eval "$@" 2>&1 | ${LOG_FILTER:=cat} | tee -a "$LOG_FILE"
    else
        # Just write that junk to the log
        eval "$@" 2>&1 | ${LOG_FILTER:=cat} >> "$LOG_FILE"
    fi
    # Return exit status
    return $?
}

# Print script name, usage notes, and optional error message, then exit.
# Args: $@ == text string containing error message
usage_error ()
{
    printf "%s\n" "$USAGE"
    printf "%s\n" "$SEPARATOR"
    printf "*** %s\n" "$@"
    exit 1
}


function cleanlog()
# process $LOG_FILE.tmp variously - eg. ffmpeg's output is ugly without this
{
    FOLD="fold -bs"
    NO_CR="tr -d '\r'"
    RELINE="{s/$SED_VAR/\n$SED_VAR/g}"
    TMP_LOG="$LOG_FILE.tmp"
    NOSPACE="tr -s ' '"

    case "$1" in
        1 )
            $FOLD $TMP_LOG >> $LOG_FILE
            echo >> $LOG_FILE
            ;;
        2 )
            $NO_CR < $TMP_LOG | $FOLD >> $LOG_FILE
            echo >> $LOG_FILE
            ;;
        3 )
            $NO_CR < $TMP_LOG | sed $RELINE | $FOLD >> $LOG_FILE
            echo >> $LOG_FILE
            ;;
        4 )
            $NOSPACE < $TMP_LOG | $FOLD >> $LOG_FILE
            ;;
    esac
    rm -f $LOG_FILE.tmp
}

function get_font()
{
    # If there's a filename extension, find the absolute path
    if echo "$1" | grep -q '\...*$'; then
        echo $(abspath "$1")
    # Otherwise, use the literal name
    else
        echo "$1"
    fi
    # TODO: Check for font availability?
}

# ******************************************************************************
# Print out a runtime error specified as an argument, and exit
# ******************************************************************************
runtime_error()
{
    # Uncomment if needed later
    #killsubprocs
    echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    yecho "todisc encountered an error:"
    yecho "    $@"
    echo "Check the contents of $LOG_FILE to see what went wrong."
    # TODO: Uncomment once -debug is actually implemented
    if $DEBUG; then :; else
        echo "Run todisc again with the -debug option to produce more verbose"
        echo "output, if the log file doesn't give you enough information."
    fi
    #echo " "
    echo "See the tovid website ($TOVID_HOME_PAGE) for what to do next."
    echo "Sorry for the inconvenience!"
    echo "!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!!"
    exit 1
}

function vid_length()
{
    mencoder "$1" -quiet -ovc copy -oac pcm -o /dev/null |
    awk '/Video stream/ {print $10}'
}

function cleanup()
{
    yecho "Cleaning up..."
    if $KEEP_FILES; then
        yecho "Keeping temporary files in $WORK_DIR"
    else
        rm -rf "$WORK_DIR"
    fi
}

function running_total ()
{
    awk '{
    for (i=1; i<=NF; i++) if (s=s+$i) printf("%s ",s);printf ("\n")}'
}

function format_seconds()
{
    awk '{
    hr=($1/3600); hd=(sprintf("%02d", hr))
    mr=((hr-hd)*60); md=(sprintf("%02d", mr))
    s=((mr-md)*60); sd=(sprintf("%02d", s))
    t=(sprintf("%02d:%02d:%06.3f" ,hd,md,s)); print t}' <<< $1
}

function awk_math()
{
    if [ $2 = times ]; then
        OP=*
    elif [ $2 = by ]; then
        OP=/
    elif [ $2 = less ]; then
        OP=-
    elif [ $2 = plus ]; then
        OP=+
    fi
if [[ -n "$4" && "$4" = "float" ]]; then
    awk 'BEGIN { printf("'"$1"'" '$OP' "'"$3"'")"\n" ; exit  }'
else
    awk -v A=$1 -v B=$3 'BEGIN { printf("%d\n", (A '$OP' B)); }'
fi
}


function confirm_preview()
{
    yecho
    echo "If you are happy with the preview, type 'yes' to continue: "
    read input
    echo
    if [ ! -z "$input" -a "$input" = "yes" ]; then
        yecho "Preview OK, continuing."
        yecho
    else
        yecho "Preview not OK, exiting."
        yecho
        yecho "Some configuration options to try, if things look bad:"
        yecho "   -menu-font and -menu-fontsize"
        yecho "     (to adjust the main title)"
        yecho "    -thumbfont and -thumb-fontsize"
        yecho "If you get black frames, then look at the -seek option"
        yecho "For other fine-tuning options, see 'man todisc'."
        exit 0
    fi
#    yecho
}

##############################################################################
#                          	End of functions                                 #
##############################################################################

trap 'cleanup; exit 13' TERM INT

###############################################################################
#       Process arguments to the script, set up VARS and WORK_DIR             #
###############################################################################

# ***********************************
# EXECUTION BEGINS HERE
# ***********************************

yecho $"$SCRIPT_NAME"

while test $# -gt 0; do
    DO_SHIFT=:
    case "$1" in
        "-files" )
            shift
            # Hackish list-parsing
            while test $# -gt 0 && test ${1:0:1} != "-"; do
                FILES=("${FILES[@]}" "$1")
                shift
            done
            # Do not skip past the next argument
            if test $# -gt 0 && test ${1:0:1} = "-"; then DO_SHIFT=false; fi
            ;;
        "-titles" )
            shift
            # Hackish list-parsing
            IFS="";while test $# -gt 0 && test ${1:0:1} != "-"; do
                TITLES=("${TITLES[@]}" "$1")
                shift
            done
            # Do not skip past the next argument
            if test $# -gt 0 && test ${1:0:1} = "-"; then DO_SHIFT=false; fi
            unset IFS
            ;;
        "-out" )
            shift
            OUT_PREFIX="$1"
            ;;
        "-keepfiles" )
            KEEP_FILES=:
            ;;
        "-debug" )
            DEBUG=:
            ;;
        "-ntsc" )
            TV_STANDARD=ntsc
            ;;
        "-pal" )
            TV_STANDARD=pal
            ;;
        "-menu-length" )
            shift
            ANI_MENU_LENGTH="$1"
            ;;
        "-submenu-length" )
            shift
            ANI_SUBMENU_LENGTH="$1"
            ;;
        "-dvd" )
            TARGET=dvd
            ;;
        "-svcd" )
            TARGET=svcd
            ;;
        "-static" )
            STATIC=:
            ;;
        "-bgimage" )
            shift
            BG_PIC="$(abspath "$1")"
            ;;
        "-menu-fade" )
            MENU_FADE=:
            AUDIO_FADE=:
            ;;
        "-loop" )
            shift
            PAUSE_TIME="$1"
            ;;
        "-bgvideo" )
            shift
            BG_VIDEO="$(abspath "$1")"
            ;;
        "-thumb-shape" )
            shift
            THUMB_SHAPE="$1"
            FEATHER=:
            IMG_FMT=png
            ;;
        "-blur" )
            shift
            BLUR="$1"
            ;;
        "-title-colour" | "-title-color" )
            shift
            TITLE_COLOUR="$1"
            ;;
        "-stroke-colour" | "-stroke-color" )
            shift
            STROKE="$1"
            ;;
        "-thumb-text-colour" | "-thumb-text-color" )
            shift
            THUMB_TEXT_COLOUR="$1"
            ;;
        "-text-mist" )
            MIST=:
            ;;
        "-text-mist-opacity" )
            shift
            MIST_BLUR="$1"
            ;;
        "-mist-color" |"-mist-colour" )
            shift
            MIST_COLOUR="$1"
            ;;
        "-thumb-mist-color" |"-thumb-mist-colour" )
            shift
            THUMB_BG_COLOUR="$1"
            ;;
        "-opacity" )
            shift
            TRANSPARENT=:
            OPACITY="$1"
            ;;
        "-chapters" )
            shift
            CHAPTERS="$1"
            ;;
        "-bgaudio" )
            shift
            BG_AUDIO="$(abspath "$1")"
            ;;
        "-menu-audio-fade" )
            shift
            FADE="$1"
            AUDIO_FADE=:
            ;;
        "-submenu-audio" )
            shift
            # Hackish list-parsing
            while test $# -gt 0 && test ${1:0:1} != "-"; do
                SM_AUDIO=( "${SM_AUDIO[@]}" "$(abspath "$1")" )
                shift
            done
            # Do not skip past the next argument
            if test $# -gt 0 && test ${1:0:1} = "-";then
                DO_SHIFT=false
            fi
            SUBMENU_AUDIO=:
            ;;
        "-submenu-audio-fade" )
            shift
            SM_FADE="$1"
            SM_AUDIO_FADE=:
            ;;
        "-submenus" )
            SUB_MENU=:
            ;;
        "-ani-submenus" )
            ANI_SUB_MENU=:
            SUB_MENU=:
            ;;
        "-menu-title" )
            shift
            VMGM_TITLE="$1"
            ;;
        "-menu-font" )
            shift
            MENU_FONT="$(get_font "$1")"
            ;;
        "-menu-fontsize" )
            shift
            MENU_FONTSIZE="$1"
            ;;
        "-thumb-font" )
            shift
            THUMB_FONT="$(get_font "$1")"
            ;;
        "-thumb-fontsize" )
            shift
            THUMB_FONTSIZE="$1"
            ;;
        "-seek" )
            shift
            SEEK_VAL="$1"
            SEEK="-ss $SEEK_VAL"
            ;;
    esac
    $DO_SHIFT && shift
done

##############################################################################
#                      Sanity checks and preliminaries                       #
##############################################################################

# Make sure equal, nonzero number of titles and files were provided
if test ${#FILES[@]} -eq 0 || test ${#TITLES[@]} -eq 0; then
    usage_error "Please provide at least one file and one title."
elif test ${#FILES[@]} -ne ${#TITLES[@]}; then
    usage_error "Please give the same number of files as titles."
fi

# Make sure -out was provided
if test -n "$OUT_PREFIX"; then
    OUT_DIR="$(abspath "$OUT_PREFIX")"
    MENU_FILE="animenu.mpg"
else
    usage_error "Please provide an output name with -out"
fi

# Make sure thumb labels have no more than 12 characters
for ((i=0; i<${#TITLES[@]}; i++)); do
    val=${#TITLES[i]}
    [ -z "$MAX_CHARS" ] || ((val > MAX_CHARS)) && MAX_CHARS=$val && key=$i
done
if [ $MAX_CHARS -gt 12 ]; then
    echo -e "Sorry, thumb labels can only be 12 characters in length."
    echo "\"${TITLES[key]}\" is too long; please use a shorter title."
    exit 1
fi

# If output directory already exists, print a message and exit
if test -d "$OUT_DIR"; then
    echo "Output directory \"$OUT_DIR\" already exists."
    echo "Please use a different -out name, or (re)move the existing directory."
    exit 1
fi

yecho
yecho "Creating work directories"
yecho

# Clean out any existing WORK_DIR
if test -d "$WORK_DIR"; then
    echo "Removing existing files in \"$WORK_DIR\""
    rm -rf "$WORK_DIR"
fi
mkdir -pv "$WORK_DIR"

# Remove any existing log file
test -f "$LOG_FILE" && rm -fv "$LOG_FILE"

# allow user to only specify one audio file for all submenus
if [ ${#SM_AUDIO[@]} -eq 1 ]; then
    SM_AUDIO_FILE=${SM_AUDIO[0]}
fi
# if more than one audio file for submenu make sure they equal video #
if [[ $SM_AUDIO &&  ${#FILES[@]} -ne ${#SM_AUDIO[@]} &&  ${#SM_AUDIO[@]} -ne 1 ]]; then
    usage_error "Please give the same number of submenu audios as videos.
    You gave ${#FILES[@]} video files and ${#SM_AUDIO[@]} audio files"
fi
# Get absolute pathnames of all files
for i in "${FILES[@]}"; do
    IN_FILES=("${IN_FILES[@]}" "$(abspath "$i")")
    echo "Adding: $i"
done
V_ARRAY_TOTAL=${#IN_FILES[@]}
# (Length of array) - 1
NUM_FILES=$(($V_ARRAY_TOTAL - 1))

# create_dirs
yecho "Creating pics directories..."
for ((i=0; i<=NUM_FILES; i++)); do
    mkdir -pv "$WORK_DIR/pics/$i"
done
# prevent user from using mutually exclusive options
if $STATIC; then
    MENU_FADE=false
fi
if [ $FADE = 0 ]; then
    AUDIO_FADE=false
elif [ $SM_AUDIO_FADE = 0 ]; then
    SM_AUDIO_FADE=false
fi
if $MENU_FADE || test -n "$BG_VIDEO"; then mkdir -v $WORK_DIR/bg; fi
mkdir -v "$WORK_DIR/animenu"
if $ANI_SUB_MENU; then
    for ((i=0; i<CHAPTERS; i++)); do
        mkdir -v "$WORK_DIR/animenu/$i"
    done
fi

# Check input files for compliance; offer to tovid-encode non-compliant files
for ((i=0; i<=NUM_FILES; i++)); do
    TEST_FILE=${IN_FILES[i]}
    yecho "Checking $TEST_FILE for compliance..."
    # TODO: Check for PAL/NTSC compliance
    # If video matches the target format, append to NEW_IN_FILES
    if test $TARGET = "dvd" && idvid -is dvd "$TEST_FILE"; then
        NEW_IN_FILES=("${NEW_IN_FILES[@]}" "$TEST_FILE")
    elif test $TARGET = "svcd" && idvid -is svcd "$TEST_FILE"; then
        NEW_IN_FILES=("${NEW_IN_FILES[@]}" "$TEST_FILE")
    # Video needs to be re-encoded; use a .enc filename in NEW_IN_FILES
    else
        FILES_TO_ENCODE[i]="$TEST_FILE"
        NEW_IN_FILES=("${NEW_IN_FILES[@]}" "$TEST_FILE.enc.mpg")
    fi
done
if test "${#FILES_TO_ENCODE[@]}" -gt 0; then
    TGT_CAPS=$(echo $TARGET | tr a-z A-Z)
    yecho
    yecho "Encode input files"
    yecho
    yecho "Some of the -files you provided are not $TGT_CAPS-compliant:"
    yecho " "
    for i in "${FILES_TO_ENCODE[@]}"; do
        test -n "$i" && yecho "  $i"
    done
    yecho " "
    yecho "I can encode them for you, but it may take a long time."
    yecho "Encoding will ensure that your disc is fully compliant;"
    yecho "you may skip this, but your disc may not be playable."
    yecho "Please type 'yes' if you want the files to be encoded:"
    read ENCODE
    if test -n "$ENCODE" && test "$ENCODE" = 'yes'; then
        yecho
        yecho "Converting files to $TGT_CAPS format with 'tovid'"
        for i in "${FILES_TO_ENCODE[@]}"; do
            yecho "Converting: $i"
            countdown
            tovid -$TV_STANDARD -$TARGET -in $i -out $i.enc
            wait
            # See if output file exists
            if ! test -f "$i.enc.mpg"; then
                runtime_error "Couldn't encode file: $i"
            fi
            yecho
        done
        # Replace IN_FILES with NEW_IN_FILES (with .enc extension)
        IN_FILES=("${NEW_IN_FILES[@]}")
    else
        yecho
        yecho "Not re-encoding. I'll proceed with menu generation, but"
        yecho "your authored disc will not be fully $TGT_CAPS-compliant."
        yecho
    fi
fi

##############################################################################
# Font defaults
##############################################################################

# Menu title font size
test $TARGET = "dvd" && : ${MENU_FONTSIZE:="40"}
test $TARGET = "svcd" && : ${MENU_FONTSIZE:="32"}
# Thumbnail title font size
# PTSIZE=(30 36 42 42 42 42 48 48 48 48 48 48 54 54 54 54 54 54 54 54 \
# 54 54 54 54 54 54 54 54 54 54)
THUMB_FONTSIZE_ARRAY=(14 14 14 14 12 12 12 12 11 11 11 11 11 11 11 11 11 11 \
11 11 11 11 11 11 11 11 11 11)
: ${THUMB_FONTSIZE:=${THUMB_FONTSIZE_ARRAY[NUM_FILES]}}

# See if "Helvetica" or "helvetica" are available as default fonts
if convert -size 50x20 xc:none -font Helvetica -gravity Center \
-draw "text 0,0 'test'" $WORK_DIR/font.png; then
    DEFAULT_FONT="Helvetica"
elif convert -size 200x100 xc:none -font helvetica -gravity Center \
-draw "text 0,0 'test'" $WORK_DIR/font.png; then
    DEFAULT_FONT="helvetica"
fi
: ${MENU_FONT:=$DEFAULT_FONT}
: ${THUMB_FONT:=$DEFAULT_FONT}
rm -f "$WORK_DIR/font.png"


# Some user feedback
yecho
yecho "Disc title: \"$VMGM_TITLE\""
yecho "  (adjust with -menu-title)"
yecho "Including the following videos:"
for ((i=0; i<${#TITLES[@]}; i++)); do
    yecho "  \"${TITLES[i]}\" (${IN_FILES[i]})"
done
yecho "Current font settings: "
yecho "  -menu-font $MENU_FONT"
yecho "  -menu-fontsize $MENU_FONTSIZE"
yecho "  -thumb-font $THUMB_FONT"
yecho "  -thumb-fontsize $THUMB_FONTSIZE"
yecho "Current menu settings: "
yecho "  -menu-length $ANI_MENU_LENGTH seconds"
if $ANI_SUB_MENU; then
    yecho "  -submenu-length $ANI_SUBMENU_LENGTH seconds"
fi
yecho "  -seek $SEEK_VAL second(s)"
yecho "  -menu-audio-fade $FADE second(s)"
yecho "  -chapters $CHAPTERS"
yecho


# TODO: Merge these globals with the ones up top
DVD_GEO_ARRAY=(320x240 272x204 192x144 192x144 184x138 184x138 144x108 144x108 \
120x90 120x90 120x90 120x90 96x72 96x72 96x72 96x72 96x72 96x72 96x72 96x72 \
72x54 72x54 72x54 72x54 72x54 72x54 72x54 72x54 72x54 72x54)
SVCD_GEO_ARRAY=(240x240 180x180 120x120 120x120 120x120 120x120 96x96 96x96 \
96x96 80x80 80x80 80x80 64x64 64x64 64x64 64x64 64x64 64x64 64x64 64x64 \
48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48 48x48)
TILE_ARRAY=(1x1 2x1 2x2 2x2 3x2 3x2 4x2 4x2 3x3 4x3 4x3 4x3 4x4 4x4 4x4
4x4 5x4 5x4 5x4 5x4 5x5 5x5 5x5 5x5 5x5 6x5 6x5 6x5 6x5 6x5)

PATTERN=$(for ((i=1; i<=79; i++)); do echo -n \*; done)
printf "%s\n%s\n%s\n\n\n" "$PATTERN" \
"tovid suite's todisc - log for `date`" \
"$PATTERN" >> $LOG_FILE

# Do everything in $WORK_DIR
echo "Doing all work in directory: $WORK_DIR"
cd $WORK_DIR

echo  
if  [ $TARGET = "dvd" ]; then
    AUDIO_EXT="ac3"
    SAMPLERATE="48000"
    MPLEX_FORMAT="8"
    GEO_ARRAY=("${DVD_GEO_ARRAY[@]}")
    FFMPEG_OPTS="-b 8000  -maxrate 9000 -bufsize 230  -aspect 4:3"
    if [ $TV_STANDARD = ntsc ]; then
        VIDSIZE="720x480"
        FRAME_RATE=29.970
    elif [ $TV_STANDARD = pal ]; then
        VIDSIZE="720x576"
        FRAME_RATE=25
    fi
elif [ $TARGET = "svcd" ]; then
    AUDIO_EXT="mp2"
    SAMPLERATE="44100"
    MPLEX_FORMAT="4"
    GEO_ARRAY=("${SVCD_GEO_ARRAY[@]}")
    FFMPEG_OPTS="-b 2200 -minrate 2200 -maxrate 2200 -bufsize 230 -aspect 4:3"
    if [ $TV_STANDARD = ntsc ]; then
        VIDSIZE="480x480"
        FRAME_RATE=29.970
    elif [ $TV_STANDARD = pal ]; then
        VIDSIZE="480x576"
        FRAME_RATE=25
    fi
fi
AUDIO_OPTS="-ab 224 -ar $SAMPLERATE -ac 2 -acodec $AUDIO_EXT"
THUMB_SIZE="${GEO_ARRAY[NUM_FILES]}"

###############################################################################
#     generate title_txt png, and template.png needed for all operations       #
###############################################################################

if [ -z "$BG_PIC" ]; then
    echo
    echo "Creating a black background"
    BG_PIC="$WORK_DIR/pics/template.png"
    convert  -resize $VIDSIZE! xc:"#161514" "$BG_PIC"
else
    convert -resize $VIDSIZE! "$BG_PIC" "$WORK_DIR/pics/template.png"
fi

if $MENU_FADE || $FEATHER; then
    convert -size $VIDSIZE xc:"#161514" "$WORK_DIR/black.jpg"
fi
DIMY=$(echo $THUMB_SIZE|cut -f1 -dx)
DIMX=$(echo $THUMB_SIZE|cut -f2 -dx)
DIMY1=$((DIMY / 20))
DIMX1=$((DIMX / 20))
DIMY2=$((DIMY - DIMY1))
DIMX2=$((DIMX - DIMY1))
DIMY3=$(($DIMY2 / 2))
DIMX3=$(($DIMX2 / 2))
DIMY4=$((DIMY / 2))
DIMX4=$((DIMX / 2))
DIMY5=$((DIMY / 3))
DIMX5=$((DIMX4 / 3))
BLUR_CMD=(convert - -blur 0x$BLUR -channel RGBA +matte miff:-)
if [ -n "$THUMB_SHAPE" ]; then
    # make a mask for the mist if called for
    convert -size $THUMB_SIZE xc:none -fill  $THUMB_BG_COLOUR -stroke none \
    -draw "rectangle $DIMY1,$DIMY1 $DIMY2,$DIMX2" $WORK_DIR/feather_orig.png
    convert $WORK_DIR/feather_orig.png -channel RGBA \
    -blur 0x60 $WORK_DIR/feather_mask2.png
fi
if test "$THUMB_SHAPE" = "normal"; then
    THUMB_MASK=$WORK_DIR/feather_mask.png
    convert -size $THUMB_SIZE xc:black -fill white \
    -draw "Rectangle $DIMY1,$DIMY1 $DIMY2,$DIMX2," +matte -compose CopyOpacity miff:- |
    "${BLUR_CMD[@]}" | "${BLUR_CMD[@]}" | "${BLUR_CMD[@]}" | "${BLUR_CMD[@]}" |
    convert - -evaluate subtract 50% -normalize $THUMB_MASK
fi
if [ -z $THUMB_TEXT_COLOUR ]; then
    if $FEATHER; then
        THUMB_TEXT_COLOUR="#161514"
    else
        THUMB_TEXT_COLOUR="#C6C6C6"
    fi
fi

if test "$THUMB_SHAPE" = "oval"; then
    THUMB_MASK=$WORK_DIR/oval_mask.png
    echo "Running:
    convert -size $THUMB_SIZE xc:black -fill white
    -draw "RoundRectangle $DIMY1,$DIMY1 $DIMY2,$DIMX2, $DIMY3,$DIMX3" \
    +matte -compose CopyOpacity miff:- |
    convert - -blur 0x$BLUR -channel RGBA +matte miff:- |
    convert - -evaluate subtract 50% -normalize $THUMB_MASK" |
    sed 's/    */ /g'|sed -e "s/^ *//" 
    echo
    convert -size $THUMB_SIZE xc:black -fill white
    -draw "RoundRectangle $DIMY1,$DIMY1 $DIMY2,$DIMX2, $DIMY3,$DIMX3" \
    +matte -compose CopyOpacity miff:- |
    "${BLUR_CMD[@]}" | "${BLUR_CMD[@]}" | "${BLUR_CMD[@]}" | "${BLUR_CMD[@]}" |
    convert - -evaluate subtract 50% -normalize $THUMB_MASK
fi

if test "$THUMB_SHAPE" = "egg"; then
    THUMB_MASK=$WORK_DIR/egg_mask.png
    echo "Running:

    convert -size $THUMB_SIZE xc:black -fill white \
    -draw "circle $DIMY4,$DIMX4 $DIMY5,$DIMX5" \
    +matte -compose CopyOpacity miff:- |
    convert - -blur 0x$BLUR -channel RGBA +matte miff:- |
    convert - -evaluate subtract 50% -normalize $THUMB_MASK" |
    sed 's/    */ /g'|sed -e "s/^ *//"
    echo
    convert -size $THUMB_SIZE xc:black -fill white \
    -draw "circle $DIMY4,$DIMX4 $DIMY5,$DIMX5" \
    +matte -compose CopyOpacity miff:- |
    "${BLUR_CMD[@]}" | "${BLUR_CMD[@]}" | "${BLUR_CMD[@]}" | "${BLUR_CMD[@]}" |
    convert - -evaluate subtract 50% -normalize - $THUMB_MASK
fi

if test "$THUMB_SHAPE" = "cloud"; then
    THUMB_MASK=$WORK_DIR/cloud_mask.png
    convert -size 320x240 xc:none -fill white \
    -draw "circle 80,80 120,120" \
    -draw "circle 160,80 200,120" \
    -draw "circle 240,80 280,120" \
    -draw "circle 80,160 120,200" \
    -draw "circle 160,160 200,200" \
    -draw "circle 240,160 280,200" \
    +matte -compose CopyOpacity  miff:- |
    "${BLUR_CMD[@]}" | "${BLUR_CMD[@]}" | "${BLUR_CMD[@]}" | "${BLUR_CMD[@]}" |
    convert -resize $THUMB_SIZE! - $THUMB_MASK
fi

yecho "Creating a title image"
if [ -z "$BG_PIC" ]; then
    STROKE=none
elif [ -z "$STROKE" ]; then
    STROKE=gray
fi

echo "Running
convert -size 620x100 xc:none -font "$MENU_FONT" \
-pointsize $MENU_FONTSIZE \
-fill black -draw "gravity center text 2,2 \"$VMGM_TITLE\"" \
-stroke "$STROKE" -strokewidth 1 \
-fill "$TITLE_COLOUR" -stroke "$STROKE" \
-draw "gravity center text 1,1 \"$VMGM_TITLE\"" miff:- | \
convert -trim +repage - -blur 0x0.4 $WORK_DIR/title_txt.png
"

convert -size 620x100 xc:none -font "$MENU_FONT" \
-pointsize $MENU_FONTSIZE \
-fill black -draw "gravity center text 2,2 \"$VMGM_TITLE\"" \
-stroke "$STROKE" -strokewidth 1 \
-fill "$TITLE_COLOUR" -stroke "$STROKE" \
-draw "gravity center text 1,1 \"$VMGM_TITLE\"" miff:- | \
convert -trim +repage - -blur 0x0.4 $WORK_DIR/title_txt.png

if $MIST; then
    # make a white png for misted background effect, only for user's bg
    Y=$(identify $WORK_DIR/title_txt.png |awk '{print $3}'|cut -dx -f1)
    X=$(identify $WORK_DIR/title_txt.png |awk '{print $3}'|cut -dx -f2)
    # add 10 pixels to width and height compared to title text png
    y=$((Y + 40))
    x=$((X + 40))
    newX=$(($X + 30))
    newY=$(($Y + 30))
    DIM=${y}x${x}
    convert -size $DIM xc:none -fill $MIST_COLOUR -stroke none \
    -draw "rectangle 10,10 $newY,$newX" $WORK_DIR/white_orig.png
    convert $WORK_DIR/white_orig.png -channel RGBA -blur 0x4 $WORK_DIR/white.png
    unset X Y x y
fi

###############################################################################
#      generate a basic preview of the main menu                              #
###############################################################################
if $MIST; then
    # overlay white.png onto the background
    composite -dissolve $MIST_BLUR -gravity south -geometry +0+45 \
    $WORK_DIR/white.png $WORK_DIR/pics/template.png \
    $WORK_DIR/pics/template.png
fi
# generate images for montage and title and resize them
for ((i=0; i<=NUM_FILES; i++)) ; do
    FFMPEG_CMD=(ffmpeg -i "${IN_FILES[i]}" $SEEK -vframes 1 \
    -s $THUMB_SIZE $WORK_DIR/${i}-preview%d.$IMG_FMT)
    echo -e "\nRunning: "${FFMPEG_CMD[@]}"\n" | fold -bs >> $LOG_FILE
    SED_VAR="frame="
    if "${FFMPEG_CMD[@]}" >> $LOG_FILE.tmp 2>&1;then
        cleanlog 3
    else
        cleanlog 3
        runtime_error "Problem creating images from the video."
        exit 1
    fi
done
PICS=( "${PICS[@]}" \
$(find $WORK_DIR/ -maxdepth 1 -name \*preview\*.$IMG_FMT) )
for ((i=0; i<${#PICS[@]}; i++)); do
    if $FEATHER; then
        composite -compose CopyOpacity $THUMB_MASK +matte \
        "${PICS[i]}" miff:- |
        convert -trim +repage -  "${PICS[i]}"
    fi

    # **if horizontal lines in frames, try montage "${JPGS[i]}" -blur 0x.3**
    # using a mask just on the frame portion would be even better
    # www.cit.gu.edu.au/~anthony/info/graphics/imagemagick.hints 1/4 down
    IM_CMD1=(montage "${PICS[i]}" -geometry +4+4 -compose Copy  \
    -background  none -fill "$THUMB_TEXT_COLOUR" -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE \
    -title "${TITLES[i]}")
    IM_CMD2=(convert -resize $THUMB_SIZE! -)
    IM_CMD3=(composite -gravity center -compose DstOver $WORK_DIR/feather_mask2.png - )
    IM_CMD4=(convert -background none -frame 5x5 \
    -bordercolor "#444744" -)
    IM_CMD5=(convert -resize $THUMB_SIZE! - "${PICS[i]}")
    if $FEATHER; then
        "${IM_CMD1[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
        "${IM_CMD3[@]}" miff:- | "${IM_CMD5[@]}"
    else
        "${IM_CMD1[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
        "${IM_CMD4[@]}" miff:- | "${IM_CMD5[@]}"
    fi
done

echo "Creating and displaying a preview of the main menu."
echo "(Press 'q' or ESC in the preview window to close it.)"

if $TRANSPARENT; then
    montage ${PICS[@]} -blur 0x.3 -tile ${TILE_ARRAY[NUM_FILES]} \
    -geometry ${GEO_ARRAY[NUM_FILES]}+5+5 -background none -bordercolor "#444744" miff:- |
    composite -dissolve $OPACITY \
    -gravity north -geometry +0+45 - \
    $WORK_DIR/pics/template.png -background none miff:- |
    convert - $WORK_DIR/title_txt.png  \
    -gravity south -geometry +0+65 -composite miff:- |display
else # Not transparent
    montage ${PICS[@]} -tile ${TILE_ARRAY[NUM_FILES]} \
    -geometry ${GEO_ARRAY[NUM_FILES]}+5+5 -background none -bordercolor "#444744" miff:- |
    convert $WORK_DIR/pics/template.png \
    $WORK_DIR/title_txt.png  -gravity south -geometry +0+65 -composite \
    -  -gravity north -geometry +0+45 -composite miff:- | display
fi
confirm_preview

unset PICS IM_CMD1 IM_CMD2 IM_CMD3 IM_CMD4 IM_CMD5
###############################################################################
#             get information about videos and store in an array              #
###############################################################################

for ((i=0; i<${#IN_FILES[@]}; i++)); do
    echo "Getting stats on "${IN_FILES[i]}""
    mencoder_stats=( "${mencoder_stats[@]}" \
    "$(mencoder -quiet "${IN_FILES[i]}" -oac pcm -ovc copy -o /dev/null 2>&1)" )
done
#echo
#echo $SEPARATOR
#echo
# put in the log file in case anyone is interested
for ((i=0; i<${#IN_FILES[@]}; i++)); do
    VCODEC="$(awk '/VIDEO:/ {gsub(/\[|\]/, ""); print $2}' \
    <<< "${mencoder_stats[i]}")"
    V_BR="$(awk '/Video stream:/{print $3}'<<<"${mencoder_stats[i]}")"
    ACODEC="$(awk  '/Selected audio codec/ {gsub(/\[|\]/, ""); print $4}' \
    <<< "${mencoder_stats[0]}")"
    A_BR="$(awk  '/AUDIO:/ {print $7}' <<< "${mencoder_stats[i]}")"
    if [ -z "$A_BR" ]; then
        A_BR="No audio found"
    fi
    V_LENGTH="$(awk '/Video stream:/{print $10}'<<<"${mencoder_stats[i]}")"
    FPS="$(awk '/VIDEO:/ {print $6}' <<<"${mencoder_stats[i]}")"
    yecho
    echo -e "Stats for" "${IN_FILES[i]}" "\n" \
    "video codec:   " \
    "$VCODEC" "\n" \
    "video bitrate: " "$V_BR" "kbps" "\n" \
    "framerate:     " "$FPS" "fps" "\n" \
    "audio codec:   " \
    "$ACODEC" "\n" \
    "audio bitrate: " \
    "$A_BR" " kbps" "\n" \
    "video length:  " \
    "$V_LENGTH" " seconds" |tee -a $LOG_FILE
done
echo
echo $SEPARATOR

for ((i=0; i<${#mencoder_stats[@]}; i++)); do
    VID_LEN=( ${VID_LEN[@]}  "$(awk '/Video stream:/{print $10}' \
    <<<"${mencoder_stats[i]}")" )
done

for ((i=0; i<${#VID_LEN[@]}; i++)); do
    NEW_LENGTH=( ${NEW_LENGTH[@]}   ${VID_LEN[i]%.*} )
done
# find out longest video and shortest video 
for ((i=0; i<${#NEW_LENGTH[@]}; i++)); do
    val=${NEW_LENGTH[i]}
    [ -z "$MAX_VAL" ] || ((val > MAX_VAL)) && MAX_VAL=$val && max_key=$i
    if $ANI_SUB_MENU; then 
        [ -z "$MIN_VAL" ]  || ((val < MIN_VAL)) && MIN_VAL=$val && min_key=$i
    fi
done
# if shortest is less than 340 frames * $CHAPTERS then no animated submenu
if $ANI_SUB_MENU && [ $MIN_VAL -lt $(((340 * CHAPTERS) / 30)) ]; then
    echo -n "Sorry, the shortest length video must be greater than "
    echo "$(((340 * CHAPTERS) / 30)) seconds"
    echo "to use animated submenus."
    echo "${IN_FILES[min_key]} is only $MIN_VAL seconds long"
    exit 1
fi 
# allow animated menus of length of longest video
MAX_ANI_LENGTH=$(awk_math $FRAME_RATE times $ANI_MENU_LENGTH)
MAX_VAL_FRAMES="$(($MAX_VAL * 30))"
if [ $MAX_VAL_FRAMES -lt $MAX_ANI_LENGTH ]; then
    MAX_ANI_LENGTH=$MAX_VAL_FRAMES
fi
# if submenu selected, translate seconds of submenu length into # of frames
if $ANI_SUB_MENU; then
    ANI_SUBMENU_FRAMES=$(awk_math $FRAME_RATE times $ANI_SUBMENU_LENGTH)
fi

ANI_FRAMES=$MAX_ANI_LENGTH
if $STATIC; then
    FRAMES=1
else
    FRAMES=$ANI_FRAMES
fi

###############################################################################
#                           End of info block                                 #
###############################################################################

###############################################################################
#                       work on the clip title images                         #
###############################################################################
# extract images from the provided background video
echo
echo "Creating images from each video for the main menu"
for ((i=0; i<=NUM_FILES; i++)) ; do
    echo "Working on "${IN_FILES[$i]}""
    CREATE_IMG_CMD=(ffmpeg -i "${IN_FILES[$i]}"  $SEEK -vframes $FRAMES \
    -s "$THUMB_SIZE" "$WORK_DIR/pics/$i/%d.$IMG_FMT")
    echo -e "\nRunning: ${CREATE_IMG_CMD[@]}\n" | fold -bs >> $LOG_FILE

    SED_VAR="frame="
    if "${CREATE_IMG_CMD[@]}" >> $LOG_FILE.tmp 2>&1;then
        cleanlog 3
    else
        cleanlog 3
        runtime_error "Problem creating images from the video."
        exit 1
    fi

done
# create the pics for background image
    if [ -z "$BG_PIC" ]; then
        echo
        echo "Creating a black background"
        BG_PIC="$WORK_DIR/pics/template.jpg"
        convert  -size $VIDSIZE xc:"#161514" "$BG_PIC"
        cp "$BG_PIC" "$WORK_DIR/submenu_template.jpg"
    else
        convert -resize $VIDSIZE! "$BG_PIC" "$WORK_DIR/pics/template.jpg"
        convert -size $VIDSIZE xc:"#161514" "$WORK_DIR/submenu_template.jpg"
    fi

echo

##############################################################################
#                     spumux and dvdauthor stuff                             #
##############################################################################
echo
echo "Creating the highlight and selection PNGs for the main menu"
#echo
GEO="${GEO_ARRAY[NUM_FILES]/x/,}"
(
cat  <<EOF
rectangle 0,0 $GEO
EOF
)  > $WORK_DIR/draw_file

convert -size "${GEO_ARRAY[NUM_FILES]}+5+5"  xc:none \
-fill none +antialias -stroke '#DE7F7C' -strokewidth 4 -draw @draw_file \
-colors 3 "$WORK_DIR/Selectx1.png"
convert -size "${GEO_ARRAY[NUM_FILES]}+5+5" xc:none \
-fill none +antialias -stroke '#188DF6' -strokewidth 4 -draw @draw_file \
-colors 3 "$WORK_DIR/Highlightx1.png"
rm -f draw_file
for button in Select Highlight; do
    montage -background none \
    $(for ((i=0; i<=NUM_FILES; i++)); do echo $WORK_DIR/${button}x1.png;done) \
    -tile ${TILE_ARRAY[NUM_FILES]} -geometry ${GEO_ARRAY[NUM_FILES]}+5+5 \
    -bordercolor none -mattecolor transparent miff:- |
    convert  -colors 3 -size 720x480 xc:none - -gravity north -geometry +0+45 \
    -composite  "$WORK_DIR/${button}.png"
done

if $SUB_MENU; then
    echo
    echo "Creating the highlight and selection PNGs for the submenus"
    echo
    GEO="${GEO_ARRAY[CHAPTERS - 1]/x/,}"
(
cat  <<EOF
rectangle 0,0 $GEO
EOF
)  > $WORK_DIR/draw_file
    convert -size "${GEO_ARRAY[CHAPTERS - 1]}+5+5" xc:none -fill none \
    +antialias -stroke '#DE7F7C' -strokewidth 4 -draw @draw_file \
    -colors 3 "$WORK_DIR/Submenu_Selectx1.png"
    convert -size "${GEO_ARRAY[CHAPTERS - 1]}+5+5" xc:none -fill none \
    +antialias -stroke '#188DF6' -strokewidth 4 -draw @draw_file \
    -colors 3 "$WORK_DIR/Submenu_Highlightx1.png"
    for button in Select Highlight; do
        montage -background none \
        $(for ((i=0; i<CHAPTERS; i++)); do
        echo $WORK_DIR/Submenu_${button}x1.png;done) \
        -tile ${TILE_ARRAY[CHAPTERS - 1]} \
        -geometry ${GEO_ARRAY[CHAPTERS - 1]}+5+5 \
        -bordercolor none -mattecolor transparent miff:- |

        convert  -colors 3 -size 720x480 xc:none  - \
        -gravity north -geometry +0+45  \
        -composite  $WORK_DIR/Submenu_${button}.png
    done
fi

# make appropriate chapter lengths for each video
# get chapter lengths by dividing by $CHAPTERS, then getting running totals
for ((i=0; i<${#NEW_LENGTH[@]}; i++)); do
    CHAPT_INTERVALS=( ${CHAPT_INTERVALS[@]} "$(awk_math ${NEW_LENGTH[i]} by $CHAPTERS float)" )
done
# and format in HH:MM:SS
for len in ${CHAPT_INTERVALS[@]}; do
    L=( ${L[@]} $(for ((i=1; i<CHAPTERS; i++)) ; do echo "$len";done) )
    chapt_intervals=$(running_total <<< ${L[@]})
    chapters="$(for c in $chapt_intervals; do echo $(format_seconds $c); done)"
    chapters="00:00:00.000 $chapters"
    CHAPTS=$(for i in $chapters; do echo -n $i,;done|sed 's/,$//')
    CHAPT_ARRAY=( ${CHAPT_ARRAY[@]} $CHAPTS )
    unset L chapt_intervals cmd
done
# debug chapters
for ((i=0; i<${#IN_FILES[@]}; i++)); do
    echo -e "Chapters for "${IN_FILES[i]}" are: \n${CHAPT_ARRAY[i]}\n"
done
# make xml files, and run dvdauthor and spumux
START="00:00:00.0"
MAIN_POST="        <post> jump cell 1; </post>"
if $MENU_FADE; then
    . todisc-fade-routine
    END_TIME=$(format_seconds $THUMBS_FADE_OUT_END_TIME)
    END=" end=\"$END_TIME\""
    START=$(format_seconds $THUMBS_FADE_IN_START_TIME)
    POST="<post> jump cell 1; </post>"
elif $STATIC; then
    PAUSE_TIME="inf"
fi
if [ "$PAUSE_TIME" = "inf" ]; then
    unset MAIN_POST
fi

(
    cat <<EOF
<subpictures>
   <stream>
     <spu force="yes" start="$START"$END
          highlight="$WORK_DIR/Highlight.png"
          select="$WORK_DIR/Select.png"
          autooutline="infer"
          autoorder="rows"/>
   </stream>
 </subpictures>
EOF
)  > "$SPUMUX_XML"
# make submenu spumux.xml
if $SUB_MENU; then
(
    cat <<EOF
<subpictures>
   <stream>
     <spu force="yes" start="00:00:00.0"
          highlight="$WORK_DIR/Submenu_Highlight.png"
          select="$WORK_DIR/Submenu_Select.png"
          autooutline="infer"
          autoorder="rows"/>
   </stream>
 </subpictures>
EOF
) > "$SUBMENU_SPUMUX_XML"
fi
if $SUB_MENU; then
    JUMP=menu
    POST="        <post> jump cell 1; </post>"
    if $ANI_SUB_MENU; then
        PAUSE=" pause=\"5\""
    else
        PAUSE=" pause=\"inf\""
        unset POST
    fi
else
    JUMP=title
fi
if [ "$TARGET" = "dvd" ]; then
# make dvdauthor.xml
(
    cat <<EOF
<?xml version="1.0" encoding="utf-8"?>
<dvdauthor dest="$OUT_DIR" jumppad="1">
  <vmgm>
    <menus>
      <pgc>
        <post>jump titleset 1 menu;</post>
      </pgc>
    </menus>
  </vmgm>
  <titleset>
    <menus>
      <pgc>
$(for ((i=1; i<=$V_ARRAY_TOTAL; i++)); do
    if $SUB_MENU; then
        JUMP_INC=$(($i + 1))
    else
        JUMP_INC=$i
    fi
    echo -e "        <button name=\"$i\">jump $JUMP $JUMP_INC;</button>"
done)
        <vob file="$MENU_FILE" pause="$PAUSE_TIME"/>
$MAIN_POST
      </pgc>
$(if $SUB_MENU; then
    echo -ne "      <pgc>\n"
        for ((Y=1; Y<=$V_ARRAY_TOTAL; Y++)); do
            for ((i=1; i<=CHAPTERS; i++)); do
                if [ -n ${CHAPT_ARRAY[i-1]} ]; then
                    echo -e "        <button name=\"$i\">jump title $Y chapter $i;</button>"
                fi
            done
            echo -e "        <vob file=\"$WORK_DIR/Menu$Y.mpg\"$PAUSE/>"
echo "$POST"
            echo "      </pgc>"
            echo "      <pgc>"
        done | sed '$d'
fi)    
    </menus>
    <titles>
$(for ((i=0; i<${#IN_FILES[@]}; i++)); do
    echo -e "      <pgc>"
    echo -ne "        <vob file=\"${IN_FILES[i]}\""
    echo -e  " chapters=\""${CHAPT_ARRAY[i]}"\"/>"
    echo -e "        <post>call vmgm menu 1;</post>"
    echo -e "      </pgc>"
done)
    </titles>
  </titleset>
</dvdauthor> 
EOF
) |sed '/^$/d' >> "$DVDAUTHOR_XML"
fi
##############################################################################
#                            Animenu stuff                                   #
##############################################################################

# do submenu 1st for debug purposes
if $SUB_MENU; then
    yecho
    yecho "Building submenus"
    yecho
    yecho "Creating images for each chapter"
    for ((i=0; i<${#IN_FILES[@]}; i++)); do
        yecho "Creating a transparent title PNG"
		convert -size 620x100 xc:none -font "$MENU_FONT" \
		-pointsize $MENU_FONTSIZE \
		-fill black -draw "gravity center text 2,2 \"${TITLES[i]}\"" \
		-stroke "$STROKE" -strokewidth 1 \
		-fill "$TITLE_COLOUR" -stroke "$STROKE" \
		-draw "gravity center text 1,1 \"${TITLES[i]}\"" miff:- | \
		convert -trim +repage - -blur 0x0.4 $WORK_DIR/title${i}_txt.png

        # which is harmless as they get removed, but needs to be tweaked         
        if $ANI_SUB_MENU; then
            JPEG2YUV_OPTS=(-n $ANI_SUBMENU_FRAMES)
            PICS_IN=($WORK_DIR/animenu/%0d.$SM_IMG_FMT)
            PICS_OUT=($WORK_DIR/animenu/chapt)
            CUT_TIME=340

        else  # not animated submenu
            JPEG2YUV_OPTS=(-n 1 -l 60)
            PICS_IN=($WORK_DIR/${i}-submenu.$SM_IMG_FMT)
            PICS_OUT=($WORK_DIR/${i}-chapt)
            CUT_TIME=1
        fi    
        CUT_START=$(awk_math $FRAME_RATE times $SEEK_VAL)
        counts=$(awk_math ${CHAPT_INTERVALS[i]} times $FRAME_RATE)
        CUT=( $CUT_START $(running_total <<<  $(for ((a=0; a<CHAPTERS ; a++)); \
        do echo -n "$counts ";done)) )
        for ((c=0; c<${#CUT[@]}; c++)); do
            cmd[c]=$((${CUT[c]}))-$((${CUT[c]} + CUT_TIME))
        done
        key=$((${#cmd[@]} - 1))
        unset cmd[key]
        CMD="${cmd[@]}"
        TCODE_CMD=(transcode -q 0 -i "${IN_FILES[i]}" -o "${PICS_OUT[@]}" \
        -f $FRAME_RATE -Z ${GEO_ARRAY[CHAPTERS - 1]},fast -J cut="$CMD" -y $SM_IMG_FMT,null)
        yecho
        yecho "Creating chapter images for "${IN_FILES[i]}""

        yecho "Running  "${TCODE_CMD[@]}"" >> $LOG_FILE
        yecho "Running  "${TCODE_CMD[@]}""
        if "${TCODE_CMD[@]}" >> $LOG_FILE.tmp 2>&1; then
            cleanlog 1
        else
            cleanlog 1
            runtime_error "Problem creating images from the video."
            exit 1
        fi
        unset TCODE_CMD

        if $ANI_SUB_MENU; then
            # FIXME make sure $CHAPTERS number of images got created
            # move 340 images to each subdir:  $WORK_DIR/animenu/{0,1,2,3,etc}
            for ((a=0; a<CHAPTERS; a++)); do
                pics=( $(find $WORK_DIR/animenu/ -maxdepth 1 -name chapt\*.$SM_IMG_FMT|
                head -n 340) )
                for f in ${pics[@]}; do
                    mv $f $WORK_DIR/animenu/$a
                done
            done
            for ((a=0; a<CHAPTERS; a++)); do
                find $WORK_DIR/animenu/$a/ -name chapt\*.$SM_IMG_FMT|head -n 20|xargs rm
                find $WORK_DIR/animenu/$a/ -name chapt\*.$SM_IMG_FMT|tail -n 20|xargs rm
            done
            echo
            echo "Making montage images for  "${IN_FILES[i]}""

            o=1; sp="/-\|/-\|";  echo -n ' '
            for ((a=1; a<300; a++)); do
                echo -en "\b${sp:o++%${#sp}:1}"
                for ((b=0; b<CHAPTERS; b++)); do
                    IMGS=( "${IMGS[@]}" $(find $WORK_DIR/animenu/$b \
                    -name \*.$SM_IMG_FMT|head -n $a|sed  -n -e "$a p") )
                done
                IM_CMD=(montage ${IMGS[@]} -tile ${TILE_ARRAY[CHAPTERS - 1]} \
                -geometry ${GEO_ARRAY[CHAPTERS - 1]}+5+5 -bordercolor '#161514' \
                -mattecolor '#161514' -background '#161514' miff:-)
                IM_CMD2=(convert $WORK_DIR/submenu_template.jpg \
                $WORK_DIR/title${i}_txt.png  -gravity south \
                -geometry +0+55 -composite -  -gravity north -geometry +0+45 \
                -composite $WORK_DIR/animenu/$a.$SM_IMG_FMT)
 
                "${IM_CMD[@]}" | "${IM_CMD2[@]}"
                unset IMGS
            done

            unset IM_CMD IM_CMD2 d f PIC
 
        else # not $ANI_SUB_MENU

            yecho
            yecho "Making montage images for  "${IN_FILES[i]}""
            # just use $CHAPTERS number of images
            imgs=( $(find $WORK_DIR -name ${i}-chapt000\*.$SM_IMG_FMT|head -n $CHAPTERS) )
            # create frames for the chapter thumbs
            for PIC in "${imgs[@]}"; do
                echo -en "\b${sp:o++%${#sp}:1}"
                convert -background '#141614' -frame 5x5 \
                -bordercolor none -mattecolor "#444744" "$PIC" miff:- |
                convert -resize "${GEO_ARRAY[CHAPTERS - 1]}"! - "$PIC"
            done

            IM_CMD=(montage "${imgs[@]}" -tile ${TILE_ARRAY[CHAPTERS -1]} -geometry \
            ${GEO_ARRAY[CHAPTERS - 1]}+5+5 -background '#141614' miff:-)
            IM_CMD2=(convert $WORK_DIR/submenu_template.jpg \
            $WORK_DIR/title${i}_txt.png  -gravity south -geometry +0+55 \
            -composite - -gravity north -geometry +0+45 -composite \
            $WORK_DIR/${i}-submenu.$SM_IMG_FMT)
#            echo "Running "${IM_CMD[@]}" | "${IM_CMD2[@]}""
            "${IM_CMD[@]}" | "${IM_CMD2[@]}"
        fi

        yecho
        yecho "Converting chapter montages of "${IN_FILES[i]}" to m2v video format"
        IMG_STREAM_CMD1=(jpeg2yuv -v 0 -f $FRAME_RATE -I p \
        "${JPEG2YUV_OPTS[@]}" -L 1 -b 1  -j "${PICS_IN[@]}")
        ENC_CMD1=(ffmpeg   -f yuv4mpegpipe -i - -r $FRAME_RATE -s $VIDSIZE \
        -tvstd $TV_STANDARD $FFMPEG_OPTS -y $WORK_DIR/menu$i.m2v)
        yecho "Running "${IMG_STREAM_CMD1[@]}" | "${ENC_CMD1[@]}""
        if "${IMG_STREAM_CMD1[@]}" | "${ENC_CMD1[@]}" >> $LOG_FILE.tmp 2>&1; then
            cleanlog 3
        else
            cleanlog 3
            runtime_error
        fi
        rm -f $WORK_DIR/animenu/*.$IMG_FMT
    done    
    unset IMG_STREAM_CMD1 ENC_CMD1 JPEG2YUV_OPTS
    for ((s=0; s<=NUM_FILES; s++)); do
        # create audio background for either animated or plain submenus
        yecho
        yecho "Creating an audio background"
        yecho "Working on submenu audio for "${IN_FILES[s]}""
        if $SUBMENU_AUDIO; then
            if [ "${SM_AUDIO[s]}" = "none" ]; then # user asked for silence
                TIME=`vid_length "$WORK_DIR/menu$s.m2v"`
                BGAUDIO_CMD=(ffmpeg -f s16le -i /dev/zero -t $TIME \
                $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT)
            elif [ -n "$SM_AUDIO_FILE" ]; then # user supplied "1" audio file
                COPY_AC3=(cp -v $WORK_DIR/submenu.$AUDIO_EXT \
                $WORK_DIR/menu$s.$AUDIO_EXT)
                TIME=$(ffmpeg -i "$SM_AUDIO_FILE" 2>&1|awk '/Duration/ {print $2}')
                TIME=${TIME/,/}
                BGAUDIO_CMD=(ffmpeg -i "$SM_AUDIO_FILE" -ar 48000 -ac 2 -acodec pcm_s16le -y \
                $WORK_DIR/submenu.wav)
            else # SM_AUDIO[s] is an audio file we will process it
            TIME=$(ffmpeg -i "${SM_AUDIO[s]}" 2>&1|awk '/Duration/ {print $2}')
            TIME=${TIME/,/}
            # make seperate wavs for each supplied audio bg for each submenu 
            BGAUDIO_CMD=(ffmpeg -i ${SM_AUDIO[s]} -ar 48000 -ac 2 -acodec pcm_s16le -y \
            $WORK_DIR/menu$s.wav)
            BGAUDIO_CMD2=(ffmpeg -i $WORK_DIR/menu$s.wav \
            $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT)
            fi
        else # no supplied audio for submenu so create silence
            TIME=`vid_length "$WORK_DIR/menu$s.m2v"`
            BGAUDIO_CMD=(ffmpeg -f s16le -i /dev/zero -t $TIME \
            $AUDIO_OPTS -y $WORK_DIR/menu$s.$AUDIO_EXT)
        fi
        if [ ! -e $WORK_DIR/submenu.wav ]; then # only run if no wav
            yecho "Running "${BGAUDIO_CMD[@]}"" >> "$LOG_FILE.tmp" 2>&1
            cleanlog 1
            if "${BGAUDIO_CMD[@]}" >> "$LOG_FILE.tmp" 2>&1; then #run command
                cleanlog 3
            else
                cleanlog 3
                runtime_error
            fi
        fi
        # convert to DVD/SVCD format as long as "none" is not called for
        if "$SUBMENU_AUDIO" && [[ ! "${SM_AUDIO[s]}" = "none" && -z "$SM_AUDIO_FILE" ]]; then
            if $SM_AUDIO_FADE; then
                TIME=$(ffmpeg -i "$WORK_DIR/menu$s.wav" 2>&1|awk '/Duration/ {print $2}')
                TIME=${TIME/,/}
                echo -e "Running:
                sox $WORK_DIR/menu$s.wav \
                $WORK_DIR/menu$s-processed.wav fade t $SM_FADE $TIME $SM_FADE" |
                sed 's/    */ /g'|sed -e "s/^ *//"

                sox -q $WORK_DIR/menu$s.wav \
                $WORK_DIR/menu$s-processed.wav fade t $FADE $TIME $FADE
                rm $WORK_DIR/menu$s.wav
                mv $WORK_DIR/menu$s-processed.wav $WORK_DIR/menu$s.wav
            fi
            echo "Running "${BGAUDIO_CMD2[@]}"" >> "$LOG_FILE.tmp" 2>&1
            cleanlog 1
            if "${BGAUDIO_CMD2[@]}" >> "$LOG_FILE.tmp" 2>&1; then
                cleanlog 3
            else
                cleanlog 3
                runtime_error
            fi
            unset TIME
        fi
        # if "1" audio file, then convert it if it has not been done yet
        if [[ -n "$SM_AUDIO_FILE" && ! -e $WORK_DIR/submenu-processed.wav ]]; then 
            if $AUDIO_FADE; then
                TIME=$(ffmpeg -i "$WORK_DIR/submenu.wav" 2>&1|awk '/Duration/ {print $2}')
                TIME=${TIME/,/}
                echo -e "Running:
                sox $WORK_DIR/submenu.wav \
                $WORK_DIR/submenu-processed.wav fade t $FADE $TIME $FADE" |sed 's/    */ /g'

                sox -q $WORK_DIR/submenu.wav \
                $WORK_DIR/submenu-processed.wav fade t $FADE $TIME $FADE
                rm -f $WORK_DIR/submenu.wav
                cp  $WORK_DIR/submenu-processed.wav $WORK_DIR/submenu.wav
            fi
            BGAUDIO_CMD3=(ffmpeg -i $WORK_DIR/submenu.wav \
            $AUDIO_OPTS -y $WORK_DIR/submenu.$AUDIO_EXT)
            if [ -e $WORK_DIR/submenu.$AUDIO_EXT ]; then # if file exists do nothing
                :
            else 
                echo "Running "${BGAUDIO_CMD3[@]}"" >> "$LOG_FILE.tmp" 2>&1
                if "${BGAUDIO_CMD3[@]}" >> "$LOG_FILE.tmp" 2>&1; then
                    cleanlog 3
                else
                    cleanlog 3
                    runtime_error
                fi
            fi
        fi
        # copy the final file for each submenu if only 1 supplied
        "${COPY_AC3[@]}"
        yecho
        yecho "Multiplexing video and audio together"
        S=$((s + 1))
        MPLEX_CMD=(mplex -V -f $MPLEX_FORMAT -b 230 -o $WORK_DIR/menu$S.mpg \
        $WORK_DIR/menu$s.$AUDIO_EXT $WORK_DIR/menu$s.m2v)
        echo "Running: "${MPLEX_CMD[@]}"" >> $LOG_FILE.tmp
        cleanlog 1
        if "${MPLEX_CMD[@]}" >> $LOG_FILE.tmp 2>&1; then
            cleanlog 1
        else
            cleanlog 1
            runtime_error
        fi
        # remove wav to save space
        rm -fv $WORK_DIR/menu$s.wav
    done
    rm -fv $WORK_DIR/submenu.{wav,$AUDIO_EXT}
fi

##############################################################################
#                      Work on main menu                                     #
##############################################################################
yecho
yecho "Building main menu"
yecho
if [ -n "$BG_VIDEO" ]; then
    yecho "Getting background video from $BG_VIDEO"
    FFMPEG_CMD="ffmpeg -i \"$BG_VIDEO\" $SEEK -vframes $FRAMES \
    -s $VIDSIZE \"$WORK_DIR/bg/%d.jpg\""
    yecho "Extracting/resizing background images with the following command:"
    yecho "$FFMPEG_CMD"
    # Filter ffmpeg output
    LOG_FILTER="sed s/\\r/\\r\\n/g"
    # Run command and check for failure
    if ! cmd_exec "$FFMPEG_CMD"; then
        runtime_error "Problem creating images from the background video"
    fi
    # make sure there are enough pics to make a bg video 
    IMAGES=( "${IMAGES[@]}" \
    $(find $WORK_DIR/bg -maxdepth 1 -name \*[1-9]\*.jpg) )
    last_pic=${#IMAGES[@]}
    next_pic=$(($last_pic + 1))
    if [ $last_pic -lt $MAX_ANI_LENGTH ]; then
        for ((l=next_pic; l<=MAX_ANI_LENGTH; l++)); do
            cp $WORK_DIR/bg/${last_pic}.jpg $WORK_DIR/bg/$l.jpg
        done
    fi
    unset IMAGES PICS last_pic next_pic
fi
unset FFMPEG_CMD

yecho
yecho "Adding title to images and resizing"
for ((i=0; i<=NUM_FILES; i++)); do
    PICS=( "${PICS[@]}" \
    $(find $WORK_DIR/pics/$i -maxdepth 1 -name \*[1-9]\*.$IMG_FMT) )
    yecho "Working on images from ${IN_FILES[i]}"
    o=1; sp="/-\|/-\|";  echo -n ' '

    for pic in "${PICS[@]}"; do
        echo -en "\b${sp:o++%${#sp}:1}"
        IM_CMD0=(composite -compose CopyOpacity $THUMB_MASK +matte \
        "$pic")
        IM_CMD1=(convert -trim +repage -)
        IM_CMD2=(montage -  -geometry +4+4 -compose Copy -background none \
        -fill "$THUMB_TEXT_COLOUR" -font "$THUMB_FONT" -pointsize $THUMB_FONTSIZE -title "${TITLES[i]}")

        IM_CMD2b=(convert -resize $THUMB_SIZE! -)
        IM_CMD2c=(composite -gravity center -compose DstOver $WORK_DIR/feather_mask2.png -) 
        
        IM_CMD3=(montage -geometry +4+4 -background '#161514' \
        -fill '#C6C6C6' -pointsize $THUMB_FONTSIZE -title "${TITLES[i]}" "$pic")
        IM_CMD4=(convert -background '#161514' -frame 5x5 \
        -bordercolor none -mattecolor "#444744" -)
        IM_CMD5=(convert -resize $THUMB_SIZE! - $pic)
        if $FEATHER; then
#            "${IM_CMD0[@]}" miff:- | "${IM_CMD2[@]}" miff:- | "${IM_CMD1[@]}" miff:- |
            "${IM_CMD0[@]}" miff:- | "${IM_CMD2[@]}" miff:- |
            "${IM_CMD2b[@]}" miff:- |"${IM_CMD2c[@]}" miff:- |
            "${IM_CMD1[@]}" miff:- | "${IM_CMD5[@]}"
        else
            "${IM_CMD3[@]}" miff:- | "${IM_CMD4[@]}" miff:- | "${IM_CMD5[@]}"
        fi
        unset PICS IM_CMD0 IM_CMD1 IM_CMD2 IM_CMD3 IM_CMD4 IM_CMD5
    done

    # make sure all animated thumbs finish at the same time 
    if ! $STATIC; then
        IMAGES=( "${IMAGES[@]}" \
        $(find $WORK_DIR/pics/$i -maxdepth 1 -name \*[1-9]\*.$IMG_FMT) )
        last_pic=${#IMAGES[@]}
        next_pic=$(($last_pic + 1))
        if [ $last_pic -lt $MAX_ANI_LENGTH ]; then
            for ((l=next_pic; l<=MAX_ANI_LENGTH; l++)); do
                cp $WORK_DIR/pics/$i/${last_pic}.$IMG_FMT $WORK_DIR/pics/$i/$l.$IMG_FMT
            done
        fi
        unset IMAGES PICS last_pic next_pic
   fi
done

yecho
yecho "Making final montages and compositing onto background with title"
yecho
if $MENU_FADE && ! $STATIC; then
    if [ -z "$BG_VIDEO" ]; then
        for ((frame=0; frame<=ANI_MENU_END_FRAME; frame++)); do
            # copy template for fade out beginning and end frames
            cp $WORK_DIR/pics/template.jpg $WORK_DIR/bg/$(($frame + 1)).jpg
        done
    fi      
    for ((frame=0; frame<=BACKGROUND_FADE_IN_END_FRAME; frame++)); do
        D=`get_bg_opacity`
        composite -dissolve $D $WORK_DIR/bg/$(($frame + 1)).jpg $WORK_DIR/black.jpg \
        $WORK_DIR/bg/$(($frame + 1)).jpg
    done
    for ((frame=BACKGROUND_FADE_OUT_START_FRAME; frame<BACKGROUND_FADE_OUT_END_FRAME; frame++)); do
        D=`get_bg_opacity`
        composite -dissolve $D $WORK_DIR/bg/$(($frame + 1)).jpg $WORK_DIR/black.jpg \
        $WORK_DIR/bg/$(($frame + 1)).jpg
    done

    o=1; sp="/-\|/-\|";  echo -n ' '  # initialize spinner
    for ((frame=0; frame<ANI_MENU_END_FRAME; frame++)); do
        # set dissolve vars from todisc-fade-routine functions
        BC=$(get_title_opacity)
        B=$(awk -F ':' '{print $1'}<<<$BC)
        C=$(awk -F ':' '{print $2'}<<<$BC)
        S=$(get_thumb_opacity)

        echo -en "\b${sp:o++%${#sp}:1}" # start spinner

        ANI_PICS=( $(find $WORK_DIR/pics/*[0-9]* -maxdepth 1 -name $((frame + 1)).$IMG_FMT) )
        BG_PIC=$(find $WORK_DIR/bg -name $(($frame + 1)).jpg)
        # create the montage from the images in each video dir
        MONTAGE_CMD1=(montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[NUM_FILES]} \
        -geometry ${GEO_ARRAY[NUM_FILES]}+5+5 -background none)
        #  dissolve the finished montages onto the background
        MONTAGE_CMD2=(composite -dissolve $S -gravity north \
        -geometry +0+45 - $WORK_DIR/bg/$(($frame + 1)).jpg -background none)
        # if MIST is called for, this dissolves the mist onto the background
        MONTAGE_CMD3=(composite -dissolve $B -gravity south -geometry +0+45 \
        $WORK_DIR/white.png -)
        # finally, we dissolve the title onto the MIST (or plain background)
        MONTAGE_CMD4=(composite -dissolve $C -gravity south -geometry +0+65 \
        $WORK_DIR/title_txt.png - -background none $WORK_DIR/animenu/$(($frame + 1)).jpg)
        # pipe all of above commands if using MIST
        if $MIST; then
            # debug echo only
#            echo "Running "${MONTAGE_CMD1[@]}" miff:- | "${MONTAGE_CMD2[@]}" miff:- |"
#            echo  ""${MONTAGE_CMD3[@]}" miff:- | "${MONTAGE_CMD4[@]}""
            "${MONTAGE_CMD1[@]}" miff:- | "${MONTAGE_CMD2[@]}" miff:- |
            "${MONTAGE_CMD3[@]}" miff:- | "${MONTAGE_CMD4[@]}"
        else  # no mist: pipe all commands but the mist command
             "${MONTAGE_CMD1[@]}" miff:- | "${MONTAGE_CMD2[@]}" miff:- |
            "${MONTAGE_CMD4[@]}"
        fi
    done
# copy a few black frames to make sure end frame is really "black"
    for ((i=ANI_MENU_END_FRAME; i<ANI_MENU_END_FRAME+6; i++)); do
        cp $WORK_DIR/black.jpg $WORK_DIR/animenu/$i.jpg
    done
else # Do not do menu fade
    if $TRANSPARENT; then
         o=1; sp="/-\|/-\|";  echo -n ' '  # initialize spinner
         for (( count=1; count<=$MAX_ANI_LENGTH; count++)); do
            echo -en "\b${sp:o++%${#sp}:1}"
            ANI_PICS=$(find $WORK_DIR/pics/*[0-9]* -maxdepth 1 -name $count.$IMG_FMT)
            IM_CMD1=(montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[NUM_FILES]} \
            -geometry ${GEO_ARRAY[NUM_FILES]}+5+5 -background none miff:-)
            IM_CMD2=(composite -dissolve $OPACITY \
            -gravity north -geometry +0+45 - \
            $WORK_DIR/pics/template.jpg -background none miff:-)
            IM_CMD3=(composite -dissolve 30 -gravity south -geometry +0+45 \
            $WORK_DIR/white.png - miff:-)
            IM_CMD4=(convert - $WORK_DIR/title_txt.png  \
            -gravity south -geometry +0+65 -composite \
            $WORK_DIR/animenu/$count.jpg )
            if $MIST; then
                "${IM_CMD1[@]}" | "${IM_CMD2[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
            else
                "${IM_CMD1[@]}" | "${IM_CMD2[@]}" | "${IM_CMD4[@]}"
            fi
            rm -f ${ANI_PICS[@]}
        done
    else # Not transparent
        o=1; sp="/-\|/-\|";  echo -n ' '  # initialize spinner
        for (( count=1; count <=FRAMES; count++)); do
            echo -en "\b${sp:o++%${#sp}:1}"
            ANI_PICS=$(find $WORK_DIR/pics/*[0-9]* -maxdepth 1 -name $count.$IMG_FMT)

            # make final montages and composite onto grey background with title
            IM_CMD0=(montage ${ANI_PICS[@]} -tile ${TILE_ARRAY[NUM_FILES]} \
            -geometry ${GEO_ARRAY[NUM_FILES]}+5+5 -background none miff:-)
            IM_CMD1=(convert $WORK_DIR/pics/template.jpg \
            -  -gravity north -geometry +0+45 -composite miff:-)
            IM_CMD2=(convert $WORK_DIR/bg/$count.jpg \
            -  -gravity north -geometry +0+45 -composite miff:-)
            IM_CMD3=(composite -dissolve 30 -gravity south -geometry +0+45 \
            $WORK_DIR/white.png - miff:-)
            IM_CMD4=(convert - $WORK_DIR/title_txt.png  \
            -gravity south -geometry +0+65 -composite \
            $WORK_DIR/animenu/$count.jpg )
            if $MIST && ! $STATIC; then
                "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
            elif $MIST && ! $STATIC && test -n "$BG_VIDEO"; then
                "${IM_CMD0[@]}" | "${IM_CMD2[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
            elif ! $MIST && ! $STATIC && test -n "$BG_VIDEO"; then
                "${IM_CMD0[@]}" | "${IM_CMD2[@]}" | "${IM_CMD4[@]}"
            elif $MIST && $STATIC; then
                "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD3[@]}" | "${IM_CMD4[@]}"
            elif ! $MIST && $STATIC; then
                "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD4[@]}"   
            else
                "${IM_CMD0[@]}" | "${IM_CMD1[@]}" | "${IM_CMD4[@]}"
            fi
            rm -f ${ANI_PICS[@]}
        done
    fi    
fi

echo
echo "Converting images to video stream and encoding to DVD-compliant format"
# convert images to video stream and encode to dvd compliant m2v
if $STATIC; then
    JPEG2YUV_OPTS=(-n 1 -l 60)
    PICS_IN="$WORK_DIR/animenu/1.jpg"
else  # animated menu
    if $MENU_FADE; then
        JPEG2YUV_OPTS="-n $((ANI_MENU_END_FRAME + 6))"
    else
        JPEG2YUV_OPTS="-n $ANI_FRAMES"
    fi
    PICS_IN="$WORK_DIR/animenu/%d.jpg"
fi
ENC_CMD1=(jpeg2yuv -v 0 -f $FRAME_RATE -I p "${JPEG2YUV_OPTS[@]}" -L 1 -b1 \
-j "$PICS_IN")
ENC_CMD2=(ffmpeg   -f yuv4mpegpipe -i - -an -r $FRAME_RATE -s $VIDSIZE \
-tvstd $TV_STANDARD $FFMPEG_OPTS -y $WORK_DIR/intro.m2v)
yecho
echo "Running "${ENC_CMD1[@]}" | "${ENC_CMD2[@]}""
if "${ENC_CMD1[@]}" | "${ENC_CMD2[@]}" >> $LOG_FILE.tmp 2>&1; then
    cleanlog 3
else
    cleanlog 3
    runtime_error
fi
echo
echo "Cleaning up montage images"
rm -fr $WORK_DIR/animenu/*.jpg

TIME=$(vid_length "$WORK_DIR/intro.m2v")
if ! $STATIC; then
    SEEK_CMD="-t $TIME"
fi
# create audio background for the main menu
if [ -z "$BG_AUDIO" ]; then # no audio supplied: use silence
    cat /dev/zero | nice -n 0 sox -t raw -c 2 -r 48000 -w \
    -s - $WORK_DIR/intro.wav  trim 0 $TIME
else # audio supplied: convert to wav then later to dvd/svcd format
    BGAUDIO_CMD=(ffmpeg -i "$BG_AUDIO" -ar 48000 -ac 2 -acodec pcm_s16le -y \
    $SEEK_CMD $WORK_DIR/intro.wav)
    yecho
    echo "Running "${BGAUDIO_CMD[@]}"" >> $LOG_FILE.tmp 2>&1
    if "${BGAUDIO_CMD[@]}" >> $LOG_FILE.tmp 2>&1; then
        cleanlog 3
    else
        cleanlog 3
        runtime_error
    fi
fi

unset BGAUDIO_CMD
if $AUDIO_FADE; then
    TIME=$(ffmpeg -i "$WORK_DIR/intro.wav" 2>&1|awk '/Duration/ {print $2}')
    TIME=${TIME/,/}
    echo "Running: "
    echo "sox $WORK_DIR/intro.wav $WORK_DIR/intro-processed.wav fade t \
    $FADE $TIME $FADE"
    sox $WORK_DIR/intro.wav \
    $WORK_DIR/intro-processed.wav fade t $FADE $TIME $FADE
    rm $WORK_DIR/intro.wav
    mv $WORK_DIR/intro-processed.wav $WORK_DIR/intro.wav
fi

unset TIME

# convert to proper audio format
BGAUDIO_CMD=(ffmpeg -i $WORK_DIR/intro.wav \
$AUDIO_OPTS -y $WORK_DIR/intro.$AUDIO_EXT)
if "${BGAUDIO_CMD[@]}" >> $LOG_FILE.tmp 2>&1; then
    cleanlog 3
    else
    cleanlog 3
    runtime_error
fi
unset BGAUDIO_CMD

echo
echo "Multiplexing main menu audio and video together"
# mplex main menu audio and video together
INTRO_MPLEX_CMD="mplex -V -f $MPLEX_FORMAT -b 230 -o $WORK_DIR/intro.mpg \
$WORK_DIR/intro.$AUDIO_EXT $WORK_DIR/intro.m2v"
echo -e "\nRunning: $INTRO_MPLEX_CMD\n" >> $LOG_FILE.tmp 
cleanlog 1
yecho
if ${INTRO_MPLEX_CMD[@]} >> $LOG_FILE.tmp 2>&1; then
    cleanlog 1
else
    cleanlog 1
    runtime_error
fi

echo
echo "Running spumux to create the main menu"
spumux "$SPUMUX_XML" < $WORK_DIR/intro.mpg > "$MENU_FILE"
if test -f "$MENU_FILE"; then
    echo "Menu file $MENU_FILE created"
else
    echo "Menu file $MENU_FILE is missing!"
fi

if $SUB_MENU; then
    echo "Creating submenus"
    for i in $(find $WORK_DIR/ -name menu[0-9]\*.mpg); do
#        spumux "$SUBMENU_SPUMUX_XML" < $i > ${i/menu/Menu}
        spumux "$SUBMENU_SPUMUX_XML" < $i > $(echo $i|sed 's/\(.*\)menu/\1Menu/')
    done
fi

echo "Running dvdauthor to create the DVD filesystem"
dvdauthor -x "$DVDAUTHOR_XML"

SCRIPT_END_TIME=`date +%s`
SCRIPT_TOT_TIME=`expr $SCRIPT_END_TIME \- $SCRIPT_START_TIME`
HHMMSS=`format_time $SCRIPT_TOT_TIME`

cleanup
echo $SEPARATOR
echo "todisc took $HHMMSS to finish on $CPU_MODEL $CPU_SPEED mhz"
echo $SEPARATOR
echo "Your new DVD should be in $OUT_DIR"
echo
echo "Thanks for using todisc."

